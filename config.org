#+title: SK Emacs configuration
#+author: SeungKi Kim
#+email: tttuuu888@gmail.com

* About
This is my personal Emacs setting.
* Init.el
=init.el= will generate =config.el= from =config.org= and then will load
=config.el=.

=file-name-handler-alist= will be set to =nil= and =gc-cons-threshold= will be
set to =most-positive-fixnum= in order to boost up the speed during the boot
time.

All the other settings will be located in =config.org=.
* Initial settings
** Commentary
This comment will be added on the top of =config.el=.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; config.el --- generated from config.org -*- lexical-binding: t -*-
  ;;
  ;;; Code:
#+END_SRC

** Emacs -init
If Emacs is executed with an =-init= argument, =parallel install= process is
performed.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (member "-init" command-line-args)
    (delete "-init" command-line-args)
    (require 'pinstall "~/.emacs.d/etc/pinstall.el")
    (pinstall-init))
#+END_SRC

** Package initialize
Process =package-initialize= first and set =package-archives= for boot time
speed up. =package-initialize= should be called again after boot up.

#+BEGIN_SRC emacs-lisp :tangle yes
  (package-initialize)
  (setq package-archives
        '(("gnu"   . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org"   . "https://orgmode.org/elpa/")))
#+END_SRC

** User-emacs-directory setting
From this point, =user-emacs-directory= is set to =~/.emacs.d/.local/= so that
all package local files would be hidden under the path.

=emacs-config-dir= would be used instead of =user-emacs-directory=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar emacs-config-dir user-emacs-directory)
  (setq user-emacs-directory (expand-file-name ".local/" emacs-config-dir))
  (unless (file-exists-p user-emacs-directory)
    (make-directory-internal user-emacs-directory))
#+END_SRC

Set =emacs-etc-dir= to indicate a folder containing extra files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar emacs-etc-dir (expand-file-name "etc/" emacs-config-dir))
  (unless (file-exists-p emacs-etc-dir)
    (make-directory-internal emacs-etc-dir))
#+END_SRC

** Custom file
=custom.el= will be saved under =~/.emacs.d/.local/= but will not be used.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Instead of using =custom.el=, insert the contents of the file directly here.

#+BEGIN_SRC emacs-lisp :tangle yes
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(backup-directory-alist (quote ((".*" . "/tmp/"))))
   '(blink-cursor-mode nil)
   '(completion-styles (quote (basic partial-completion emacs22 initials)))
   '(css-indent-offset 2)
   '(ediff-split-window-function (quote split-window-horizontally))
   '(fill-column 80)
   '(font-use-system-font t)
   '(indent-tabs-mode nil)
   '(inhibit-startup-screen t)
   '(make-backup-files nil)
   '(menu-bar-mode nil)
   '(mouse-wheel-progressive-speed nil)
   '(password-cache-expiry 900)
   '(scroll-bar-mode nil)
   '(send-mail-function (quote smtpmail-send-it))
   '(size-indication-mode t)
   '(split-height-threshold nil)
   '(split-width-threshold 140)
   '(tab-always-indent (quote complete))
   '(tab-width 4)
   '(tool-bar-mode nil)
   '(use-file-dialog nil)
   '(vc-follow-symlinks nil))
#+END_SRC

** User information
If =USER_FULL_NAME= and =USER_MAIL_ADDRESS= environment variables exist, update
=user_full_name= and =user_mail_address= variables.

#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((name (getenv "USER_FULL_NAME"))
        (mail (getenv "USER_MAIL_ADDRESS")))
    (when name (setq user-full-name name))
    (when mail (setq user-mail-address mail)))
#+END_SRC

** Color setting
Simple color setting function which has 'dark' and 'light' theme.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my-theme-setting (&optional dark-theme)
    (let ((fg-color (if (or dark-theme (not window-system)) "Gray80" "Black"))
          (bg-color (if (or dark-theme (not window-system)) "Gray23" "Ivory2")))
      (set-face-attribute 'default nil
                          :foreground fg-color :background bg-color)
      (set-face-attribute 'fringe nil
                          :background bg-color)
      (set-face-attribute 'header-line nil
                          :background bg-color :underline nil)
      (set-face-attribute 'vertical-border nil
                          :background bg-color)))
  (defun sk-light-theme () (interactive) (my-theme-setting))
  (defun sk-dark-theme  () (interactive) (my-theme-setting t))
#+END_SRC

Enable dark theme.

#+BEGIN_SRC emacs-lisp :tangle yes
  (my-theme-setting t)
#+END_SRC

** Yes-or-no -> y-or-n
Use =y-or-n= instead of =yes-or-no=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** M-up, M-down, M-left, and M-right keys.
M-up,down,left,right keys for moving to windows.

#+BEGIN_SRC emacs-lisp :tangle yes
  (windmove-default-keybindings 'meta)
#+END_SRC

** SK-mode-line
Simple mode line setting function.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun sk-mode-line ()
    (set-face-attribute 'mode-line nil
                        :foreground "Gray2"
                        :box nil)
    (set-face-attribute 'mode-line-inactive nil
                        :foreground "Gray55"
                        :box nil)
    (setq-default
     mode-line-format
     '("%e"
       (:eval
        (let* ((evil-info (and (featurep 'evil) evil-mode
                               (concat " " (upcase (symbol-name evil-state)))))
               (buffer-info (concat " %* %I " current-input-method-title))
               (buffer-name (propertize " %b " 'face 'mode-line-emphasis))
               (git-branch (format-mode-line '(vc-mode vc-mode)))
               (vc-info (and vc-mode (concat " (" (substring git-branch 5) ") ")))
               (mode-info (propertize
                           (concat " " (format-mode-line mode-name) " ")
                           'face 'mode-line-inactive))
               (line-info (format-mode-line " %l,%3c  "))
               (pos-info (format-mode-line "%p%% "))
               (right-info (concat line-info pos-info))
               (right-length (length right-info))
               (center-fill (propertize
                             " "
                             'face 'mode-line-inactive
                             'display
                             `((space :align-to
                                      (- (+ right right-fringe right-margin)
                                         ,right-length))))))
          (concat evil-info buffer-info buffer-name vc-info mode-info
                  center-fill
                  right-info))))))
#+END_SRC

Enable =sk-mode-line=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (sk-mode-line)
#+END_SRC
** SK-utils
Various useful functions.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun sharp-ifdef-insert (start end pre)
    (save-excursion
      (let ((end2 (if (and (equal evil-state 'visual)
                           (equal end (line-beginning-position)))
                      (1- end)
                    end)))
        (goto-char end2) (end-of-line) (insert "\n#endif")
        (goto-char start) (beginning-of-line) (insert pre "\n"))))

  (defun izero-insert (start end)
    "Intesrt #if 0 at the beginning of region and #endif at the end of region"
    (interactive "r")
    (sharp-ifdef-insert start end "#if 0"))

  (defun idef-insert (start end in)
    "Intesrt #ifdef at the beginning of region and #endif at the end of region"
    (interactive "r\nsDefine : ")
    (sharp-ifdef-insert start end (concat "#ifdef " in)))

  (defun find-file-in-tree (dir fname &optional project-root)
    "Find a file looking up to the HOME folder or root folder."
    (let ((file (concat dir fname))
          (parent (unless (or (equal "~" dir) (equal "/" dir))
                    (file-name-directory (directory-file-name dir)))))
      (cond ((and project-root
                  (file-exists-p (concat project-root fname)))
             project-root)
            ((file-exists-p file) dir)
            (parent (find-file-in-tree parent fname))
            (t nil))))

  (defun sk-make ()
    "Find a Makefile path and perform Make"
    (interactive)
    (let ((dir (find-file-in-tree default-directory
                                  "Makefile"
                                  (my-project-root-or-dir))))
      (if (equal dir nil)
          (message "Makefile is not found")
        (compile (concat "export LANG=en_US && make -j8 -C " dir)))))

  (defun sk-clean ()
    "Find a Makefile path and perform Clean"
    (interactive)
    (let ((dir (find-file-in-tree default-directory
                                  "Makefile"
                                  (my-project-root-or-dir))))
      (if (equal dir nil)
          (message "Makefile is not found")
        (compile (concat "export LANG=en_US && make -C " dir " clean")))))

  (defun sk-rebuild ()
    "Find a Makefile path, clean the project and rebuild it."
    (interactive)
    (let ((dir (find-file-in-tree default-directory
                                  "Makefile"
                                  (my-project-root-or-dir))))
      (if (equal dir nil)
          (message "Makefile is not found")
        (call-process "make" nil nil nil "-C" dir "clean")
        (compile (concat "export LANG=en_US && make -j8 -C " dir)))))

  (defun sk-clang-complete-make ()
    "Generate .clang_complete file."
    (interactive)
    (let ((file "./.clang_complete")
          (includes (shell-command-to-string
                     "find -type f -name '*.h' -printf '-I%h\n' | sort -u")))
      (write-region includes nil file)))

  (defun insert-date ()
    "Insert date at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %A")))

  (defun insert-date-and-time ()
    "Insert date and time at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %a %p %l:%M")))

  (defun nuke-all-buffers ()
    "kill all buffers, leaving *scratch* only"
    (interactive)
    (mapc (lambda (x) (kill-buffer x))
          (buffer-list))
    (delete-other-windows))

  (defun hide-ctrl-M ()
    "Hides the disturbing '^M' showing up in files containing mixed
  UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  (defun move-line (n)
    "Move the current line up or down by N lines."
    (interactive "p")
    (let ((col (current-column))
          (line-text
           (delete-and-extract-region (line-beginning-position)
                                      (line-beginning-position 2))))
      (forward-line n)
      (insert line-text)
      ;; restore point to original column in moved line
      (forward-line -1)
      (forward-char col)))

  (defun transpose-windows ()
    "Swap positions of 2 windows."
    (interactive)
    (let ((buffer1 (window-buffer (selected-window)))
          (buffer2 (window-buffer (select-window (next-window)))))
      (switch-to-buffer buffer1)
      (switch-to-buffer-other-window buffer2)))

  (defun buffer-save-or-load (num &optional restore)
    (if restore
        (progn
          (jump-to-register num)
          (message (concat "Windows are Restored by F" (number-to-string num))))
      (window-configuration-to-register num)
      (message (concat "Windows are saved to F" (number-to-string num)))))

  (defun tmux-running-p ()
    "Check if tmux is currently running or not."
    (zerop (process-file "tmux" nil nil nil "has-session")))

  (defun tmux-new-pane-here ()
    "Open tmux pane of the current path."
    (interactive)
    (if (tmux-running-p)
        (call-process "tmux" nil nil nil "new-window")
      (message "Tmux is not running!")))

  (defun get-week-form (&optional offset date)
    "Create a specific form with the week number and the date. DATE
  is a list of the form (month day year). OFFSET is a integer
  number. DATE takes precedence over OFFSET when both are
  provided."
    (require 'cal-iso)
    (let* ((d (calendar-absolute-from-gregorian
               (or date (calendar-current-date offset))))
           (day (% d 7))
           (week-number (car (calendar-iso-from-absolute d)))
           (monday (calendar-gregorian-from-absolute (- d (- day 1))))
           (friday (calendar-gregorian-from-absolute (+ d (- 5 day))))
           (month-of-next-friday (if (equal (car monday) (car friday))
                                     ""
                                   (format "%2d월 " (car friday))))
           (start (format "%2d주차  %2d월 %2d일 ~ "
                          week-number
                          (car monday)
                          (nth 1 monday)))
           (end (format "%s%2d일"
                        month-of-next-friday
                        (nth 1 friday))))
      (format "%s%s" start end)))

  (defun sk-insert-current-week-form ()
    (interactive)
    (insert (get-week-form)))

  (defun sk-insert-next-week-form ()
    (interactive)
    (insert (get-week-form 7)))

  (defmacro sk-switch-buffer-repl (name mode repl run-repl &optional nobind)
    "Create NAME function which switch between a file of MODE and a
  REPL. Open REPL with RUN-REPL function if REPL is not yet
  opened. Evil-Leader z binding will be added to toggle MODE and
  REPL buffer unless NOBIND is not nil."
    (declare (indent defun))
    `(let ((last-mode "")
           (last-repl ""))
       (unless ,nobind
         (evil-leader/set-key-for-mode ',mode "z" ',name)
         (evil-leader/set-key-for-mode ',repl "z" ',name))
       (defun ,name ()
         (interactive)
         (cond ((equal major-mode ',mode)
                (setq last-mode (buffer-name))
                (if (get-buffer last-repl)
                    (pop-to-buffer last-repl)
                  (call-interactively ',run-repl)))
               ((equal major-mode ',repl)
                (setq last-repl (buffer-name))
                (when (get-buffer last-mode)
                  (pop-to-buffer last-mode)))
               (t nil)))))

  (let ((cnt 0))
    (defmacro sk-defer-init (&rest body)
      "Defer BODY until the very first command after init."
      (declare (indent defun))
      (let ((name (intern (format "sk-defer-init-%d" (setq cnt (1+ cnt))))))
        `(progn
           (defun ,name ()
             ,@body
             (remove-hook 'pre-command-hook ',name)
             (unintern ',name nil))
           (add-hook 'pre-command-hook #',name)))))
#+END_SRC
** Use-package
Install =use-package= if not exists. Set some default settings for
=use-package=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-always-defer t
        use-package-always-ensure t
        use-package-enable-imenu-support t)
  (put :map 'lisp-indent-function 'defun)
#+END_SRC

Load =use-package=. From this point, only =use-package= will be used for
settings.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'use-package)
#+END_SRC
* General settings
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; Evil-leader and evil
  (use-package evil-leader
    :init
    (defvar sk-evil-sub-leader "M-m")
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "<escape>" 'keyboard-quit
      "0"  'delete-window
      "1"  'delete-other-windows
      "2"  'split-window-below
      "3"  'split-window-right
      ","  'other-window
      "q"  'kill-buffer
      "Q"  'kill-emacs
      "u"  'pop-to-mark-command
      "w"  'save-buffer
      "cc" (kbd "\C-c\C-c")
      "st" 'tmux-new-pane-here
      "hk" 'describe-key
      "hm" 'describe-mode
      "xr" 'read-only-mode
      "xv" 'evil-reload-file)
    (defun sk-evil-leader-describe-bindings ()
      (interactive)
      (let ((current-buffer (current-buffer)))
        (with-help-window (help-buffer)
          (with-current-buffer (help-buffer)
            (describe-buffer-bindings current-buffer)
            (keep-lines "^SPC" (point-min) (point-max))
            (delete-matching-lines "Prefix Command" (point-min) (point-max))))))
    (defun evil-sub-leader-mode ()
      (let* ((sub-leader (kbd sk-evil-sub-leader))
             (mode-map (cdr (assoc major-mode evil-leader--mode-maps)))
             (map (or mode-map evil-leader--default-map)))
        (evil-normalize-keymaps)
        (define-key evil-motion-state-local-map sub-leader map)
        (define-key evil-insert-state-local-map sub-leader map)
        (define-key evil-emacs-state-local-map sub-leader map)))
    (add-hook 'evil-local-mode-hook 'evil-sub-leader-mode t)
    (defun evil-leader/set-key-minor-mode (mode key def &rest bindings)
      (declare (indent defun))
      (while key
        (let ((k1 (kbd (concat evil-leader/leader key)))
              (k2 (kbd (concat sk-evil-sub-leader " " key))))
          (evil-define-minor-mode-key 'motion mode k1 def)
          (evil-define-minor-mode-key 'motion mode k2 def)
          (evil-define-minor-mode-key 'insert mode k2 def)
          (evil-define-minor-mode-key 'emacs mode k2 def))
        (setq key (pop bindings)
              def (pop bindings))))
    (setq evil-leader/no-prefix-mode-rx
          '("magit-.*-mode" "gnus-.*-mode" "package-.*-mode" "dired-mode")))

  (use-package evil
    :bind (:map evil-insert-state-map
            ("C-a" . move-beginning-of-line)
            ("C-e" . move-end-of-line)
            ("C-k" . kill-line)
            :map evil-visual-state-map
            ("p"   . evil-paste-pgvy)
            :map evil-ex-completion-map
            ("C-a" . move-beginning-of-line)
            ("C-b" . backward-char)
            ("C-d" . delete-char)
            ("C-k" . kill-line)
            ("M-n" . next-complete-history-element)
            ("M-p" . previous-complete-history-element))
    :custom
    (evil-want-C-u-scroll t)
    :init
    (evil-mode)
    :config
    (setq evil-insert-state-modes (delete 'wdired-mode evil-insert-state-modes))
    (add-hook 'evil-insert-state-entry-hook
              (lambda () (when buffer-read-only (read-only-mode -1))))
    (defun evil-reload-file ()
      (interactive)
      (find-alternate-file (buffer-file-name)))
    (defun evil-paste-pgvy ()
      "Paste and restore visual block and yank."
      (interactive)
      (call-interactively 'evil-paste-after)
      (evil-visual-restore)
      (call-interactively 'evil-yank))
    (defun evil-swap-key (map key1 key2)
      "Swap KEY1 and KEY2 in MAP"
      (let  ((def1 (lookup-key map key1))
             (def2 (lookup-key map key2)))
        (define-key map key1 def2)
        (define-key map key2 def1)))
    (evil-swap-key evil-motion-state-map "j" "gj")
    (evil-swap-key evil-motion-state-map "k" "gk")
    (evil-global-set-key 'normal "Y" (kbd "y$"))
    (evil-global-set-key 'motion "$" 'end-of-line)
    (dolist (m '(image-mode term-mode diff-mode))
      (evil-set-initial-state m 'emacs)))


  ;;; Personal packages
  (use-package company-sql
    :ensure nil
    :load-path emacs-etc-dir
    :hook ((sql-mode sql-interactive-mode) . my-sql-mode-hook)
    :config
    (defun my-sql-mode-hook ()
      (add-to-list 'company-backends 'company-sql)))


  ;;; Built-in packages
  (use-package korea-util
    :ensure nil
    :bind ("C-\\" . toggle-korean-input-method)
    :init
    (setq default-korean-keyboard "3")
    (when window-system
      (set-fontset-font t 'unicode (font-spec :name "Unifont Upper"))
      (set-fontset-font t 'hangul (font-spec :name "D2Coding")))
    (setup-korean-environment-internal))

  (use-package recentf
    :ensure nil
    :hook (find-file . recentf-mode)
    :custom (recentf-max-saved-items 100)
    :config
    (add-to-list 'recentf-exclude
                 (expand-file-name "elpa/.*" emacs-config-dir)))

  (use-package ido
    :ensure nil
    :config
    (ivy-mode 1)
    (defalias 'ido-completing-read 'ivy-completing-read))

  (use-package calendar
    :ensure nil
    :bind (:map calendar-mode-map
            ("h"       . calendar-backward-day)
            ("j"       . calendar-forward-week)
            ("k"       . calendar-backward-week)
            ("l"       . calendar-forward-day)
            ("C-f"     . calendar-scroll-left-three-months)
            ("C-b"     . calendar-scroll-right-three-months)
            ("<left>"  . calendar-scroll-right)
            ("<right>" . calendar-scroll-left))
    :config
    (setq calendar-date-display-form
          '((format "%s-%.2d-%.2d%s" year
                    (string-to-number month)
                    (string-to-number day)
                    (if dayname (concat " " dayname) "")))
          diary-file "~/Dropbox/org/diary")
    (evil-set-initial-state 'calendar-mode 'emacs))

  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
            ("M-o"   . dired-omit-mode)
            ("j"     . dired-next-line)
            ("k"     . dired-previous-line)
            ("r"     . ora-dired-rsync)
            ("/"     . evil-search-forward)
            ("^"     . dired-up-and-close-dir)
            ("bp"    . my-dired-pdf-size-down)
            ("<DEL>" . dired-up-and-close-dir)
            ("<RET>" . dired-visit-file-or-dir))
    :init
    (add-to-list 'magic-mode-alist
                 '((lambda () (< large-file-warning-threshold (buffer-size)))
                   . fundamental-mode))
    :config
    (setq dired-listing-switches "-alh --group-directories-first"
          dired-omit-extensions '("~")
          dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..+$")

    (require 'dired-x)
    (add-hook 'dired-mode-hook (lambda () (dired-omit-mode)))

    (evil-set-initial-state 'dired-mode 'emacs)
    (evil-leader/set-key-for-mode 'dired-mode
      "cy" 'my-dired-copy-path            ; copy current folder path
      "cY" 'my-dired-copy-filepath        ; copy selected file path
      "ee" 'wdired-change-to-wdired-mode
      "ec" 'wdired-finish-edit
      "eq" 'wdired-exit)

    (defun my-dired-copy-path ()
      (interactive)
      (let ((path (expand-file-name default-directory)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun my-dired-copy-filepath ()
      (interactive)
      (let ((path (dired-filename-at-point)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun dired-visit-file-or-dir ()
      (interactive)
      (if (file-directory-p (dired-get-filename nil t))
          (dired-find-alternate-file)
        (dired-find-file-other-window)))

    (defun dired-up-and-close-dir (n)
      (interactive "p")
      (let* ((buf (get-buffer (buffer-name)))
             (curr (dired-current-directory))
             (dest (file-name-directory (directory-file-name curr))))
        (dotimes (_ (- n 1))
          (setq curr dest)
          (setq dest (file-name-directory (directory-file-name dest))))
        (dired dest)
        (dired-goto-file curr)
        (kill-buffer buf)))

    (defun ora-dired-rsync ()
      (interactive)
      (let* ((dest (read-file-name "Rsync to: " (dired-dwim-target-directory)))
             (files (dired-get-marked-files nil current-prefix-arg))
             (regex "\\(^/scp.?:\\)\\|\\(^/ssh.?:\\)")
             (prefix (cond ((string-match-p regex dest)
                            (replace-regexp-in-string regex "" dest))
                           ((string-match-p ".@.*:" dest) dest)
                           (t (expand-file-name dest))))
             (cmd (concat "rsync -ahrsvzP "
                          (mapconcat
                           (lambda (f)
                             (concat
                              "\"" (replace-regexp-in-string regex "" f) "\"" ))
                           files " ")
                          " \"" prefix "\""))
             (remote-p (string-match-p regex default-directory))
             (default-directory (if remote-p "~/" default-directory)))
        ;; Run rsync in home folder if remote-p.
        ;; Available for local to local, local to remote, remote to local.
        ;; Remote to remote is not available.
        (async-shell-command cmd "*rsync*")
        (other-window 1)
        (view-mode)))

    (defun my-dired-pdf-size-down ()
      (interactive)
      (let ((display-buffer-alist
             '(("\\*Async Shell Command\\*.*" display-buffer-no-window)))
            (file (dired-filename-at-point))
            (temp (make-temp-file ".temp" nil ".pdf")))
        (if (not (equal (file-name-extension file) "pdf"))
            (message "Not a PDF file.")
          (async-shell-command
           (concat
            "gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 "
            "-dPDFSETTINGS=/printer -dNOPAUSE -dQUIET -dBATCH -dPrinted=false "
            "-sOutputFile=" temp " " file " && "
            "mv " temp " " file))))))

  (use-package org
    :ensure nil
    :bind (:map org-mode-map
            ("C-c a"   . org-agenda)
            ("C-c b"   . org-switchb)
            ("C-c l"   . org-store-link)
            ("C-c r"   . org-remember)
            ("C-c t"   . org-table-create)
            ("C-c u"   . org-up-element)
            ("C-c e e" . org-edit-src-code))
    :init
    (evil-leader/set-key
      "ca" 'org-agenda)
    :config
    (setq
     my-org-path "~/Dropbox/org/"
     my-org-note (expand-file-name "notes.org" my-org-path)
     org-agenda-files (list my-org-path)
     org-babel-load-languages '((css . t)
                                (emacs-lisp . t)
                                (octave . t)
                                (plantuml . t)
                                (python . t)
                                (shell . t))
     org-confirm-babel-evaluate nil
     org-capture-templates
     `(("t" "Todo" entry (file+headline ,my-org-note "ToDos")
        "* TODO %?\n%U" :empty-lines 1)
       ("w" "Wait" entry (file+headline ,my-org-note "ToDos")
        "* WAIT %?\n%t" :empty-lines 1)
       ("n" "Note" entry (file+headline ,my-org-note "Notes")
        "* %?\n%U" :empty-lines 1)
       ("e" "Event" entry (file+headline ,my-org-note "Events")
        "* %?\n%U" :empty-lines 1))
     org-default-notes-file my-org-note
     org-export-default-language "kr"
     org-export-headline-levels 2
     org-export-time-stamp-file nil
     org-export-with-email t
     org-export-with-section-numbers nil
     org-export-with-sub-superscripts nil
     org-footnote-definition-re "^\\[fn:[-_[:word:]]+\\]"
     org-footnote-re (concat "\\[\\(?:fn:\\([-_[:word:]]+\\)?:"
                             "\\|"
                             "\\(fn:[-_[:word:]]+\\)\\)")
     org-html-inline-image-rules
     '(("file" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("http" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'"))
     org-html-metadata-timestamp-format "%Y-%m-%d"
     org-html-validation-link ""
     org-latex-packages-alist '(("" "parskip" nil) ("" "kotex" nil))
     org-log-done 'time
     org-plantuml-jar-path (getenv "PLANTUML_PATH")
     org-src-window-setup 'current-window
     org-startup-indented t
     org-startup-with-inline-images t
     org-todo-keywords
     '((sequence "TODO(t)" "PROG(p)" "WAIT(w)" "|" "DONE(d)" "KILL(k)")))
    (evil-leader/set-key-for-mode 'org-mode
      "cb"  'org-switchb
      "ce"  'org-export-dispatch
      "ci"  'org-insert-link
      "cl"  'org-store-link
      "ct"  'org-todo
      "cw"  'org-refile
      "ee"  'org-edit-src-code
      "ei"  'org-insert-structure-template
      "tc"  'org-table-create
      "tl"  'org-tags-view
      "ts"  'org-set-tags-command
      "cdd" 'org-deadline
      "cds" 'org-schedule
      "cd." 'org-time-stamp)
    (evil-leader/set-key-minor-mode 'org-src-mode
      "ec" 'org-edit-src-exit
      "eq" 'org-edit-src-abort)
    (evil-leader/set-key-minor-mode 'org-capture-mode
      "ck" 'org-capture-kill
      "cw" 'org-capture-refile)
    (evil-define-key 'insert org-mode-map
      (kbd "<tab>") 'company-indent-or-complete-common)
    (evil-define-key 'motion org-mode-map
      (kbd "TAB") 'org-cycle
      "gh" 'org-up-element
      "gl" 'org-down-element
      "gj" 'org-forward-element
      "gk" 'org-backward-element)
    (evil-declare-motion 'org-up-element)
    (evil-declare-motion 'org-down-element)
    (evil-declare-motion 'org-forward-element)
    (evil-declare-motion 'org-backward-element)

    (dolist (mode '("js" "javascript"))
      (add-to-list 'org-src-lang-modes `(,mode . js2)))
    (dolist (mode '("css" "html" "vue" "web"))
      (add-to-list 'org-src-lang-modes `(,mode . web)))

    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages)

    (defun my-org-inline-image-hook ()
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun my-org-inline-css-hook (exporter)
      (when (eq exporter 'html)
        (setq-local org-html-head-include-default-style nil)
        (setq-local org-html-head
                    (concat "<style type=\"text/css\">\n"
                            "<!--/*--><![CDATA[/*><!--*/\n"
                            (with-temp-buffer
                              (insert-file-contents
                               (expand-file-name "org.css" emacs-etc-dir))
                              (buffer-string))
                            "/*]]>*/-->\n"
                            "</style>\n")))
      (when (eq exporter 'reveal)
        (setq-local org-export-with-toc nil)))
    (add-hook 'org-babel-after-execute-hook 'my-org-inline-image-hook)
    (add-hook 'org-export-before-processing-hook 'my-org-inline-css-hook))

  (use-package ibuffer
    :ensure nil
    :bind ("C-x C-b" . ibuffer)
    :init
    (evil-leader/set-key
      "xb" 'ibuffer)
    :config
    (setq ibuffer-expert t
          ibuffer-sorting-mode 'alphabetic
          ibuffer-default-sorting-mode 'major-mode
          ibuffer-saved-filter-groups
          '(("home"
             ("Emacs-config" (or (filename . ".emacs")
                                 (filename . ".emacs.d")
                                 (filename . "emacs-config")))
             ("Org / MD" (or (mode . org-mode)
                             (mode . markdown-mode)
                             (filename . "OrgMode")))
             ("Magit" (mode . magit-status-mode))
             ("Code" (derived-mode . prog-mode))
             ("Shell" (or (mode . shell-mode)
                          (mode . eshell-mode)))
             ("Dired" (mode . dired-mode))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
    (defun my-ibuffer-unmark-all ()
      "Unmark all immdiately"
      (interactive)
      (ibuffer-unmark-all ?\s))
    (define-key ibuffer-mode-map (kbd "* *") 'my-ibuffer-unmark-all)
    (define-ibuffer-column size
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "home"))))

  (use-package shell
    :ensure nil
    :init
    (evil-leader/set-key
      "ss" 'shell)
    :config
    (evil-leader/set-key-for-mode 'shell-mode
      "l"  'my-comint-history))

  (use-package eshell
    :ensure nil
    :hook (eshell-mode . my-eshell-setup)
    :init
    (evil-leader/set-key
      "se" 'eshell)
    :config
    (defun eshell/clear ()
      "Clear Eshell buffer"
      (interactive)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (execute-kbd-macro (kbd "<RET>"))))
    (defun my-eshell-change-whole-line ()
      (interactive)
      (execute-kbd-macro (kbd "0C")))
    (defun my-eshell-history ()
      (interactive)
      (my-comint-history eshell-history-ring))
    (defun my-eshell-setup ()
      (setenv "TERM" "screen-256color")
      (evil-define-key 'insert eshell-mode-map (kbd "C-a") 'eshell-bol)
      (evil-define-key 'normal eshell-mode-map "S" 'my-eshell-change-whole-line)
      (evil-define-key 'motion eshell-mode-map
        "0"  'eshell-bol
        "gk" 'eshell-previous-prompt
        "gj" 'eshell-next-prompt
        (kbd "M-p") (lambda () (interactive) nil)
        (kbd "M-n") (lambda () (interactive) nil)
        (kbd "RET") 'my-comint-return))
    (evil-leader/set-key-for-mode 'eshell-mode
      "l"  'my-eshell-history))

  (use-package paren
    :ensure nil
    :init
    (sk-defer-init (show-paren-mode 1)))

  (use-package hl-line
    :ensure nil
    :init
    (sk-defer-init (global-hl-line-mode 1)))

  (use-package ansi-color
    :ensure nil
    :hook (compilation-filter . my-ansi-colorize-buffer)
    :custom
    (ansi-color-names-vector
     ["black" "red3" "green3" "yellow3" "dodger blue" "magenta3" "cyan3" "gray90"])
    :config
    (defun my-ansi-colorize-buffer ()
      (let ((buffer-read-only nil))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (use-package display-line-numbers
    :ensure nil
    :custom-face
    (line-number ((t :foreground "gray51" :inherit 'default)))
    (line-number-current-line ((t (:inherit 'default))))
    :hook
    ((find-file prog-mode) . display-line-numbers-mode)
    :config
    (setq-default display-line-numbers-width 3
                  display-line-numbers-type 'visual
                  display-line-numbers-current-absolute nil))

  (use-package tramp
    :ensure nil
    :config
    (setq tramp-auto-save-directory "/tmp/tramp/"
          tramp-chunksize 2000
          tramp-histfile-override (expand-file-name ".tramp_history"
                                                    user-emacs-directory))
    ;; TRAMP respect PATH variable on remote machine.
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path))

  (use-package autorevert
    :ensure nil
    :hook (find-file . global-auto-revert-mode))

  (use-package view
    :ensure nil
    :hook (view-mode . evil-motion-state))

  (use-package flymake
    :ensure nil
    :config
    (evil-set-initial-state 'flymake-diagnostics-buffer-mode 'emacs)
    (evil-define-key 'motion flymake-mode-map
      "]e" 'flymake-goto-next-error
      "[e" 'flymake-goto-prev-error))

  (use-package comint
    :ensure nil
    :commands my-comint-history
    :config
    (defun my-comint-history (&optional ring)
      (interactive)
      (let ((input-ring (if ring ring comint-input-ring)))
        (cl-letf (((symbol-function 'ivy-completion-in-region-action)
                   (lambda (cmd) (my-comint-return) (insert cmd))))
          (counsel--browse-history input-ring
                                   :caller #'counsel-shell-history))))
    (defun my-comint-return ()
      (interactive)
      (evil-goto-line)
      (evil-append-line 1))
    (evil-leader/set-key-for-mode 'comint-mode
      "l"  'my-comint-history)
    (evil-define-key 'normal comint-mode-map
      "gj" 'comint-next-prompt
      "gk" 'comint-previous-prompt
      (kbd "RET") 'my-comint-return))

  (use-package package
    :init
    (sk-defer-init (package-initialize)))

  ;;; External packages
  (use-package evil-anzu
    :demand t
    :after anzu)

  (use-package evil-visualstar
    :bind (:map evil-visual-state-map
            ("n" . evil-visualstar/begin-search-forward)
            ("N" . evil-visualstar/begin-search-backward))
    :config
    (global-evil-visualstar-mode))

  (use-package evil-surround
    :init
    (sk-defer-init (global-evil-surround-mode 1))
    :config
    (evil-define-key 'visual evil-surround-mode-map
      "gs" 'evil-surround-region))

  (use-package evil-commentary
    :init
    (sk-defer-init (evil-commentary-mode 1)))

  (use-package bind-key
    :init
    (bind-keys*
     ("<mouse-1>"        . nil)
     ("<mouse-3>"        . nil)
     ("<down-mouse-1>"   . nil)
     ("<down-mouse-3>"   . nil)
     ("<drag-mouse-1>"   . nil)
     ("<drag-mouse-3>"   . nil)
     ("<C-down-mouse-1>" . nil)
     ("<M-down-mouse-1>" . nil)
     ("<S-down-mouse-1>" . nil)
     ("C-c <escape>"     . keyboard-quit)
     ("C-x <escape>"     . keyboard-quit)
     ("M-,"              . my-other-window)
     ("<f5>"             . sk-make)
     ("C-<f5>"           . sk-rebuild)
     ("C-M-,"            . transpose-windows)
     ("M-S-<up>"         . (lambda () (interactive) (move-line -1)))
     ("M-S-<down>"       . (lambda () (interactive) (move-line  1)))
     ("<f7>"             . (lambda () (interactive) (buffer-save-or-load 7 t)))
     ("<f8>"             . (lambda () (interactive) (buffer-save-or-load 8 t)))
     ("C-<f7>"           . (lambda () (interactive) (buffer-save-or-load 7)))
     ("C-<f8>"           . (lambda () (interactive) (buffer-save-or-load 8)))
     :map minibuffer-local-map
     ("<escape>"         . minibuffer-keyboard-quit))
    (defun my-other-window ()
      (interactive)
      (if (minibufferp)
          (abort-recursive-edit)
        (call-interactively 'other-window))))

  (use-package company
    :custom-face
    (company-tooltip ((t :foreground "Black" :background "Yellow3")))
    :init
    (sk-defer-init (global-company-mode 1))
    :config
    (setq company-idle-delay 0.3)
    (evil-define-key 'insert company-mode-map
      (kbd "TAB") 'company-indent-or-complete-common))

  (use-package company-irony
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony))

  (use-package company-irony-c-headers
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony-c-headers))

  (use-package company-web
    :demand t
    :after web-mode)

  (use-package company-go
    :demand t
    :after go-mode
    :config
    (add-to-list 'company-backends 'company-go))

  (use-package company-ghc
    :demand t
    :after haskell-mode
    :config
    (add-to-list 'company-backends 'company-ghc))

  (use-package undo-tree
    :config
    (evil-set-initial-state 'undo-tree-visualizer-mode 'emacs)
    (evil-leader/set-key
      "xu" 'undo-tree-visualize))

  (use-package wgrep
    :commands wgrep-change-to-wgrep-mode
    :bind (:map helm-git-grep-mode-map
            ("C-c C-e" . wgrep-change-to-wgrep-mode)
            ("C-c C-s" . wgrep-save-all-buffers)))

  (use-package helm
    :bind (("M-y"     . helm-show-kill-ring)
           ("C-c i"   . helm-semantic-or-imenu)
           ("C-x C-r" . helm-recentf)
           ("C-c h o" . helm-occur)
           ("C-c h r" . helm-resume)
           :map minibuffer-local-map
           ("M-l"     . helm-minibuffer-history)
           :map helm-map
           ("<escape>". helm-keyboard-quit))
    :init
    (evil-leader/set-key
      "i"  'helm-semantic-or-imenu
      "y"  'helm-show-kill-ring
      "ho" 'helm-occur
      "hr" 'helm-resume)
    :config
    (setq helm-imenu-execute-action-at-once-if-one nil
          helm-split-window-default-side 'right
          helm-show-completion-display-function nil))

  (use-package helm-ag
    :commands (helm-ag-project-or-here helm-ag-here)
    :bind (("C-c j p" . helm-ag-project-or-here)
           ("C-c j P" . helm-ag-here))
    :init
    (evil-leader/set-key
      "jp" 'helm-ag-project-or-here
      "jP" 'helm-ag-here)
    :config
    (setq helm-ag-insert-at-point 'symbol
          helm-ag-base-command "ag --nocolor --nogroup --follow"
          helm-ag-use-grep-ignore-list t)
    (defun helm-ag-project-or-here ()
      (interactive)
      (helm-do-ag
       (my-project-root-or-dir)
       (car (projectile-parse-dirconfig-file))))
    (defun helm-ag-here ()
      (interactive)
      (helm-do-ag default-directory)))

  (use-package helm-git-grep
    :bind (("C-c p" . helm-git-grep-at-point))
    :init
    (evil-leader/set-key
      "p" 'helm-git-grep-at-point))

  (use-package projectile
    :commands (my-project-root-or-dir
               sk-add-known-project
               sk-remove-known-project)
    :bind (("C-c j d" . projectile-find-dir)
           ("C-c j k" . projectile-kill-buffers)
           ("C-c j b" . projectile-switch-to-buffer)
           ("C-c j s" . projectile-switch-project)
           ("C-c j S" . projectile-save-project-buffers))
    :init
    (evil-leader/set-key
      "jd" 'projectile-find-dir
      "jk" 'projectile-kill-buffers
      "jb" 'projectile-switch-to-buffer
      "js" 'projectile-switch-project
      "jS" 'projectile-save-project-buffers)
    :config
    (setq projectile-completion-system 'ivy
          projectile-require-project-root nil
          projectile-switch-project-action 'projectile-dired
          projectile-track-known-projects-automatically nil)
    (projectile-mode 1)
    (defun my-project-root-or-dir ()
      (or (projectile-project-root) default-directory))
    (defun sk-add-known-project (project-root)
      "Make .projectile file and add the project to known projects list."
      (interactive (list (read-directory-name "Add to known projects: ")))
      (let ((pfile (concat project-root ".projectile")))
        (unless (file-exists-p pfile)
          (write-region "" nil pfile)))
      (projectile-add-known-project project-root))
    (defalias 'sk-remove-known-project 'projectile-remove-known-project))

  (use-package markdown-mode)

  (use-package markdown-toc)

  (use-package ox-reveal
    :demand t
    :after org
    :custom (org-reveal-note-key-char nil)
    :config
    (setq org-reveal-center t
          org-reveal-hlevel 2
          org-reveal-plugins '(classList markdown highlight zoom notes)
          org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"
          org-reveal-theme "moon"
          org-reveal-title-slide "<h2>%t</h2><h4>%a&nbsp(%e)</h4>"
          org-reveal-transition "none"))

  (use-package neotree
    :commands my-neotree-directory
    :bind (("C-c n" . my-neotree-directory)
           :map neotree-mode-map
           ("u" . neotree-select-up-node)
           ("y" . (lambda ()
                    "Copy the absolute path of the node at point."
                    (interactive)
                    (message "Copied path : %s"
                             (neotree-copy-filepath-to-yank-ring)))))
    :init
    (evil-leader/set-key
      "n" 'my-neotree-directory)
    :config
    (evil-set-initial-state 'neotree-mode 'emacs)
    (defun my-neotree-directory ()
      (interactive)
      (if (neo-global--window-exists-p)
          (neotree-hide)
        (neotree-dir (my-project-root-or-dir)))))

  (use-package magit
    :bind ("<f12>" . magit-status)
    :hook (with-editor-mode . evil-normal-state)
    :init
    (evil-leader/set-key
      "gs" 'magit-status
      "gb" 'magit-blame)
    :config
    (setq magit-log-section-commit-count 5
          magit-completing-read-function #'ivy-completing-read)
    (evil-leader/set-key-minor-mode 'with-editor-mode
      "ck" 'with-editor-cancel)
    (bind-key "<escape>" 'transient-quit-one transient-map)
    (evil-make-overriding-map magit-blame-read-only-mode-map 'normal)
    (add-hook 'magit-blame-mode-hook 'evil-normalize-keymaps)
    (add-hook 'with-editor-mode-hook 'flyspell-mode)
    (defun magit-svn-rebase (&rest _)
      "Run $ git svn rebase"
      (interactive)
      (magit-run-git-async "svn" "rebase"))
    (defun magit-svn-dcommit (&rest _)
      "Run $ git svn dcommit"
      (interactive)
      (magit-run-git-async "svn" "dcommit"))
    (if (or (transient--layout-member "v" 'magit-pull)
            (transient--layout-member "v" 'magit-push))
        (error "Layout conflict occured!")
      (transient-append-suffix 'magit-push "m"
        '("v" "git svn dcommit" magit-svn-dcommit))
      (transient-append-suffix 'magit-pull "e"
        '("v" "git svn rebase" magit-svn-rebase))))

  (use-package expand-region
    :bind (("C-="   . er/expand-region)
           ("C-c =" . er/expand-region))
    :init
    (evil-leader/set-key
      "=" 'er/expand-region))

  (use-package smex)

  (use-package anzu
    :init
    (sk-defer-init (global-anzu-mode 1))
    :config
    (setq anzu-search-threshold 1000
          anzu-replace-threshold 1000))

  (use-package htmlize
    :demand t
    :after org)

  (use-package korean-holidays
    :init
    (setq calendar-holidays korean-holidays))

  (use-package visual-regexp
    :bind (("C-c r r" . vr/replace)
           ("C-c r q" . vr/query-replace)))

  (use-package visual-regexp-steroids
    :demand t
    :after visual-regexp)

  (use-package fzf
    :bind (("C-c j o" . fzf)
           ("C-c j h" . fzf-here)
           ("C-c o"   . fzf-git-files))
    :init
    (evil-leader/set-key
      "o"  'fzf-git-files
      "jh" 'fzf-here
      "jo" 'fzf)
    :config
    (setq fzf/window-height 20)
    (require 'term)
    (defun term-send-esc ()
      "Send ESC in term mode."
      (interactive)
      (term-send-raw-string "\e"))
    ;; to quit fzf with ESC key
    (define-key term-raw-map (kbd "<escape>") 'term-send-esc)
    (defun fzf-here ()
      (interactive)
      (fzf/start default-directory)))

  (use-package yasnippet
    :commands yas-expand
    :init
    (evil-define-key 'insert prog-mode-map (kbd "M-j") 'yas-expand)
    :config
    (advice-add 'yas-expand :before (lambda () (yas-minor-mode 1)))
    (add-to-list 'yas-snippet-dirs (expand-file-name "snippets/" emacs-etc-dir))
    (yas-reload-all))

  (use-package yasnippet-snippets
    :demand t
    :after yasnippet)

  (use-package ivy
    :bind (("C-x b"    . ivy-switch-buffer)
           :map minibuffer-inactive-mode-map
           ("<escape>" . abort-recursive-edit)
           :map ivy-minibuffer-map
           ("<escape>" . minibuffer-keyboard-quit)
           ("C-j"      . ivy-partial)
           ("TAB"      . ivy-alt-done))
    :init
    (evil-leader/set-key
      "b" 'ivy-switch-buffer)
    :config
    (setq ivy-height 15
          ivy-height-alist '((t . 15))
          ivy-wrap t
          ivy-fixed-height-minibuffer t
          ;; Don't use ^ as initial input
          ivy-initial-inputs-alist nil
          ;; disable magic slash on non-match
          ivy-magic-slash-non-match-action nil
          ;; prefix match first
          ivy-sort-matches-functions-alist
          '((t . ivy--prefix-sort)
            (ivy-switch-buffer . ivy-sort-function-buffer)))
    (require 'subr-x)
    (ivy-mode 1)
    (when window-system
      (ivy-posframe-mode 1))
    (defun sk-ivy-buffer-transformer (str)
      (let* ((buf (get-buffer str))
             (buf-dir (buffer-local-value 'default-directory buf))
             (buf-mode (buffer-local-value 'major-mode buf))
             (mode (capitalize
                    (string-remove-suffix "-mode" (symbol-name buf-mode))))
             (max-path-len (max 0
                                (- (frame-width) 65 (max 0 (- (length str) 35)))))
             (path-dir (abbreviate-file-name (or buf-dir "~/")))
             (path-file (when-let ((name (buffer-file-name buf)))
                          (abbreviate-file-name name)))
             (path-opt (or path-file
                           (when (or (string-match-p "shell" str)
                                     (equal buf-mode 'dired-mode))
                             path-dir)))
             (path-prefix (if (string-prefix-p "~" path-opt)
                              "~/"
                            "/"))
             (path-len (length path-opt))
             (path-mod (if (<= path-len max-path-len)
                           nil
                         (substring path-opt (- path-len max-path-len) path-len)))
             (path (if path-mod
                       (concat path-prefix
                               "…"
                               (replace-regexp-in-string "^[^~/]*" "" path-mod))
                     path-opt)))
        (format "%-35s %-20s %s" buf mode (or path ""))))
    (ivy-set-display-transformer 'ivy-switch-buffer 'sk-ivy-buffer-transformer)
    (ivy-set-actions
     'projectile-switch-project
     '(("d" (lambda (p) (projectile-remove-known-project p)) "delete"))))

  (use-package ivy-yasnippet
    :init
    (evil-leader/set-key "/" 'ivy-yasnippet)
    :config
    (advice-add 'ivy-yasnippet :before (lambda () (yas-minor-mode 1)))
    (advice-add 'ivy-yasnippet :after (lambda () (evil-insert-state))))

  (use-package ivy-posframe
    :custom-face
    (ivy-posframe
     ((((class color) (min-colors 88) (background light))
       :background "ivory3" :foreground "black")
      (((class color) (min-colors 88) (background dark))
       :background "#282a36" :foreground "gray80")))
    (ivy-posframe-border ((t (:inherit ivy-posframe))))
    :config
    (setq ivy-posframe-border-width 20
          ivy-posframe-display-functions-alist
          '((complete-symbol . nil)
            (ivy-yasnippet   . nil)
            (swiper          . nil)
            (t               . ivy-posframe-display-at-frame-center))))

  (use-package posframe)

  (use-package counsel
    :commands (counsel-fzf-here my-counsel-switch-to-shell-buffer)
    :bind (("M-x"     . counsel-M-x)
           ("C-x d"   . counsel-find-file)
           ("C-x C-f" . counsel-find-file)
           ("C-h b"   . counsel-descbinds)
           ("C-h v"   . counsel-describe-variable)
           ("C-h f"   . counsel-describe-function))
    :init
    (evil-leader/set-key
      "<SPC>" 'counsel-M-x
      "M-m"   'counsel-M-x
      "d"     'counsel-find-file
      "f"     'counsel-find-file
      "r"     'counsel-recentf
      "cr"    'counsel-org-capture
      "hb"    'counsel-descbinds
      "hv"    'counsel-describe-variable
      "hf"    'counsel-describe-function
      "jc"    'counsel-fzf-here
      "sb"    'my-counsel-switch-to-shell-buffer)
    :config
    (setq ivy-initial-inputs-alist nil
          ivy-height-alist '((t . 15)))
    (defun counsel-fzf-here ()
      (interactive)
      (counsel-fzf nil default-directory))
    (defun my-counsel-switch-to-shell-buffer ()
      "Switch to a shell buffer, or create one."
      (interactive)
      (ivy-read "Shell buffer: "
                (append (counsel--buffers-with-mode #'shell-mode)
                        (counsel--buffers-with-mode #'eshell-mode))
                :action #'counsel--switch-to-shell
                :caller 'ivy-switch-buffer))
    (ivy-set-actions
     'counsel-shell-history
     '(("d" (lambda (x) (ring-remove comint-input-ring
                                     (ring-member comint-input-ring (car x))))
        "delete"))))

  (use-package which-key
    :init
    (sk-defer-init (which-key-mode 1)))
#+END_SRC
* Development settings
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; Built-in packages
  (use-package prog-mode
    :ensure nil
    :config
    (evil-define-key 'normal prog-mode-map
      "gd" 'xref-find-definitions
      "gp" 'xref-pop-marker-stack
      "gr" 'xref-find-reference-here
      "g[" 'xref-pop-marker-stack)
    (add-hook 'before-save-hook (lambda () (when (derived-mode-p 'prog-mode)
                                             (delete-trailing-whitespace)))))

  (use-package elec-pair
    :ensure nil
    :hook (prog-mode . electric-pair-mode)
    :config
    (defun electric-pair-delete-pair (arg &optional killp)
      "Custom pair-delete. Delete a closing braket in case of (|),
  delete a pair of inner braket in case of ((|))."
      (interactive "*p\nP")
      (if (memq (char-after (1+ (point))) '(?\) ?\" ?\] ?\} ?\$))
          (delete-char 1)
        (forward-char))
      (backward-delete-char-untabify arg killp)))

  (use-package octave
    :ensure nil
    :mode ("\\.m\\'" . octave-mode)
    :config
    (sk-switch-buffer-repl sk-octave-buffer-repl-toggle
      octave-mode inferior-octave-mode run-octave)
    (evil-leader/set-key-for-mode 'octave-mode
      "eb" 'octave-send-buffer
      "ee" 'octave-send-line
      "ef" 'octave-send-defun
      "er" 'octave-send-region))

  (use-package python
    :ensure nil
    :hook (python-mode . eglot-ensure)
    :commands sk-toggle-python
    :bind (:map python-mode-map
            ("M-<left>"  . python-indent-shift-left)
            ("M-<right>" . python-indent-shift-right))
    :config
    (setq imenu-create-index-function 'python-imenu-create-index
          python-indent-guess-indent-offset-verbose nil)
    (defun sk-toggle-python ()
      "Toggle between Python2 and Python3"
      (interactive)
      (let ((python (if (equal python-shell-interpreter "python2")
                        "python"
                      "python2")))
        (setq python-shell-interpreter python)
        (message (concat "Toggled to " python))))
    (sk-switch-buffer-repl sk-python-buffer-repl-toggle
      python-mode inferior-python-mode
      (lambda ()
        (interactive)
        (pop-to-buffer (process-buffer (call-interactively 'run-python)))))
    (evil-leader/set-key-for-mode 'inferior-python-mode
      "l"  'my-comint-history)
    (evil-leader/set-key-for-mode 'python-mode
      "eb" 'python-shell-send-buffer
      "ee" 'python-shell-send-defun
      "ef" 'python-shell-send-defun
      "er" 'python-shell-send-region))

  (use-package xref
    :ensure nil
    :commands xref-find-reference-here
    :bind (:map xref--xref-buffer-mode-map
            ("<return>" . xref-quit-and-goto-xref)
            ("<RET>"    . xref-quit-and-goto-xref))
    :config
    (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
    (defun xref-find-reference-here ()
      (interactive)
      (xref-find-references (thing-at-point 'symbol))))

  (use-package gdb-mi
    :ensure nil
    :init
    (advice-add 'gdb-setup-windows :after
                (lambda (&rest _)
                  (set-window-dedicated-p (selected-window) t)))
    :config
    (gdb-many-windows t)
    (dolist (mm '(gdb-edit-locals-map-1
                  gdb-locals-mode-map
                  gdb-locals-watch-map
                  gdb-registers-mode-map
                  gdb-frames-mode-map
                  gdb-breakpoints-mode-map
                  gdb-threads-mode-map))
      (bind-keys :map (symbol-value mm)
                 ("j" . next-line)
                 ("k" . previous-line)))
    (evil-leader/set-key-for-mode 'gud-mode
      "l"  'my-comint-history)
    (evil-leader/set-key-minor-mode 'gdb-many-windows
      "ab" 'gud-break
      "ad" 'gud-remove
      "af" 'gud-finish
      "ai" 'gud-stempi
      "aj" 'gud-jump
      "al" 'gud-refresh
      "an" 'gud-next
      "ap" 'gud-print
      "ar" 'gud-cont
      "as" 'gud-step
      "at" 'gud-tbreak
      "au" 'gud-until
      "aw" 'gud-watch))

  (use-package make-mode
    :ensure nil
    :mode ("Makefile.*" . makefile-gmake-mode))

  (use-package which-func
    :ensure nil
    :hook ((c-mode-common python-mode js-mode) . my-which-function-setup)
    :custom-face (which-func ((t :inherit font-lock-function-name-face)))
    :config
    (setq which-func-unknown "N/A")
    (defun my-which-function-setup ()
      (which-function-mode)
      (setq-local header-line-format 'which-func-format)))

  (use-package sh-script
    :ensure nil
    :hook (sh-mode . (lambda () (sh-electric-here-document-mode -1))))

  (use-package scheme
    :ensure nil
    :config
    (require 'geiser)
    (sk-switch-buffer-repl sk-scheme-buffer-repl-toggle
      scheme-mode geiser-repl-mode run-geiser)
    (evil-leader/set-key-for-mode 'scheme-mode
      "eb" 'geiser-eval-buffer
      "ee" 'geiser-eval-last-sexp
      "ef" 'geiser-eval-definition
      "er" 'geiser-eval-region))

  (use-package elisp-mode
    :ensure nil
    :config
    (defun my-describe-symbol-at-point ()
      (interactive)
      (describe-symbol (symbol-at-point)))
    (dolist (mm '(emacs-lisp-mode lisp-interaction-mode))
      (evil-leader/set-key-for-mode mm
        "eb" 'eval-buffer
        "ee" 'eval-last-sexp
        "ef" 'eval-defun
        "er" 'eval-region))
    (evil-define-key 'normal emacs-lisp-mode-map
      "gh" 'my-describe-symbol-at-point)
    (evil-define-key 'normal lisp-interaction-mode-map
      "gh" 'my-describe-symbol-at-point))

  (use-package sql
    :ensure nil
    :config
    (evil-leader/set-key-for-mode 'sql-interactive-mode
      "l" 'my-comint-history))

  (use-package cc-cmds
    :ensure nil
    :bind (("C-<backspace>" . c-hungry-backspace)
           ("C-c <DEL>"     . c-hungry-backspace))
    :init
    (evil-leader/set-key (kbd "<DEL>") 'c-hungry-backspace)
    :config
    (setq c-basic-offset 4
          c-default-style "bsd"))

  ;;; External packages
  (use-package cff
    :init
    (add-hook 'c-mode-common-hook
              (lambda () (local-set-key (kbd "M-o") 'cff-find-other-file))))

  (use-package ggtags
    :hook ((c-mode-common asm-mode) . ggtags-mode)
    :config
    (evil-define-key 'normal ggtags-mode-map
      "gd" 'ggtags-find-tag-dwim
      "gr" 'ggtags-find-reference)
    (evil-define-key 'motion ggtags-navigation-mode-map
      (kbd "RET") 'ggtags-navigation-mode-done))

  (use-package irony
    :hook ((c++-mode c-mode objc-mode) . irony-mode)
    :config
    (defun my-irony-mode-hook ()
      (define-key irony-mode-map [remap completion-at-point]
        'irony-completion-at-point-async)
      (define-key irony-mode-map [remap complete-symbol]
        'irony-completion-at-point-async)
      (irony-cdb-autosetup-compile-options))
    (add-hook 'irony-mode-hook 'my-irony-mode-hook))

  (use-package paredit
    :hook ((clojure-mode emacs-lisp-mode lisp-mode scheme-mode geiser-repl-mode
                         sly-mrepl-mode)
           . enable-paredit-mode)
    :bind (:map paredit-mode-map
            ("M-b" . paredit-backward)
            ("M-f" . paredit-forward)
            ("C-c <left>"  . paredit-forward-barf-sexp)
            ("C-c <right>" . paredit-forward-slurp-sexp))
    :config
    (defun evil-paredit-kill (&rest _)
      (interactive)
      (let ((evil-execute-in-emacs-state-buffer t)
            (pos (point)))
        (when (equal pos (1- (line-end-position)))
          (goto-char (1+ pos)))
        (call-interactively 'paredit-kill)))
    (defun my-evil-paredit-next-bracket (n direction)
      "Move to the next Nth bracket or quote with DIRECTION."
      (let* ((evil-execute-in-emacs-state-buffer t)
             (pos (point))
             (forward (> direction 0))
             (arg (if forward n (- n))))
        (and forward
             (member (line-end-position) (list pos (1+ pos)))
             (goto-char (line-beginning-position 2)))
        (when (paredit-in-string-p)
          (goto-char (nth 8 (paredit-current-parse-state)))
          (and forward (forward-sexp 1))
          (setq arg (- arg (if forward 1 -1))))
        (unless (re-search-forward "(\\|)\\|\\[\\|\\]" nil t arg)
          (goto-char pos))))
    (defun sk-evil-paredit-forward-braket (&optional n)
      (interactive "p")
      (my-evil-paredit-next-bracket n 1))
    (defun sk-evil-paredit-backward-braket (&optional n)
      (interactive "p")
      (my-evil-paredit-next-bracket n -1))
    (evil-leader/set-key-minor-mode 'paredit-mode
      "k"  'evil-paredit-kill)
    (evil-define-key 'insert paredit-mode-map
      (kbd "C-k") 'paredit-kill)
    (evil-define-key 'motion paredit-mode-map
      "]b" 'sk-evil-paredit-forward-braket
      "[b" 'sk-evil-paredit-backward-braket))

  (use-package clojure-mode
    :config
    (evil-define-key 'normal clojure-mode-map
      "gd"  'cider-find-dwim
      "gp"  'cider-pop-back
      "ghc" 'cider-clojuredocs
      "ghe" 'cider-apropos-documentation-select
      "ghh" 'my-cider-doc
      "ghj" 'cider-javadoc
      "ghw" 'cider-clojuredocs-web)
    (evil-leader/set-key-for-mode 'clojure-mode
      "z"   'cider-switch-to-repl-buffer
      "eb"  'cider-eval-buffer
      "ee"  'cider-eval-last-sexp
      "ef"  'cider-eval-defun-at-point
      "er"  'cider-eval-region
      "epc" 'cider-pprint-eval-last-sexp-to-comment
      "epf" 'cider-pprint-eval-defun-at-point
      "epp" 'cider-pprint-eval-last-sexp
      "esb" 'cider-browse-ns
      "esf" 'cider-find-ns
      "ess" 'cider-repl-set-ns
      "eta" 'cider-test-rerun-test
      "etn" 'cider-test-run-ns-tests
      "etp" 'cider-test-run-project-tests
      "etr" 'cider-test-rerun-failed-tests
      "ett" 'cider-test-run-test
      "evv" 'cider-eval-sexp-at-point
      "evx" 'cider-eval-last-sexp-and-replace)
    (defun my-cider-doc ()
      (interactive)
      (cider-ensure-connected)
      (cider-doc-lookup (thing-at-point 'symbol))))

  (use-package cider
    :config
    (evil-set-initial-state 'cider-auto-test-mode           'emacs)
    (evil-set-initial-state 'cider-browse-ns-mode           'emacs)
    (evil-set-initial-state 'cider-browse-spec-example-mode 'emacs)
    (evil-set-initial-state 'cider-browse-spec-mode         'emacs)
    (evil-set-initial-state 'cider-browse-spec-view-mode    'emacs)
    (evil-set-initial-state 'cider-docview-mode             'emacs)
    (evil-set-initial-state 'cider-enlighten-mode           'emacs)
    (evil-set-initial-state 'cider-inspector-mode           'emacs)
    (evil-set-initial-state 'cider-repl-history-mode        'emacs)
    (evil-set-initial-state 'cider-stacktrace-mode          'emacs)
    (evil-set-initial-state 'cider-test-report-mode         'emacs)
    (evil-define-key 'normal cider-repl-mode-map
      "gd"        'cider-find-dwim
      "gp"        'cider-pop-back
      (kbd "RET") 'my-comint-return)
    (evil-define-minor-mode-key 'normal 'cider-popup-buffer-mode
      "q"  'quit-window)
    (evil-leader/set-key-for-mode 'clojurescript-mode
      "z"  'cider-switch-to-repl-buffer)
    (evil-leader/set-key-for-mode 'cider-repl-mode
      "z"  'cider-switch-to-last-clojure-buffer))

  (use-package clj-refactor
    :disabled t
    :mode ("\\.clj\\'" . clojure-mode))

  (use-package sly
    :init
    (setq inferior-lisp-program "sbcl")
    :config
    (setq sly-mrepl-history-file-name
          (expand-file-name ".sly-mrepl-history" user-emacs-directory))
    (evil-set-initial-state 'sly-db-mode                'emacs)
    (evil-set-initial-state 'sly-inspector-mode         'emacs)
    (evil-set-initial-state 'sly-stickers--replay-mode  'emacs)
    (evil-set-initial-state 'sly-xref-mode              'emacs)
    (evil-set-initial-state 'sly-xref-mode              'emacs)
    (defun my-sly-mrepl ()
      (interactive)
      (call-interactively (if (sly-connected-p) 'sly-mrepl 'sly)))
    (evil-leader/set-key-minor-mode 'sly-mode
      "z"   'my-sly-mrepl
      "cb"  'sly-compile-file
      "cf"  'sly-compile-defun
      "cr"  'sly-compile-region
      "eb"  'sly-eval-buffer
      "ee"  'sly-eval-last-expression
      "ef"  'sly-eval-defun
      "er"  'sly-eval-region
      "es"  'sly-mrepl-sync
      "csd" 'sly-stickers-clear-defun-stickers
      "csk" 'sly-stickers-clear-buffer-stickers
      "csr" 'sly-stickers-replay
      "css" 'sly-stickers-dwim
      "csF" 'sly-stickers-forget)
    (evil-leader/set-key-for-mode 'sly-mrepl-mode
      "l"  'my-comint-history
      "z"  'sly-switch-to-most-recent
      "es" 'sly-mrepl-set-package)
    (evil-define-key 'normal sly-mode-map
      "gd" 'sly-edit-definition
      "gh" 'sly-documentation
      "gp" 'sly-pop-find-definition-stack
      "gr" 'sly-edit-uses)
    (evil-define-key 'normal sly-mrepl-mode-map
      "gj" 'sly-mrepl-next-prompt
      "gk" 'sly-mrepl-previous-prompt
      "gd" 'sly-edit-definition
      "gp" 'sly-pop-find-definition-stack
      "gr" 'sly-edit-uses
      (kbd "RET") 'my-comint-return)
    (evil-define-minor-mode-key 'normal 'sly-popup-buffer-mode
      "q"  'quit-window))

  (use-package geiser
    :config
    (setq geiser-chicken-binary "chicken-csi"
          geiser-repl-history-filename
          (expand-file-name ".geiser_history" user-emacs-directory))
    (advice-add 'run-geiser :before
                (lambda (impl) (geiser-impl--set-buffer-implementation impl))))

  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.ejs\\'" . web-mode)
           ("\\.vue\\'" . web-mode))
    :config
    (setq web-mode-style-padding 0
          web-mode-script-padding 0
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-enable-current-element-highlight t)
    (require 'cl)
    (defun tree-assoc (key tree)
      (when (consp tree)
        (destructuring-bind (x . y)  tree
          (if (eql x key) tree
            (or (tree-assoc key x) (tree-assoc key y))))))
    (defmacro code-to-key (code)
      `(key-description (vector ,code)))
    (defun cc-map-to-evil-leader-map (mode ori1 ori2 con1 con2)
      "Find bindings start with ori1 ori2 from mode-map and
  convert it to corresponding evil-leader map. For example, all
  bindings of C-c C-e X is converted to leader c e X by below:
  '(cc-map-to-evil-leader-map ?\C-c ?\C-e c e)'"
      (let* ((map (symbol-value (intern (concat (symbol-name mode) "-map"))))
             (cc-maps (thread-last map (tree-assoc ori1) (tree-assoc ori2) cddr)))
        (dolist (pair cc-maps)
          (let ((key (car pair))
                (func (cdr pair)))
            (evil-leader/set-key-for-mode mode
              (concat con1 con2 (code-to-key key)) func)))))
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-a "c" "a")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-b "c" "b")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-d "c" "d")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-e "c" "e")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-t "c" "t")
    (evil-leader/set-key-for-mode 'web-mode
      "cf" 'web-mode-fold-or-unfold
      "cl" 'web-mode-file-link
      "cn" 'web-mode-navigate
      "cw" 'web-mode-whitespaces-show))

  (use-package js2-mode
    :mode (("\\.js\\'" . js2-mode)
           ("\\.jsx\\'" . js2-jsx-mode))
    :hook (js2-mode . eglot-ensure)
    :config
    (setq js2-basic-offset 2
          js2-strict-missing-semi-warning nil)
    (add-hook 'js2-mode-hook (lambda () (js2-imenu-extras-mode))))

  (use-package js2-refactor
    :disabled t
    :config
    (js2r-add-keybindings-with-prefix "C-c C-n"))

  (use-package rjsx-mode
    :init
    (add-to-list 'auto-mode-alist '("components\\/.*\\.js\\'" . rjsx-mode))
    (add-hook 'find-file-hook
              (lambda ()
                (when
                    (and (string-match "\\.js\\'" buffer-file-name)
                         (find-file-in-tree default-directory "next.config.js"))
                  (rjsx-mode)))))

  (use-package emmet-mode
    :hook ((web-mode js2-mode css-mode) . emmet-mode))

  (use-package go-mode
    :hook (go-mode . eglot-ensure)
    :config
    (setq gofmt-command "goimports")
    (defun my-go-code-hook ()
      (make-local-variable 'before-save-hook)
      (add-hook 'before-save-hook 'gofmt-before-save)
      (setq-local compile-command
                  "go build -v && go test -v && go vet"))
    (add-hook 'go-mode-hook 'my-go-code-hook))

  (use-package format-all)

  (use-package plantuml-mode
    :mode ("\\.puml\\'" . plantuml-mode)
    :bind (:map plantuml-mode-map
            ("C-c C-e" . plantuml-make-output))
    :config
    (setq plantuml-default-exec-mode 'jar
          plantuml-jar-path (getenv "PLANTUML_PATH"))
    (evil-leader/set-key-for-mode 'plantuml-mode
      "ce" 'plantuml-make-output)
    (defun plantuml-make-output ()
      (interactive)
      (set-process-sentinel
       (start-process "plantuml" nil "plantuml" (buffer-file-name))
       (lambda (&rest _) (message "PlantUML process is done")))))

  (use-package haskell-mode
    :hook (haskell-mode . my-haskell-mode-hook)
    :config
    (defun my-haskell-mode-hook ()
      (setq-local tab-width 4))
    (sk-switch-buffer-repl sk-haskell-buffer-repl-toggle
      haskell-mode inferior-haskell-mode run-haskell))

  (use-package restclient
    :mode ("\\.rest\\'" . restclient-mode)
    :hook (restclient-mode . my-restclient-mode-hook)
    :config
    (defvar restclient-imenu-generic-expression
      '(("GET" "^\\(GET\\)\\(.*\\)" 2)
        ("PUT" "^\\(PUT\\)\\(.*\\)" 2)
        ("POST" "^\\(POST\\)\\(.*\\)" 2)
        ("DELETE" "^\\(DELETE\\)\\(.*\\)" 2)
        ("Variables" "^:\\(.*\\)" 1)))
    (defun my-restclient-mode-hook ()
      (setq imenu-generic-expression restclient-imenu-generic-expression
            imenu-case-fold-search nil))
    (evil-leader/set-key-for-mode 'restclient-mode
      "ec" 'restclient-http-send-current-raw
      "ee" 'restclient-http-send-current-stay-in-window)
    (evil-define-key 'motion restclient-mode-map
      "gj" 'restclient-jump-next
      "gk" 'restclient-jump-prev)
    (evil-define-minor-mode-key 'normal 'restclient-response-mode
      "q"  'quit-window))

  (use-package eglot
    :config
    (require 'projectile)
    (defun eglot--update-doc (string &rest _)
      "Display only the first line of STRING as an ElDoc message."
      (when string
        (eldoc-message (car (split-string string "\n")))))
    (defun my-projectile-project-find (dir)
      (let ((root (projectile-project-root dir)))
        (and root (cons 'transient root))))
    (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
    (add-to-list 'project-find-functions 'my-projectile-project-find)
    (advice-add 'projectile-kill-buffers :before
                (lambda ()
                  (when (eglot-current-server)
                    (call-interactively
                     'eglot-shutdown '((eglot-current-server) t)))))
    (evil-define-minor-mode-key 'normal 'eglot--managed-mode
      "gh" 'eglot-help-at-point))

  (use-package rust-mode
    :hook (rust-mode . eglot-ensure))

  (use-package lua-mode)
#+END_SRC
* End
** Provide a feature
Make =config.el= available to load by =require=.

#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'config)
#+END_SRC
