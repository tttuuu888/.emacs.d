#+TITLE: SK Emacs configuration
#+AUTHOR: Seungki Kim
#+EMAIL: tttuuu888@gmail.com
#+PROPERTY: header-args :tangle yes

* About
This is my personal Emacs setting.

=init.el= will generate =config.el= from =config.org= and then will load
=config.el=.

=file-name-handler-alist= will be set to =nil= and =gc-cons-threshold= will be
set to =most-positive-fixnum= in order to boost up the speed during the boot
time.

All the other settings will be located in =config.org=.
* Initial settings
** Commentary
This comment will be added on the top of =config.el=.

#+BEGIN_SRC emacs-lisp
  ;;; config.el --- generated from config.org -*- lexical-binding: t -*-
  ;;
  ;;; Code:
#+END_SRC

** Package initialize
Process =package-initialize= before setting =package-archives= to speed up Emacs
start up time. So =package-read-all-archive-contents= should be called after
start up to use of updated =package-archives=.

#+BEGIN_SRC emacs-lisp
  (unless package--activated
    (package-initialize))

  (setq package-archives
        '(("gnu"   . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

** User-emacs-directory setting
From this point, =user-emacs-directory= is set to =~/.emacs.d/.local/= so that
all package local files would be hidden under the path.

=emacs-config-dir= would be used instead of =user-emacs-directory=.

#+BEGIN_SRC emacs-lisp
  (defvar emacs-config-dir user-emacs-directory)
  (setq user-emacs-directory (expand-file-name ".local/" emacs-config-dir))
  (unless (file-exists-p user-emacs-directory)
    (make-directory-internal user-emacs-directory))
#+END_SRC

Set =emacs-etc-dir= to indicate a folder containing extra files.

#+BEGIN_SRC emacs-lisp
  (defvar emacs-etc-dir (expand-file-name "etc/" emacs-config-dir))
  (unless (file-exists-p emacs-etc-dir)
    (make-directory-internal emacs-etc-dir))
#+END_SRC

** User information
If =USER_FULL_NAME= and =USER_MAIL_ADDRESS= environment variables exist, update
=user_full_name= and =user_mail_address= variables.

#+BEGIN_SRC emacs-lisp
  (let ((name (getenv "USER_FULL_NAME"))
        (mail (getenv "USER_MAIL_ADDRESS")))
    (when name (setq user-full-name name))
    (when mail (setq user-mail-address mail)))
#+END_SRC

** Custom file
=custom.el= will be saved under =~/.emacs.d/.local/= but will not be used.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Instead of using =custom.el=, insert the contents of the file directly here.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(adaptive-fill-regexp
     (rx (0+ (any "	 "))
         (0+ (group (1+ (any "!#%*;>|·–•‣⁃◦-"))
                    (0+ (any "	 "))))
         (0+ (and (1+ (any num)) (or "." ")") space))))
   '(auth-source-save-behavior nil)
   '(backup-directory-alist '((".*" . "/tmp/")))
   '(blink-cursor-mode nil)
   '(browse-url-browser-function 'browse-url-chrome)
   '(completion-styles '(basic partial-completion emacs22 initials))
   '(css-indent-offset 2)
   '(fill-column 80)
   '(font-use-system-font t)
   '(indent-tabs-mode nil)
   '(inhibit-startup-screen t)
   '(line-number-display-limit-width 1000)
   '(major-mode 'text-mode)
   '(make-backup-files nil)
   '(mouse-wheel-progressive-speed nil)
   '(paragraph-start
     (rx (or "\f"
             (and (* space) eol)
             (and (* space) (any "-+*") space)
             (and (* space) (1+ (any num)) (or "." ")") space))))
   '(password-cache-expiry 900)
   '(ring-bell-function 'ignore)
   '(safe-local-variable-values '((c-default-style . "linux")
                                  (indent-tabs-mode . t)
                                  (tab-width . 2)))
   '(send-mail-function 'smtpmail-send-it)
   '(size-indication-mode t)
   '(split-height-threshold nil)
   '(split-width-threshold 140)
   '(tab-always-indent 'complete)
   '(tab-width 4)
   '(use-file-dialog nil)
   '(use-short-answers t))
#+END_SRC

** Custom variables
#+begin_src emacs-lisp
  (defvar sk-font "D2Coding")

  (defvar sk-vc-mode nil)

  (defvar sk-project-root-files
    '(".projectile" ".git"
      "CMakeLists.txt" "Makefile" "GTAGS"))

#+end_src

** Custom macros
#+begin_src emacs-lisp
  (let ((cnt 0))
    (defmacro sk-defer-init (&rest body)
      "Defer BODY until the very first command after init."
      (declare (indent defun))
      (let ((name (intern (format "sk-defer-init-%d" (setq cnt (1+ cnt))))))
        `(progn
           (defun ,name ()
             ,@body
             (remove-hook 'pre-command-hook ',name)
             (unintern ',name nil))
           (add-hook 'pre-command-hook #',name)))))

  (defmacro sk-switch-buffer-repl (name mode repl run-repl &optional nobind)
    "Create NAME function which switch between a file of MODE and a REPL. Open
  REPL with RUN-REPL function if REPL is not yet opened. Evil-Leader z binding
  will be added to toggle MODE and REPL buffer unless NOBIND is not nil."
    (declare (indent defun))
    `(let ((last-mode "")
           (last-repl ""))
       (unless ,nobind
         (evil-leader/set-key-for-mode ',mode "z" ',name)
         (evil-leader/set-key-for-mode ',repl "z" ',name))
       (defun ,name ()
         (interactive)
         (cond ((equal major-mode ',mode)
                (setq last-mode (buffer-name))
                (if (get-buffer last-repl)
                    (pop-to-buffer last-repl)
                  (call-interactively ',run-repl)))
               ((equal major-mode ',repl)
                (setq last-repl (buffer-name))
                (when (get-buffer last-mode)
                  (pop-to-buffer last-mode)))
               (t nil)))))

  (defmacro sk-define-lisp-eval (name eval-region &optional doc)
    "Create NAME function to eval sexp of region. This is for evil-mode."
    (declare (indent defun))
    `(defun ,name (&rest _)
       ,@(when doc `(,doc))
       (interactive "p")
       (if (region-active-p)
           (call-interactively ',eval-region)
         (let* ((curr (min (1+ (point)) (point-max)))
                (back (save-excursion (goto-char curr) (backward-sexp) (point))))
           (,eval-region back curr)))
       (setq deactivate-mark t)))

  (defmacro html-head-css (&rest body)
    (declare (indent defun))
    `(concat
      "<style type=\"text/css\">\n"
      ,@body
      "</style>\n"))

  (defmacro html-head-js (&rest body)
    (declare (indent defun))
    `(concat
      "<script type=\"text/javascript\">\n"
      ,@body
      "</script>\n"))
#+end_src

** Custom functions
#+BEGIN_SRC emacs-lisp
  (defun sharp-ifdef-insert (start end pre)
    (save-excursion
      (goto-char (1- end))
      (end-of-line)
      (unless (equal (point) (line-beginning-position))
        (insert "\n"))
      (insert "#endif")
      (goto-char start)
      (beginning-of-line)
      (insert pre "\n")))

  (defun izero-insert (start end)
    "Wrap a region with #if 0 and #endif."
    (interactive "r")
    (sharp-ifdef-insert start end "#if 0"))

  (defun idef-insert (start end in)
    "Wrap a region with #ifdef and #endif."
    (interactive "r\nsDefine : ")
    (sharp-ifdef-insert start end (concat "#ifdef " in)))

  (defun find-file-in-tree (dir files &optional return-only-dir)
    "Find first matching file of FILES up to HOME or ROOT folder.
  FILES can be a file name string or list of files."
    (let ((default-directory (file-name-as-directory (expand-file-name dir)))
          (files (ensure-list files))
          (home (expand-file-name "~/"))
          (root "/"))
      (cl-loop for file = (cl-find-if (lambda (f) (file-exists-p f)) files)
               if file return (let ((file (expand-file-name file)))
                                (cond (return-only-dir default-directory)
                                      ((file-directory-p file)
                                       (file-name-as-directory file))
                                      (t file)))
               else if (or (not (file-exists-p default-directory))
                           (equal default-directory home)
                           (equal default-directory root))
               return nil
               else do (setq default-directory
                             (file-name-directory
                              (directory-file-name default-directory))))))

  (defun sk-sbin-dired ()
    (interactive)
    (let ((sbin (find-file-in-tree default-directory ".sbin")))
      (if sbin
          (dired sbin)
        (message "Folder .sbin not found."))))

  (defun sk-clang-complete-make ()
    "Generate .clang_complete file."
    (interactive)
    (let ((file "./.clang_complete")
          (includes
           (shell-command-to-string
            (concat
             "find -L -type f -name '*.h' -not -path '*/.*' -printf '-I%h\\n'"
             "| sort -u"))))
      (write-region includes nil file)))

  (defun insert-date ()
    "Insert date at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %A")))

  (defun insert-date-and-time ()
    "Insert date and time at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %a %p %l:%M")))

  (defun nuke-all-buffers ()
    "kill all buffers, leaving *scratch* only"
    (interactive)
    (mapc #'kill-buffer (buffer-list))
    (delete-other-windows))

  (defun hide-ctrl-M ()
    "Hides the disturbing '^M' showing up in files containing mixed UNIX and DOS
  line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  (defun move-line (n)
    "Move the current line up or down by N lines."
    (interactive "p")
    (let ((col (current-column))
          (txt (delete-and-extract-region (line-beginning-position)
                                          (line-beginning-position 2))))
      (forward-line n)
      (insert txt)
      ;; restore point to original column in moved line
      (forward-line -1)
      (forward-char col)))

  (defun transpose-windows ()
    "Swap positions of 2 windows."
    (interactive)
    (let ((buffer1 (window-buffer (selected-window)))
          (buffer2 (window-buffer (select-window (next-window)))))
      (switch-to-buffer buffer1)
      (switch-to-buffer-other-window buffer2)))

  (defun buffer-save-or-load (num &optional restore)
    (if restore
        (progn
          (jump-to-register num)
          (message "Windows are Restored by F%d" num))
      (window-configuration-to-register num)
      (message "Windows are saved to F%d" num)))

  (defun sk-C-c-map-to-leader-c-map (mode mode-map &optional exceptions)
    "Change C-c ... key map to <leader> c... key map, except EXCEPTIONS list"
    (let* ((ret nil)
           (target (alist-get ?\C-c mode-map))
           (cm (number-sequence ?\C-a ?\C-z))
           (ks (append cm (number-sequence ?A ?Z) (number-sequence ?a ?z))))
      (defun ctrl-map-search (elt pre)
        (if (symbolp elt)
            (setq ret (append ret (list (cons pre elt))))
          (dolist (k ks)
            (let ((nelt (alist-get k elt))
                  (npre (if (member k cm) (+ k 96) k)))
              (when nelt
                (ctrl-map-search nelt (append pre (list npre))))))))
      (ctrl-map-search target (list ?\c))
      (dolist (e ret)
        (let ((key (mapconcat 'single-key-description (car e) "")))
          (unless (and exceptions
                       (cl-some (lambda (e) (string-prefix-p e key)) exceptions))
            (evil-leader/set-key-for-mode mode key (cdr e)))))))

  (defun tmux-running-p ()
    "Check if tmux is currently running or not."
    (zerop (call-process "tmux" nil nil nil "has-session")))

  (defun tmux-new-window-here ()
    "Open new tmux window at the current path."
    (interactive)
    (if (not (tmux-running-p))
        (message "Tmux is not running!")
      (call-process "tmux" nil nil nil "new-window")
      (message "New tmux window is opened.")))

  (defun tmux-vim-current-file ()
    "Open a new tmux window and edit the current file with vim."
    (interactive)
    (if (not (tmux-running-p))
        (message "Tmux is not running!")
      (if (not (buffer-file-name))
          (user-error "Buffer %s does not visit a file" (current-buffer))
        (call-process "tmux" nil nil nil "new-window" "vim" (buffer-file-name))
        (message "New tmux window with vim is opened."))))

  (defun sk-project-root (&optional dir)
    (find-file-in-tree (or dir default-directory) sk-project-root-files t))

  (defun git-project-p ()
    (zerop (call-process "git" nil nil nil "rev-parse" "--is-inside-work-tree")))

  (defun git-tracked-file-p (&optional file-name)
    (let ((file (or file-name buffer-file-name)))
      (and file
           (file-exists-p file)
           (zerop (process-file "git" nil nil nil
                                "ls-files" "--error-unmatch"
                                (file-name-nondirectory file))))))

  (defun git-branch-of-file (file)
    (when (git-tracked-file-p file)
      (let* ((default-directory (file-name-directory file))
             (branch (shell-command-to-string "git branch --show-current"))
             (hash (when (equal branch "")
                     (shell-command-to-string "git rev-parse HEAD"))))
        (if hash
            (substring hash 0 7)
          (string-trim-right branch)))))

  (defun my-get-git-root-dir ()
    (let ((root (string-trim-right
                 (shell-command-to-string "git rev-parse --show-toplevel"))))
      (when (file-exists-p root)
        root)))

  (defun my-find-file-in-git-project (regex root)
    (when (file-exists-p (expand-file-name ".git" root))
      (let* ((default-directory (file-truename root))
             (ret (shell-command-to-string
                   (concat "git ls-files|grep -E '" regex "'"))))
        (split-string ret))))

  (defun sk-git-diff-relative ()
    "Run git diff with --relative option."
    (interactive)
    (if (zerop
         (call-process "git" nil (get-clear-buffer "*git-diff*") nil
                       "--no-pager" "diff" "--relative"
                       "--cached"))
        (progn
          (pop-to-buffer "*git-diff*")
          (goto-char (point-min))
          (diff-mode))
      (kill-buffer "*git-diff*")
      (message "Running git diff failed.")))

  (defun my-find-file-in-dir (regex &optional dir)
    (let* ((default-directory (or (and dir (file-truename dir))
                                  default-directory))
           (ret (shell-command-to-string (concat "ls|grep -E '" regex "'"))))
      (split-string ret)))

  (defun my-find-other-file ()
    "Switch betwen .c|.cpp and .h|.hpp files in project."
    (if-let* ((file (buffer-file-name))
              (base (file-name-base file))
              (ext (file-name-extension file))
              (root default-directory)
              (regex (cond ((member ext '("h" "hpp"))
                            (concat "(^|/)" base ".(c|cpp)$"))
                           ((member ext '("c" "cpp"))
                            (concat "(^|/)" base ".(h|hpp)$"))
                           (t nil)))
              (others (or (my-find-file-in-dir regex)
                          (and (setq root (my-get-git-root-dir))
                               (my-find-file-in-git-project regex root)))))
        (if (length= others 1)
            (find-file (expand-file-name (car others) root))
          (ivy-read "Switch to: " others
                    :action (lambda (file)
                              (find-file (expand-file-name file root)))
                    :caller #'my-find-other-file))))

  (defun sk-find-other-file (&optional FLEX-MATCHING)
    "Switch betwen .c|.cpp and .h|.hpp files."
    (interactive)
    (let ((inhibit-message t))
      (or (my-find-other-file)
          (user-error "No other file found"))))

  (defun async-shell-command-callback (cmd callback &rest args)
    (let ((callback callback)
          (args args))
      (set-process-sentinel
       (start-file-process "Async" nil shell-file-name shell-command-switch cmd)
       (lambda (process signal)
         (when (memq (process-status process) '(exit signal))
           (apply callback args))))
      nil))

  (defun shell-quote-remote-file (file)
    (let* ((local-name (file-local-name file))
           (domain (string-remove-suffix local-name file))
           (name (shell-quote-argument local-name)))
      (concat domain name)))

  (defun file-to-string (file &optional online)
    (let* ((target (if online (url-file-local-copy file) file))
           (content (ignore-errors
                      (with-temp-buffer
                        (insert-file-contents target)
                        (buffer-string)))))
      (when online (delete-file target))
      (or content "")))

  (let* ((origin-height (face-attribute 'default :height))
         (big-height (round (* origin-height 1.5)))
         (big-font nil))
    (defun sk-toggle-big-font ()
      (interactive)
      (if big-font
          (set-face-attribute 'default nil :height origin-height)
        (set-face-attribute 'default nil :height big-height))
      (setq big-font (not big-font))))

  (defun sk-package-upgrade-all ()
    "Upgrade all packages without asking the user."
    (interactive)
    (package-refresh-contents)
    (let* ((vc-handled-backends '(Git))
           (upgradeable (package--upgradeable-packages))
           (pkg-cnt (length upgradeable)))
      (if (not upgradeable)
          (message "No packages to upgrade")
        (mapc #'package-upgrade upgradeable)
        (message (format "%s packages upgraded. %s" pkg-cnt upgradeable)))))

  (defun add-sudo-to-command (sudo cmd)
    "Get password and add sudo to CMD if SUDO is non-nil, otherwise return CMD."
    (concat
     (when sudo
       (concat "echo "
               (shell-quote-argument (read-passwd "Password? "))
               "| sudo -S "))
     cmd))

  (defun get-clear-buffer (buffer)
    "Return the buffer specified by BUFFER. BUFFER is always returned empty."
    (with-current-buffer (get-buffer-create buffer)
      (erase-buffer)
      (current-buffer)))

  (defun sk-alist-to-js-obj (alist &optional omit-curly-braces)
    "Convert ALIST to javascript object string. When OMIT-CURLY-BRACES is non-nil,
  omit curly braces wrapping."
    (concat
     (unless omit-curly-braces "{ ")
     (string-join
      (cl-loop for (key . value) in alist
               collect
               (format
                (cond ((and (stringp key) (stringp value)) "\"%s\": \"%s\"")
                      ((stringp key) "\"%s\": %s")
                      ((stringp value) "%s: \"%s\"")
                      (t "%s: %s"))
                key value))
      ", ")
     (unless omit-curly-braces " }")))

  (defun sk-yank-file-name-or-path (&optional whole-path)
    (let* ((file-name (buffer-file-name))
           (name (and file-name
                      (if whole-path
                          file-name
                        (file-name-nondirectory file-name)))))
      (if (not name)
          (message "Not in the file buffer")
        (kill-new name)
        (message (format "File name yanked : %s" name)))))

  (defun sk-yank-file-name ()
    (interactive)
    (sk-yank-file-name-or-path))

  (defun sk-yank-file-whole-path ()
    (interactive)
    (sk-yank-file-name-or-path 'whole-path))

  (defun sk-google-search ()
    (interactive)
    (let ((target
           (if (region-active-p)
               (buffer-substring-no-properties (region-beginning) (region-end))
             (word-at-point t))))
      (browse-url (format "https://www.google.com/search?q=%s&ie=UTF-8" target))))

  (defun align-columns (beg end)
    "Align columns in region BEG END."
    (interactive "r")
    (align-regexp beg end
                  (rx (group (* space))
                      (+ (or (not (any space ?\" ?\( ?\[ ?\{))
                             (seq ?\"
                                  (* (not (any ?\")))
                                  ?\")
                             (seq ?\(
                                  (* (not (any ?\))))
                                  ?\))
                             (seq ?\[
                                  (* (not (any ?\])))
                                  ?\])
                             (seq ?\{
                                  (* (not (any ?\})))
                                  ?\}))))
                  1 1 t))

  (defun sk-get-gpg-encrypt-cmd (recipents)
    (interactive "MRecipent? ")
    (let* ((lst (split-string recipents "[ \f\t\n\r\v,;]+"))
           (to (mapconcat (lambda (r) (concat " --recipient " r)) lst))
           (cmd (concat "gpg" to " --encrypt ")))
      (kill-new cmd)
      (message cmd)))

  (defun list-to-hex-string (lst)
    "Convert a list of integers into a hex string."
    (mapconcat (lambda (x) (format "%02x" x)) lst ""))
#+END_SRC

** Color setting
Simple color setting function which has 'dark' and 'light' theme.

#+BEGIN_SRC emacs-lisp
  (defun my-theme-setting (&optional light-theme)
    (let ((base-fg-color   (if light-theme "Black" "Gray80"))
          (base-bg-color   (if light-theme "White" "Gray23"))
          (region-bg-color (if light-theme "PowderBlue" "DodgerBlue4")))
      (set-face-attribute 'default nil
                          :foreground base-fg-color :background base-bg-color)
      (set-face-attribute 'fringe nil
                          :background base-bg-color)
      (set-face-attribute 'header-line nil
                          :background base-bg-color :underline nil)
      (set-face-attribute 'vertical-border nil
                          :background base-bg-color)
      (set-face-attribute 'region nil
                          :background region-bg-color)))
  (defun sk-light-theme () (interactive) (my-theme-setting t))
  (defun sk-dark-theme  () (interactive) (my-theme-setting))
#+END_SRC

Enable dark theme.

#+BEGIN_SRC emacs-lisp
  (my-theme-setting)
#+END_SRC
** Korean and Font setting
#+BEGIN_SRC emacs-lisp
  (setq default-input-method "korean-hangul3")
  (when (display-graphic-p)
    (set-fontset-font t 'unicode "Unifont")
    (set-fontset-font t '(#x10000 . #xFFFFF) "Unifont Upper")
    (set-fontset-font t 'hangul sk-font)
    (set-face-attribute 'fixed-pitch nil :family sk-font))
#+END_SRC
** SK-mode-line
Simple mode line setting function.

#+BEGIN_SRC emacs-lisp
  ;;; mode-line face setting
  (face-spec-set 'mode-line '((t (:box nil))))
  (face-spec-set 'mode-line-inactive '((t (:box nil))))

  ;;; sk-mode-line
  (defun sk-mode-line ()
    (setq-default
     mode-line-format
     '("%e"
       (:eval
        (let* ((width (- (window-width)
                         (if (display-graphic-p) 5 6)))
               (evil-info (and (featurep 'evil) evil-mode
                               (concat " " (upcase (symbol-name evil-state)))))
               (buffer-info " %* ")
               (buffer-name (propertize " %b " 'face 'mode-line-emphasis))
               (mode-and-vc (propertize
                             (concat " "
                                     (format-mode-line mode-name)
                                     (and sk-vc-mode (concat " (" sk-vc-mode ")"))
                                     " ")
                             'face 'mode-line-inactive))
               (input-name (propertize (concat current-input-method-title " ")
                                       'face 'mode-line-inactive))
               (line-and-pos-info (format-mode-line " %l,%3c  %p%% "))
               (right-info (concat input-name line-and-pos-info))
               (right-len (string-width right-info))
               (left-info (truncate-string-to-width
                           (concat evil-info buffer-info buffer-name mode-and-vc)
                           (- width right-len)))
               (center-fill (propertize
                             " "
                             'face 'mode-line-inactive
                             'display
                             `((space :align-to
                                      (- (+ right right-fringe right-margin)
                                         ,right-len))))))
          (concat left-info center-fill right-info))))))
#+END_SRC

Enable =sk-mode-line=.

#+BEGIN_SRC emacs-lisp
  (sk-mode-line)
#+END_SRC
** Use-package
Set some default settings for =use-package=.

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-defer t
        use-package-always-ensure t
        use-package-enable-imenu-support t)
  (put :map 'lisp-indent-function 'defun)
#+END_SRC

Load =use-package=. From this point, only =use-package= will be used for
settings.

#+BEGIN_SRC emacs-lisp
  (require 'use-package)
#+END_SRC

* Async, Evil and Evil-leader packages
#+BEGIN_SRC emacs-lisp
  (use-package async
    :init
    (async-bytecomp-package-mode 1))

  (use-package evil-leader
    :init
    (defvar sk-evil-sub-leader "M-m")
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "<escape>" 'keyboard-quit
      "0"  'delete-window
      "1"  'delete-other-windows
      "2"  'split-window-below
      "3"  'split-window-right
      ","  'other-window
      "q"  'kill-current-buffer
      "Q"  'kill-emacs
      "u"  'pop-to-mark-command
      "x"  (lookup-key global-map (kbd "C-x"))
      "w"  'save-buffer
      "cc" (kbd "\C-c\C-c")
      "cy" 'sk-yank-file-name
      "cY" 'sk-yank-file-whole-path
      "eg" 'sk-google-search
      "st" 'tmux-new-window-here
      "sv" 'tmux-vim-current-file
      "hk" 'describe-key
      "hm" 'describe-mode
      "xq" 'read-only-mode
      "xv" 'evil-reload-file)
    (defun evil-sub-leader-mode ()
      (let* ((sub-leader (kbd sk-evil-sub-leader))
             (mode-map (cdr (assoc major-mode evil-leader--mode-maps)))
             (map (or mode-map evil-leader--default-map)))
        (evil-normalize-keymaps)
        (define-key evil-motion-state-local-map sub-leader map)
        (define-key evil-insert-state-local-map sub-leader map)
        (define-key evil-emacs-state-local-map sub-leader map)))
    (add-hook 'evil-local-mode-hook 'evil-sub-leader-mode t)
    (defun evil-leader/set-key-minor-mode (mode key def &rest bindings)
      (declare (indent defun))
      (while key
        (let ((k1 (kbd (concat evil-leader/leader key)))
              (k2 (kbd (concat sk-evil-sub-leader " " key))))
          (evil-define-minor-mode-key 'motion mode k1 def)
          (evil-define-minor-mode-key '(motion insert emacs) mode k2 def))
        (setq key (pop bindings)
              def (pop bindings))))

    (defun evil-leader/set-key-for-map (map key def &rest bindings)
      (declare (indent defun))
      (while key
        (let ((k1 (kbd (concat evil-leader/leader key)))
              (k2 (kbd (concat sk-evil-sub-leader " " key))))
          (evil-define-key* 'motion map k1 def)
          (define-key map k2 def))
        (setq key (pop bindings)
              def (pop bindings))))

    (setq evil-leader/no-prefix-mode-rx
          '("magit-.*-mode" "gnus-.*-mode" "package-.*-mode" "dired-mode")))

  (use-package evil
    :bind (("M-B" . evil-backward-WORD-begin)
           ("M-F" . (lambda ()
                      (interactive)
                      (evil-forward-WORD-end)
                      (forward-char)))
           ("S-<up>" . evil-window-up)
           ("S-<down>" . evil-window-down)
           ("S-<left>" . evil-window-left)
           ("S-<right>" . evil-window-right)
           :map evil-insert-state-map
           ("C-k" . kill-line)
           :map evil-visual-state-map
           ("p"   . evil-paste-pgvy)
           :map evil-ex-completion-map
           ("C-a" . move-beginning-of-line)
           ("C-b" . backward-char)
           ("C-d" . delete-char)
           ("C-k" . kill-line)
           ("M-n" . next-complete-history-element)
           ("M-p" . previous-complete-history-element))
    :custom
    (evil-undo-system 'undo-tree)
    (evil-want-C-u-scroll t)
    :init
    (evil-mode)
    :config
    (setq evil-insert-state-modes (delete 'wdired-mode evil-insert-state-modes))
    (evil-leader/set-key "C-v" 'my-evil-visual-block)
    (push '("*eldoc*" . emacs) evil-buffer-regexps)
    (add-hook 'evil-insert-state-entry-hook
              (lambda () (when buffer-read-only (read-only-mode -1))))
    (add-hook 'isearch-mode-hook
              (lambda (&rest _)
                (evil-put-property
                 'evil-state-properties 'normal :input-method t)))
    (add-hook 'isearch-mode-end-hook
              (lambda (&rest _)
                (when current-input-method (toggle-input-method))
                (evil-put-property
                 'evil-state-properties 'normal :input-method nil)))
    (defun evil-reload-file ()
      (interactive)
      (let ((p (point)))
        (find-alternate-file (buffer-file-name))
        (goto-char p)))
    (defun evil-paste-pgvy ()
      "Paste and restore visual block and yank."
      (interactive)
      (call-interactively 'evil-paste-after)
      (evil-visual-restore)
      (call-interactively 'evil-yank))
    (defun evil-swap-key (map key1 key2)
      "Swap KEY1 and KEY2 in MAP"
      (let  ((def1 (lookup-key map key1))
             (def2 (lookup-key map key2)))
        (define-key map key1 def2)
        (define-key map key2 def1)))
    (defun undo-at-here (n)
      (interactive "p")
      (save-excursion (undo-tree-undo-1 n)))
    (defun my-evil-visual-block (&optional arg)
      (interactive)
      (evil-execute-in-emacs-state)
      (rectangle-mark-mode arg))
    (evil-define-text-object evil-a-func (count &optional beg end type)
      (save-excursion
        (move-end-of-line 1)
        (let ((p1 (and (evil-backward-section-begin) (point)))
              (p2 (and (evil-forward-section-end) (point))))
          (evil-range p1 p2 type :expanded t))))
    (evil-define-text-object evil-inner-c-func (count &optional beg end type)
      (save-excursion
        (move-end-of-line 1)
        (evil-backward-section-begin)
        (let* ((p1 (ignore-errors (search-forward "{")))
               (p2 (ignore-errors (and p1 (evil-jump-item)))))
          (if p2
              (evil-range p1 p2 type :expanded t)
            (user-error "Can't find c function.")))))
    (define-key evil-inner-text-objects-map "d" 'evil-inner-bracket)
    (define-key evil-outer-text-objects-map "d" 'evil-a-bracket)
    (define-key evil-inner-text-objects-map "j" 'evil-inner-curly)
    (define-key evil-outer-text-objects-map "j" 'evil-a-curly)
    (define-key evil-inner-text-objects-map "f" 'evil-inner-c-func)
    (define-key evil-outer-text-objects-map "f" 'evil-a-func)
    (define-key evil-inner-text-objects-map "k" 'evil-inner-angle)
    (define-key evil-outer-text-objects-map "k" 'evil-an-angle)
    (evil-swap-key evil-motion-state-map "j" "gj")
    (evil-swap-key evil-motion-state-map "k" "gk")
    (evil-global-set-key 'normal "U" 'undo-at-here)
    (evil-global-set-key 'normal "Y" (kbd "y$"))
    (evil-global-set-key 'motion "Y" (kbd "y$"))
    (evil-global-set-key 'motion "$" 'end-of-line)
    (dolist (m '(image-mode special-mode))
      (evil-set-initial-state m 'emacs)))

  (use-package evil-anzu
    :demand t
    :after anzu)

  (use-package evil-visualstar
    :bind (:map evil-visual-state-map
            ("n" . evil-visualstar/begin-search-forward)
            ("N" . evil-visualstar/begin-search-backward))
    :config
    (global-evil-visualstar-mode))

  (use-package evil-surround
    :init
    (sk-defer-init (global-evil-surround-mode 1))
    :config
    (setq-default evil-surround-pairs-alist
                  (append evil-surround-pairs-alist
                          '((?` . ("`" . "`"))
                            (?d . ("[" . "]"))
                            (?j . ("{" . "}"))
                            (?k . ("<" . ">")))))
    (evil-define-key 'visual evil-surround-mode-map
      "gs" 'evil-surround-region))

  (use-package evil-commentary
    :init
    (sk-defer-init (evil-commentary-mode 1)))
#+END_SRC
* General packages - built-in
#+BEGIN_SRC emacs-lisp
  ;;; Personal packages
  (use-package company-sql
    :ensure nil
    :load-path emacs-etc-dir
    :hook ((sql-mode sql-interactive-mode) . my-sql-mode-hook)
    :config
    (defun my-sql-mode-hook ()
      (add-to-list 'company-backends 'company-sql)))

  ;;; Built-in packages
  (use-package recentf
    :ensure nil
    :custom (recentf-max-saved-items 100)
    :init
    (sk-defer-init (recentf-mode 1))
    :config
    (add-to-list 'recentf-exclude
                 (expand-file-name "elpa/.*" emacs-config-dir)))

  (use-package calendar
    :ensure nil
    :bind (:map calendar-mode-map
            ("h"       . calendar-backward-day)
            ("j"       . calendar-forward-week)
            ("k"       . calendar-backward-week)
            ("l"       . calendar-forward-day)
            ("C-f"     . calendar-scroll-left-three-months)
            ("C-b"     . calendar-scroll-right-three-months)
            ("<left>"  . calendar-scroll-right)
            ("<right>" . calendar-scroll-left))
    :config
    (setq calendar-date-display-form
          '((format "%s-%.2d-%.2d%s" year
                    (string-to-number month)
                    (string-to-number day)
                    (if dayname (concat " " dayname) "")))
          diary-file "~/Dropbox/org/diary")
    (evil-set-initial-state 'calendar-mode 'emacs))

  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
            ("M-o"   . dired-omit-mode)
            ("c"     . my-dired-compress)
            ("C"     . my-dired-do-copy)
            ("D"     . my-dired-do-delete)
            ("j"     . dired-next-line)
            ("k"     . dired-previous-line)
            ("r"     . my-dired-rsync)
            ("x"     . my-dired-do-flagged-delete)
            ("/"     . swiper)
            ("^"     . dired-up-and-close-dir)
            ("bp"    . my-dired-pdf-size-down)
            ("bx"    . my-dired-open-extern)
            ("<DEL>" . dired-up-and-close-dir))
    :init
    (add-to-list 'magic-mode-alist
                 '((lambda () (< large-file-warning-threshold (buffer-size)))
                   . text-mode))
    :config
    (require 'dired-aux)
    (require 'dired-x)
    (setq dired-kill-when-opening-new-dired-buffer t
          dired-listing-switches "-alh --group-directories-first"
          dired-omit-extensions '("~")
          dired-omit-files (rx bol (or "#" "."))
          dired-omit-verbose nil)
    (add-to-list 'dired-compress-files-alist '("\\.zst\\'" . "tar -acf %o %i"))
    (add-to-list 'dired-guess-shell-alist-user '("\\.zst\\'" "tar xvf"))
    (add-to-list 'display-buffer-alist
                 '("*Async Shell Command*" display-buffer-no-window))
    (add-hook 'dired-mode-hook 'dired-omit-mode)
    (add-hook 'wdired-mode-hook 'turn-on-undo-tree-mode)

    (evil-set-initial-state 'dired-mode 'emacs)
    (evil-leader/set-key-for-mode 'dired-mode
      "cy" 'my-dired-copy-path            ; copy current folder path
      "cY" 'my-dired-copy-filepath        ; copy selected file path
      "ee" 'wdired-change-to-wdired-mode
      "ec" 'wdired-finish-edit
      "eq" 'wdired-exit)

    (defun my-dired-copy-path ()
      (interactive)
      (let ((path (expand-file-name default-directory)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun my-dired-copy-filepath ()
      (interactive)
      (let ((path (dired-file-name-at-point)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun dired-up-and-close-dir (n)
      (interactive "p")
      (let* ((buf (get-buffer (buffer-name)))
             (curr (dired-current-directory))
             (dest (file-name-directory (directory-file-name curr))))
        (dotimes (_ (- n 1))
          (setq curr dest)
          (setq dest (file-name-directory (directory-file-name dest))))
        (dired dest)
        (dired-goto-file curr)
        (kill-buffer buf)))

    (defun my-dired-get-target (prompt &optional files)
      (let ((files (if files files '(nil)))
            (defaults (dired-dwim-target-defaults nil nil)))
        (expand-file-name
         (minibuffer-with-setup-hook
             (lambda ()
               (setq-local minibuffer-default-add-function nil)
               (setq minibuffer-default defaults))
           (dired-mark-read-file-name
            prompt default-directory 'copy nil files nil)))))

    (defun my-dired-rsync ()
      (interactive)
      (let* ((files (dired-get-marked-files nil current-prefix-arg))
             (source (mapcar #'shell-quote-remote-file files))
             (regex (rx bol "/" (or "ssh" "scp") (? any) ":"))
             (target (my-dired-get-target "Rsync to: " files))
             (src-remote-p (file-remote-p default-directory))
             (dst-remote-p (file-remote-p target))
             (target (if dst-remote-p
                         (replace-regexp-in-string regex "" target)
                       target))
             (cmd (concat "rsync -ahs"
                          (when (or src-remote-p dst-remote-p) "z")
                          " --info=progress2 "))
             (arg (mapconcat
                   (if (or (not src-remote-p)
                           (and src-remote-p dst-remote-p))
                       #'file-local-name
                     (lambda (f) (replace-regexp-in-string regex "" f)))
                   source " "))
             (dst (concat " " (shell-quote-remote-file target)))
             (default-directory (if (and src-remote-p (not dst-remote-p))
                                    "~/"
                                  default-directory)))
        (async-shell-command (concat cmd arg dst) "*rsync*")
        (with-current-buffer "*rsync*"
          (view-mode))))

    (defun my-dired-pdf-size-down ()
      (interactive)
      (let ((file (shell-quote-argument (dired-get-filename)))
            (temp (make-temp-file ".temp" nil ".pdf")))
        (if (not (equal (file-name-extension file) "pdf"))
            (message "Not a PDF file.")
          (async-shell-command
           (concat
            "gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 "
            "-dPDFSETTINGS=/printer -dNOPAUSE -dQUIET -dBATCH -dPrinted=false "
            "-sOutputFile=" temp " " file " && "
            "mv " temp " " file)))))

    (defun my-dired-compress ()
      "Compress files asynchronously."
      (interactive)
      (let* ((defaults (dired-dwim-target-defaults nil nil))
             (minibuffer-default defaults)
             (files (mapcar #'file-name-nondirectory (dired-get-marked-files)))
             (source (mapcar #'shell-quote-argument files))
             (inital-name (if (equal (length files) 1)
                              (if (dired-nondirectory-p (car files))
                                  (file-name-base (car files))
                                (file-name-nondirectory (car files)))
                            (file-name-nondirectory
                             (directory-file-name default-directory))))
             (inital-name (if (or (string-empty-p inital-name)
                                  (string= inital-name "~"))
                              "default"
                            inital-name))
             (name (ivy-read "Compress file name: " nil
                             :initial-input
                             (concat inital-name ".zip")))
             (target (shell-quote-argument name))
             (ext (file-name-extension name))
             (cmd (pcase ext
                    ("zip" "zip -r ")
                    ("7z" "7z a ")
                    ("7zs" (concat "7z a -mhe=on -p"
                                   (password-read "Password: ")
                                   " "))
                    (_ "tar acvf "))))
        (when ext
          (async-shell-command-callback
           (concat cmd target " " (string-join source " "))
           (lambda (file)
             (dired-add-file file ?Z)
             (message "Compress files done."))
           (expand-file-name name default-directory)))))

    (defun my-dired-do-copy (&optional arg)
      "Copy files asynchronously."
      (interactive "p")
      (let* ((files (dired-get-marked-files))
             (source (mapcar #'shell-quote-argument files))
             (target (my-dired-get-target "Copy to: " files))
             (dst (shell-quote-argument target))
             (remote (or (file-remote-p default-directory)
                         (file-remote-p target)))
             (target-files
              (if (not (directory-name-p target))
                  (list target)
                (mapcar
                 (lambda (f) (expand-file-name (file-name-nondirectory f) target))
                 files)))
             (dired-copy-dereference (if (zerop (% arg 10))
                                         (not dired-copy-dereference)
                                       dired-copy-dereference)))
        (if (not remote)
            (async-shell-command-callback
             (add-sudo-to-command
              (> arg 1)
              (concat "cp -rf "
                      (when dired-copy-dereference " -L ")
                      (string-join source " ") " "
                      dst))
             (lambda (target-files)
               (mapc (lambda (f)
                       (dired-remove-file f)
                       (dired-add-file f ?C))
                     target-files)
               (message "Copy files done."))
             target-files)
          (mapc (lambda (f) (copy-file f target t)) files)
          (mapc (lambda (f)
                  (dired-remove-file f)
                  (dired-add-file f ?C))
                target-files)
          (message "Copy files done."))))

    (defun my-dired-do-delete (&optional arg)
      "Delete files asynchronously."
      (interactive "p")
      (let* ((remote (file-remote-p default-directory))
             (files (dired-get-marked-files))
             (source (mapcar #'shell-quote-argument files)))
        (when (and files
                   (dired-mark-pop-up
                    " *Deletions*" 'delete files #'yes-or-no-p "Delete files? "))
          (if (not remote)
              (async-shell-command-callback
               (add-sudo-to-command
                (> arg 1)
                (concat "rm -rf " (string-join source " ")))
               (lambda (files)
                 (mapc (lambda (f) (dired-delete-entry f)) files)
                 (message "Delete files done."))
               files)
            (mapc (lambda (f)
                    (if (file-accessible-directory-p f)
                        (delete-directory f t)
                      (delete-file f)))
                  files)
            (mapc (lambda (f) (dired-delete-entry f)) files)
            (message "Delete files done.")))))

    (defun my-dired-do-flagged-delete (&optional arg)
      "Delete files flagged for deletion asynchronously."
      (interactive "p")
      (let* ((remote (file-remote-p default-directory))
             (dired-marker-char dired-del-marker)
             (regexp (dired-marker-regexp))
             (marks (save-excursion (goto-char (point-min))
                                    (re-search-forward regexp nil t)))
             (files (when marks (dired-get-marked-files)))
             (source (mapcar #'shell-quote-argument files)))
        (when (and files
                   (dired-mark-pop-up
                    " *Deletions*" 'delete files #'yes-or-no-p "Delete files? "))
          (if (not remote)
              (async-shell-command-callback
               (add-sudo-to-command
                (> arg 1)
                (concat "rm -rf " (string-join source " ")))
               (lambda (files)
                 (mapc (lambda (f) (dired-delete-entry f)) files)
                 (message "Delete files done."))
               files)
            (mapc (lambda (f)
                    (if (file-accessible-directory-p f)
                        (delete-directory f t)
                      (delete-file f)))
                  files)
            (mapc (lambda (f) (dired-delete-entry f)) files)
            (message "Delete files done.")))))

    (defun my-dired-open-extern ()
      "Open file with an external program."
      (interactive)
      (let ((path (dired-get-filename)))
        (call-process "xdg-open" nil 0 nil path)))

    (defun sk-meld-dir ()
      (interactive)
      (let ((dir1 (my-dired-get-target "Dir1 : "))
            (dir2 (my-dired-get-target "Dir2 : ")))
        (start-process "meld" nil "meld" dir1 dir2))))

  (use-package ob-janet
    :ensure nil
    :load-path (lambda () (expand-file-name "ob-janet/" emacs-etc-dir))
    :config
    (add-to-list 'org-babel-load-languages '(janet . t)))

  (use-package org
    :ensure nil
    :init
    (evil-leader/set-key
      "na" 'org-agenda)
    :config
    (require 'ox)
    (require 'ox-beamer)
    (require 'counsel)
    (require 'ob-janet)
    (setq
     my-org-path "~/Dropbox/org/"
     my-org-diary (concat my-org-path (format-time-string "%Y_personal.org"))
     my-org-gtd (concat my-org-path (format-time-string "%Y_gtd.org"))
     my-org-work (concat my-org-path (format-time-string "%Y_work.org"))
     org-agenda-custom-commands
     '(("g" "All GTD view"
        ((agenda)
         (todo "NEXT" ((org-agenda-overriding-header "NEXTs:")))
         (todo "TODO" ((org-agenda-overriding-header "TODOs:")))
         (todo "WAIT" ((org-agenda-overriding-header "WAITs:")))))
       ("p" "Personal GTD view"
        ((agenda "" ((org-agenda-files (list my-org-gtd))))
         (todo "NEXT" ((org-agenda-files (list my-org-gtd))
                       (org-agenda-overriding-header "Nexts:")))
         (todo "TODO" ((org-agenda-files (list my-org-gtd))
                       (org-agenda-overriding-header "TODOs:")))
         (todo "WAIT" ((org-agenda-files (list my-org-gtd))
                       (org-agenda-overriding-header "WAITs:")))))
       ("w" "Work GTD view"
        ((agenda "" ((org-agenda-files (list my-org-work))))
         (todo "NEXT" ((org-agenda-files (list my-org-work))
                       (org-agenda-overriding-header "NEXTs:")))
         (todo "TODO" ((org-agenda-files (list my-org-work))
                       (org-agenda-overriding-header "TODOs:")))
         (todo "WAIT" ((org-agenda-files (list my-org-work))
                       (org-agenda-overriding-header "WAITs:"))))))
     org-agenda-files (list my-org-path)
     org-agenda-start-on-weekday 0
     org-babel-load-languages '((C . t)
                                (css . t)
                                (dot . t)
                                (emacs-lisp . t)
                                (gnuplot . t)
                                (latex . t)
                                (octave . t)
                                (plantuml . t)
                                (python . t)
                                (shell . t))
     org-confirm-babel-evaluate nil
     org-capture-templates
     `(("i" "Inbox"
        entry (file+headline ,my-org-gtd "Inbox") "* %?\n%U")

       ("p"  "Personal")
       ("pt" "Personal Todo"
        entry (file+olp+datetree ,my-org-gtd) "* TODO %?\n%t" :time-prompt t)
       ("pe" "Personal Event"
        entry (file+olp+datetree ,my-org-gtd) "* %?\n%t" :time-prompt t)
       ("pw" "Personal Wait"
        entry (file+olp+datetree ,my-org-gtd) "* WAIT %?\n%t")
       ("pn" "Personal Note"
        entry (file+headline ,my-org-gtd "Notes") "* %?\n%U")
       ("pd" "Personal Diary" plain (file+olp+datetree ,my-org-diary) ""
        :immediate-finish t :jump-to-captured t :time-prompt t)

       ("w"  "Work")
       ("wt" "Work Todo" entry (file+olp+datetree ,my-org-work) "* TODO %?\n%t"
        :time-prompt t :tree-type week)
       ("we" "Work Event" entry (file+olp+datetree ,my-org-work) "* %?\n%t"
        :time-prompt t :tree-type week)
       ("ww" "Work Wait" entry (file+olp+datetree ,my-org-work) "* WAIT %?\n%t"
        :tree-type week)
       ("wn" "Work Note" entry (file+olp+datetree ,my-org-work) "* %?\n%U"
        :tree-type week)
       ("wd" "Work Daily" entry (file+olp+datetree ,my-org-work) "* Daily\n%U"
        :immediate-finish t :jump-to-captured t :time-prompt t :tree-type week))
     org-default-notes-file my-org-gtd
     org-directory my-org-path
     org-element-use-cache nil
     org-export-default-language "kr"
     org-export-headline-levels 2
     org-export-time-stamp-file nil
     org-export-with-email t
     org-export-with-section-numbers nil
     org-export-with-sub-superscripts nil
     org-export-with-toc 1
     org-html-style-default
     (html-head-css
       (file-to-string (expand-file-name "org.css" emacs-etc-dir)))
     org-html-inline-image-rules
     '(("file" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("http" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'"))
     org-html-metadata-timestamp-format "%Y-%m-%d"
     org-html-validation-link ""
     org-imenu-depth 4
     org-latex-packages-alist '(("" "kotex" nil)
                                ("" "parskip" nil)
                                ("margin=2cm" "geometry" nil)
                                ("cachedir=/tmp/minted" "minted"))
     org-latex-pdf-process
     '("%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "%latex -shell-escape -interaction nonstopmode -output-directory %o %f")
     org-latex-src-block-backend '(verbatim minted)
     org-latex-tables-centered nil
     org-latex-title-command "\\maketitle \\clearpage"
     org-latex-toc-command "\\tableofcontents \\clearpage"
     org-log-done 'time
     org-outline-path-complete-in-steps nil
     org-plantuml-jar-path "/usr/share/java/plantuml/plantuml.jar"
     org-refile-targets '((nil :maxlevel . 5))
     org-refile-use-outline-path t
     org-src-lang-modes (cons '("dot" . graphviz-dot) org-src-lang-modes)
     org-src-window-setup 'current-window
     org-startup-folded t
     org-startup-indented t
     org-startup-with-inline-images t
     org-tags-column -80
     org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "WAIT(w)" "|" "DONE(d)" "KILL(k)")))

    (add-to-list 'safe-local-variable-values '(org-html-inline-images . embed))

    (sk-C-c-map-to-leader-c-map 'org-mode org-mode-map '("cc" "ck"))
    (evil-leader/set-key-for-mode 'org-mode
      "c <SPC>" 'org-table-blank-field
      "c'"  'org-edit-special
      "c!"  'org-time-stamp-inactive
      "c*"  'org-ctrl-c-star
      "c+"  'org-table-sum
      "c,"  'org-insert-structure-template
      "c-"  'org-ctrl-c-minus
      "c."  'org-time-stamp
      "c`"  'org-table-edit-field
      "cL"  'org-store-link
      "ee"  'org-edit-src-code
      "tc"  'org-table-create
      "tl"  'org-tags-view)
    (evil-leader/set-key-minor-mode 'org-src-mode
      "ec" 'org-edit-src-exit
      "eq" 'org-edit-src-abort)
    (evil-leader/set-key-minor-mode 'org-capture-mode
      "ck" 'org-capture-kill
      "cw" 'org-capture-refile)
    (evil-define-key 'motion org-mode-map
      (kbd "TAB") 'org-cycle
      "gb" 'org-goto-bottom-heading
      "gh" 'org-up-element
      "gl" 'org-down-element
      "gj" 'org-forward-element
      "gk" 'org-backward-element)
    (add-hook 'org-mode-hook
              (lambda ()
                (evil-local-set-key 'insert (kbd "<tab>") 'my-org-tab)
                (evil-local-set-key 'insert (kbd "TAB") 'my-org-tab)))
    (evil-declare-motion 'org-up-element)
    (evil-declare-motion 'org-down-element)
    (evil-declare-motion 'org-forward-element)
    (evil-declare-motion 'org-backward-element)

    (dolist (mode '("js" "javascript"))
      (add-to-list 'org-src-lang-modes `(,mode . js2)))
    (dolist (mode '("css" "html" "vue" "web"))
      (add-to-list 'org-src-lang-modes `(,mode . web)))

    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages)
    (defun my-org-tab (arg)
      (interactive "P")
      (if (org-at-table-p)
          (org-cycle arg)
        (company-indent-or-complete-common arg)))
    (defun my-org-inline-image-hook ()
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun my-org-before-process-hook (exporter)
      (setq-local org-html-head
                  (concat
                   org-html-head
                   (html-head-css
                     (apply #'format
                            "\n.src {background-color: %s; color: %s;}\n"
                            (mapcar
                             (lambda (x)
                               (apply #'color-rgb-to-hex
                                      (append (color-name-to-rgb x) '(2))))
                             (list (face-background 'default)
                                   (face-foreground 'default))))))))
    (defun sk-org-capture-image ()
      (interactive)
      (let* ((img (file-relative-name
                   (counsel--find-file-1 "Image file name: " nil nil nil)
                   default-directory))
             (dir (file-name-directory img)))
        (and dir (not (file-exists-p dir))
             (make-directory dir t))
        (call-process "import" nil nil nil img)
        (when (file-exists-p img)
          (insert (concat "[[file:" img "]]")))))
    (add-hook 'org-babel-after-execute-hook 'my-org-inline-image-hook)
    (add-hook 'org-export-before-processing-functions 'my-org-before-process-hook)

    (defun org-html--embed-image (source attributes info)
      (format "<img src=\"data:image/%s;base64,%s\"%s />"
              (or (file-name-extension source) "")
              (base64-encode-string
               (with-temp-buffer
                 (insert-file-contents-literally source)
                 (buffer-string)))
              (file-name-nondirectory source)))
    (advice-add 'org-html--format-image :around
                (lambda (func source attributes info)
                  (if (not (equal 'embed (plist-get info :html-inline-images)))
                      (apply func (list source attributes info))
                    (apply #'org-html--embed-image
                           (list source attributes info)))))
    (defun org-goto-bottom-heading ()
      (interactive)
      (goto-char (point-max))
      (outline-previous-heading)
      (org-show-context))
    (defun sk-org-tag-view-all ()
      (interactive)
      (let ((org-agenda-files
             (directory-files-recursively my-org-path "^[^#.].*\.org$"))
            (recentf-exclude (list (concat my-org-path ".*"))))
        (call-interactively 'org-tags-view))))

  (use-package ibuffer
    :ensure nil
    :bind ("C-x b" . ibuffer)
    :config
    (setq ibuffer-expert t
          ibuffer-sorting-mode 'ibuffer-do-sort-by-mode-name-then-filename
          ibuffer-default-sorting-mode 'mode-name-then-filename
          ibuffer-saved-filter-groups
          `(("home"
             ("Emacs" (or (mode . emacs-lisp-mode)
                          (mode . lisp-interaction-mode)))
             ("Org / MD" (or (mode . org-mode)
                             (mode . markdown-mode)))
             ("Magit" (name . "^Magit"))
             ("Code" (derived-mode . prog-mode))
             ("Shell" (or (mode . eshell-mode)
                          (mode . shell-mode)
                          (name . ,shell-command-buffer-name)
                          (name . ,shell-command-buffer-name-async)))
             ("Dired" (mode . dired-mode))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
    (define-ibuffer-sorter mode-name-then-filename
      "Sort the buffers first by their mode name, then by their file name or
  process name."
      (:description "mode name, then file name")
      (let* ((mode-a (with-current-buffer (car a) (format-mode-line mode-name)))
             (mode-b (with-current-buffer (car b) (format-mode-line mode-name)))
             (file-a (or (with-current-buffer (car a) (ibuffer-buffer-file-name))
                         (let ((pr-a (get-buffer-process (car a))))
                           (and (processp pr-a) (process-name pr-a)))))
             (file-b (or (with-current-buffer (car b) (ibuffer-buffer-file-name))
                         (let ((pr-b (get-buffer-process (car b))))
                           (and (processp pr-b) (process-name pr-b))))))
        (if (string= mode-a mode-b)
            ;; Same mode, sort by filename/process
            (string-lessp file-a file-b)
          ;; Different modes, sort by mode
          (string-lessp (downcase mode-a) (downcase mode-b)))))
    (defun my-ibuffer-unmark-all ()
      "Unmark all immdiately"
      (interactive)
      (ibuffer-unmark-all ?\s))
    (define-key ibuffer-mode-map (kbd "* *") 'my-ibuffer-unmark-all)
    (define-ibuffer-column size
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "home"))))

  (use-package shell
    :ensure nil
    :init
    (evil-leader/set-key
      "sc" 'shell-command
      "ss" 'shell))

  (use-package eshell
    :ensure nil
    :hook (eshell-mode . my-eshell-setup)
    :init
    (evil-leader/set-key
      "se" 'eshell)
    :config
    (defun eshell/clear ()
      "Clear Eshell buffer"
      (interactive)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (execute-kbd-macro (kbd "<RET>"))))
    (defun my-eshell-change-whole-line ()
      (interactive)
      (execute-kbd-macro (kbd "0C")))
    (defun my-eshell-history ()
      (interactive)
      (my-comint-history eshell-history-ring))
    (defun my-eshell-setup ()
      (setenv "TERM" "screen-256color")
      (evil-define-key 'insert eshell-mode-map (kbd "C-a") 'eshell-bol)
      (evil-define-key 'normal eshell-mode-map "S" 'my-eshell-change-whole-line)
      (evil-define-key 'motion eshell-mode-map
        "0"  'eshell-bol
        "gk" 'eshell-previous-prompt
        "gj" 'eshell-next-prompt
        (kbd "M-p") (lambda () (interactive) nil)
        (kbd "M-n") (lambda () (interactive) nil)
        (kbd "RET") 'my-comint-return))
    (evil-leader/set-key-for-mode 'eshell-mode
      "l"  'my-eshell-history))

  (use-package term
    :ensure nil
    :config
    (evil-set-initial-state 'term-mode 'emacs)
    (defun term-send-esc ()
      "Send ESC in term mode."
      (interactive)
      (term-send-raw-string "\e"))
    (define-key term-raw-map (kbd "<escape>") 'term-send-esc))

  (use-package paren
    :ensure nil
    :init
    (sk-defer-init (show-paren-mode 1)))

  (use-package hl-line
    :ensure nil
    :custom-face
    (hl-line ((((background light)) :background "AntiqueWhite" :extend t)
              (((background dark)) :background "gray16" :extend t)))
    :init
    (sk-defer-init (global-hl-line-mode 1)))

  (use-package ansi-color
    :ensure nil
    :hook (compilation-filter . my-ansi-colorize-buffer)
    :custom-face
    (ansi-color-blue ((t :foreground "skyblue3" :background "skyblue3")))
    :config
    (defun my-ansi-colorize-buffer ()
      (let ((buffer-read-only nil))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (use-package display-line-numbers
    :ensure nil
    :custom-face
    (line-number ((t :foreground "gray51" :inherit 'default))
                 face-defface-spec)
    (line-number-current-line ((t (:inherit 'default))) face-defface-spec)
    :hook
    ((find-file prog-mode) . display-line-numbers-mode)
    :config
    (setq-default display-line-numbers-width 3
                  display-line-numbers-type 'visual
                  display-line-numbers-current-absolute nil))

  (use-package tramp
    :ensure nil
    :config
    (setq remote-file-name-inhibit-cache nil
          tramp-auto-save-directory "/tmp/tramp/"
          tramp-chunksize 2000
          tramp-verbose 1)
    ;; TRAMP respect PATH variable on remote machine.
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
    (add-to-list 'tramp-remote-process-environment "HISTFILE=/dev/null"))

  (use-package autorevert
    :ensure nil
    :hook (find-file . global-auto-revert-mode)
    :config
    (setq auto-revert-check-vc-info t
          auto-revert-verbose nil))

  (use-package view
    :ensure nil
    :hook (view-mode . evil-motion-state))

  (use-package flymake
    :ensure nil
    :config
    (evil-set-initial-state 'flymake-diagnostics-buffer-mode 'emacs)
    (evil-define-key 'motion flymake-mode-map
      "]e" 'flymake-goto-next-error
      "[e" 'flymake-goto-prev-error)
    (add-hook 'flymake-mode-hook (lambda () (evil-normalize-keymaps))))

  (use-package comint
    :ensure nil
    :commands my-comint-history
    :config
    (defun my-comint-history (&optional ring)
      (interactive)
      (let ((input-ring (if ring ring comint-input-ring)))
        (cl-letf (((symbol-function 'ivy-completion-in-region-action)
                   (lambda (cmd) (my-comint-return) (insert cmd))))
          (counsel--browse-history input-ring
                                   :caller #'counsel-shell-history))))
    (defun my-comint-return ()
      (interactive)
      (evil-goto-line)
      (evil-append-line 1))
    (evil-leader/set-key-for-map comint-mode-map
      "l"  'my-comint-history)
    (evil-define-key 'normal comint-mode-map
      "gj" 'comint-next-prompt
      "gk" 'comint-previous-prompt
      (kbd "RET") 'my-comint-return)
    (evil-define-key 'insert comint-mode-map
      (kbd "RET") 'comint-send-input))

  (use-package package
    :ensure nil
    :init
    (sk-defer-init (package-read-all-archive-contents))
    :config
    (setq package-install-upgrade-built-in t))

  (use-package package-vc
    :ensure nil
    :config
    (remove-hook 'package-read-archive-hook 'package-vc--read-archive-data))

  (use-package diff-mode
    :ensure nil
    :config
    (sk-C-c-map-to-leader-c-map 'diff-mode diff-mode-map))

  (use-package ediff
    :ensure nil
    :config
    (setq ediff-split-window-function 'split-window-horizontally
          ediff-window-setup-function 'ediff-setup-windows-plain))

  (use-package eldoc
    :ensure nil
    :config
    (setq eldoc-echo-area-use-multiline-p nil))

  (use-package help-mode
    :ensure nil
    :config
    (evil-define-key 'motion help-mode-map
      "q"  'quit-window
      "[g" 'help-go-back
      "]g" 'help-go-forward
      (kbd "<tab>") 'forward-button))

  (use-package smerge-mode
    :ensure nil
    :custom-face
    (smerge-refined-added ((((background light)) (:background "grey"))
                           (((background dark)) (:background "gray35")))))

  (use-package vc
    :ensure nil
    :custom
    (vc-follow-symlinks nil)
    (vc-handled-backends nil)
    :init
    (make-variable-buffer-local 'sk-vc-mode)
    (put 'sk-vc-mode 'risky-local-variable t)
    (put 'sk-vc-mode 'permanent-local t)
    (defun sk-vc-refresh-state ()
      (setq sk-vc-mode (git-branch-of-file (buffer-file-name))))
    (defalias 'vc-refresh-state 'sk-vc-refresh-state))

  (use-package tex-mode
    :ensure nil
    :config
    (setq-default TeX-master nil)
    (setq TeX-parse-self t
          TeX-PDF-mode t)
    (evil-leader/set-key-for-mode 'latex-mode
      "cc" 'my-latex-compile
      "ce" 'LaTeX-environment
      "cj" 'LaTeX-insert-item
      "cs" 'LaTeX-section
      "cv" 'TeX-view
      "cz" 'LaTeX-command-section)
    (defun my-latex-compile ()
      (interactive)
      (TeX-command "LaTeX" 'TeX-master-file)))

  (use-package bookmark
    :ensure nil
    :custom (bookmark-set-fringe-mark nil)
    :config
    (remove-hook 'kill-emacs-hook 'bookmark-exit-hook-internal))

  (use-package rect
    :ensure nil
    :config
    (defun rectangle--default-line-number-format (start end start-at)
      (concat "%"
              (int-to-string (length (int-to-string (+ (count-lines start end)
                                                       start-at))))
              "d. ")))

  (use-package winner
    :ensure nil
    :custom (winner-dont-bind-my-keys t)
    :init (sk-defer-init (winner-mode 1))
    :config
    (evil-leader/set-key
      "xwu" 'winner-undo
      "xwr" 'winner-redo))

  (use-package epa
    :bind (:map epa-key-list-mode-map
            ("/" . swiper)))
#+END_SRC
* General packages - external
#+BEGIN_SRC emacs-lisp
  (use-package bind-key
    :init
    (bind-keys*
     ("C-c <escape>" . keyboard-quit)
     ("C-x <escape>" . keyboard-quit)
     ("M-,"          . my-other-window)
     ("M-<f5>"       . sk-sbin-dired)
     ("C-M-,"        . transpose-windows)
     ("M-S-<up>"     . (lambda (&optional arg)
                         (interactive "p")
                         (move-line (- (or arg 1)))))
     ("M-S-<down>"   . (lambda (&optional arg)
                         (interactive "p")
                         (move-line (or arg 1))))
     ("<f7>"         . (lambda () (interactive) (buffer-save-or-load 7 t)))
     ("<f8>"         . (lambda () (interactive) (buffer-save-or-load 8 t)))
     ("C-<f7>"       . (lambda () (interactive) (buffer-save-or-load 7)))
     ("C-<f8>"       . (lambda () (interactive) (buffer-save-or-load 8)))
     ("S-SPC"        . toggle-input-method)
     :map minibuffer-local-map
     ("<escape>"     . minibuffer-keyboard-quit))
    (defun my-other-window ()
      (interactive)
      (if (minibufferp)
          (abort-recursive-edit)
        (when (or (evil-insert-state-p) (evil-visual-state-p))
          (evil-normal-state))
        (call-interactively 'other-window))))

  (use-package package-loading-notifier
    :custom  (package-loading-notifier-packages '(helm org magit yasnippet))
    :init
    (package-loading-notifier-mode 1))

  (use-package company
    :init
    (sk-defer-init (global-company-mode 1))
    :config
    (setq company-format-margin-function nil)
    (defun my-company-abort ()
      (when (company--active-p)
        (company-cancel 'abort)))
    (add-hook 'evil-insert-state-exit-hook #'my-company-abort)
    (define-key company-active-map (kbd "M-n") 'company-select-next)
    (define-key company-active-map (kbd "M-p") 'company-select-previous)
    (evil-define-key 'insert company-mode-map
      (kbd "M-/") 'company-yas-expand
      (kbd "TAB") 'company-indent-or-complete-common))

  (use-package company-irony
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony))

  (use-package company-irony-c-headers
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony-c-headers))

  (use-package company-web
    :demand t
    :after web-mode)

  (use-package company-go
    :demand t
    :after go-mode
    :config
    (add-to-list 'company-backends 'company-go))

  (use-package company-ghci
    :demand t
    :after haskell-mode
    :config
    (add-to-list 'company-backends 'company-ghci))

  (use-package undo-tree
    :init
    (sk-defer-init (global-undo-tree-mode 1))
    :config
    (setq undo-tree-auto-save-history nil)
    (add-hook 'evil-local-mode-hook 'turn-on-undo-tree-mode)
    (evil-set-initial-state 'undo-tree-visualizer-mode 'emacs)
    (evil-leader/set-key
      "xu" 'undo-tree-visualize))

  (use-package wgrep
    :config
    (dolist (mode '(helm-git-grep-mode helm-ag-mode))
      (evil-leader/set-key-for-mode mode
        "ce" 'wgrep-finish-edit
        "ee" 'wgrep-change-to-wgrep-mode
        "cs" 'wgrep-save-all-buffers
        "ck" 'wgrep-abort-changes))
    (advice-add 'wgrep-change-to-wgrep-mode :after 'evil-normal-state))

  (use-package helm
    :bind (("M-y"     . helm-show-kill-ring)
           ("C-x C-r" . helm-recentf)
           :map helm-map
           ("<escape>". helm-keyboard-quit))
    :custom-face
    (helm-grep-finish ((default (:inherit helm-candidate-number)))
                      face-defface-spec)
    :init
    (evil-leader/set-key
      "i"  'helm-semantic-or-imenu
      "y"  'helm-show-kill-ring
      "ho" 'helm-occur
      "hr" 'helm-resume)
    :config
    (require 'helm-files)
    (setq helm-allow-mouse nil
          helm-always-two-windows nil
          helm-grep-file-path-style 'relative
          helm-imenu-execute-action-at-once-if-one nil
          helm-show-action-window-other-window nil
          helm-show-completion-display-function nil
          helm-split-window-default-side 'right)
    (advice-add 'helm-occur-goto-line :after
                (lambda (&rest _) (which-func-update))))

  (use-package helm-ag
    :commands (helm-ag-project-or-here helm-ag-here)
    :init
    (evil-leader/set-key
      "jp" 'helm-ag-here
      "jP" 'helm-ag-project-or-here)
    :config
    (require 'wgrep)
    (setq helm-ag-insert-at-point 'symbol
          helm-ag-base-command "ag --nocolor --nogroup --follow"
          helm-ag-use-grep-ignore-list t)
    (advice-add 'helm-ag--persistent-action :after
                (lambda (&rest _) (which-func-update)))
    (defun helm-ag-project-or-here ()
      (interactive)
      (helm-do-ag
       (sk-project-root)
       (thing-at-point 'symbol)))
    (defun helm-ag-here ()
      (interactive)
      (helm-do-ag default-directory)))

  (use-package helm-git-grep
    :init
    (evil-leader/set-key
      "p" 'helm-git-grep-at-point)
    :config
    (require 'wgrep)
    (setq helm-git-grep-candidate-number-limit 1000)
    (advice-add 'helm-git-grep-persistent-action :after
                (lambda (&rest _) (which-func-update))))

  (use-package projectile
    :commands (sk-add-known-project
               sk-remove-known-project)
    :hook (c-mode-common
           . (lambda () (local-set-key (kbd "M-o") 'sk-find-other-file)))
    :init
    (evil-leader/set-key
      "jc" 'compile
      "jd" 'projectile-find-dir
      "jk" 'projectile-kill-buffers
      "jb" 'projectile-switch-to-buffer
      "js" 'projectile-switch-project
      "jS" 'projectile-save-project-buffers)
    :config
    (setq projectile-completion-system 'ivy
          projectile-require-project-root nil
          projectile-switch-project-action 'projectile-dired
          projectile-track-known-projects-automatically nil)
    (projectile-load-known-projects)
    (defun sk-add-known-project (project-root)
      "Make .projectile file and add the project to known projects list."
      (interactive (list (read-directory-name "Add to known projects: ")))
      (let ((pfile (concat project-root ".projectile")))
        (unless (file-exists-p pfile)
          (write-region "" nil pfile)))
      (projectile-add-known-project project-root))
    (defalias 'sk-remove-known-project 'projectile-remove-known-project)
    (defalias 'projectile-project-root 'sk-project-root))

  (use-package markdown-mode
    :config
    (set-face-background 'markdown-line-break-face (face-background 'default))
    (set-face-underline 'markdown-line-break-face nil))

  (use-package markdown-toc)

  (use-package ox-reveal
    :demand t
    :after org
    :config
    (setq my-reveal-init-options '((progress . false)
                                   (slideNumber . "c/t")
                                   (transition . "none"))
          org-reveal-hlevel 2
          org-reveal-init-options
          (sk-alist-to-js-obj my-reveal-init-options t)
          org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"
          org-reveal-title-slide "<h2>%t</h2><h4>%a&nbsp(%e)</h4>"))

  (use-package magit
    :bind ("<f12>" . magit-status)
    :hook (with-editor-mode . evil-normal-state)
    :init
    (evil-leader/set-key
      "gs" 'magit-status
      "gd" 'magit-file-dispatch)
    :config
    (setq magit-log-section-commit-count 5)
    (evil-leader/set-key-minor-mode 'with-editor-mode
      "ck" 'with-editor-cancel)
    (bind-key "<escape>" 'transient-quit-one transient-map)
    (evil-make-overriding-map magit-blame-read-only-mode-map 'normal)
    (add-hook 'magit-blame-mode-hook 'evil-normalize-keymaps)
    (add-hook 'with-editor-mode-hook 'flyspell-mode)
    (remove-hook 'git-commit-setup-hook 'git-commit-setup-changelog-support)
    (defun sk-git-diff (&rest _)
      "Run git-diff"
      (interactive)
      (if (not (magit-staged-files))
          (message "No staged files")
        (call-process "git" nil (get-clear-buffer "*git-diff*") nil
                      "--no-pager" "diff" "--cached")
        (pop-to-buffer "*git-diff*")
        (goto-char (point-min))
        (diff-mode)))
    (defun sk-save-git-diff (diff-file)
      "Save git-diff"
      (interactive "F")
      (if (not (magit-staged-files))
          (message "No staged files")
        (call-process "git" nil `(:file ,diff-file) nil
                      "--no-pager" "diff" "--cached")))
    (if (transient--layout-member "v" 'magit-diff)
        (error "Layout conflict occured!")
      (transient-append-suffix 'magit-diff "p"
        '("v" "Run vc-diff" sk-save-git-diff)))
    (if (transient--layout-member "V" 'magit-diff)
        (error "Layout conflict occured!")
      (transient-append-suffix 'magit-diff "w"
        '("V" "Save vc-diff" sk-git-diff))))

  (use-package expand-region
    :bind (("C-="   . er/expand-region))
    :init
    (evil-leader/set-key
      "=" 'er/expand-region))

  (use-package smex)

  (use-package anzu
    :init
    (sk-defer-init (global-anzu-mode 1))
    :config
    (setq anzu-search-threshold 1000
          anzu-replace-threshold 1000))

  (use-package htmlize
    :demand t
    :after org)

  (use-package korean-holidays
    :init
    (setq calendar-holidays korean-holidays))

  (use-package fzf
    :bind (("C-c j h" . fzf-here))
    :init
    (evil-leader/set-key
      "jf" 'fzf-here)
    :config
    (setq fzf/args (concat fzf/args " --no-separator"))
    (defun fzf-here ()
      (interactive)
      (fzf--start default-directory #'fzf--action-find-file)))

  (use-package yasnippet
    :commands yas-expand company-yas-expand
    :config
    (let ((my-yasnippet-dir (expand-file-name "snippets/" emacs-etc-dir)))
      (add-to-list 'yas-snippet-dirs my-yasnippet-dir)
      (yas-load-directory my-yasnippet-dir t))
    (defun company-yas-expand ()
      (interactive)
      (when (company--active-p) (company-cancel))
      (yas-minor-mode-on)
      (let ((company-backends '(company-yasnippet)))
        (company-complete-common))))

  (use-package yasnippet-snippets
    :demand t
    :after yasnippet
    :config
    ;; Remove all unused snippets.
    (let* ((used
            '(bibtex-mode
              c++-mode c-lang-common c-mode cc-mode clojure-mode cmake-mode
              cpp-omnet-mode csharp-mode css-mode dart-mode elixir-mode
              emacs-lisp-mode fish-mode go-mode groovy-mode html-mode java-mode
              js-mode latex-mode lisp-mode lua-mode makefile-gmake-mode
              markdown-mode nxml-mode octave-mode org-mode prog-mode python-mode
              rst-mode rust-mode sh-mode snippet-mode sql-mode))
           (path (concat
                  (seq-find
                   (lambda (x) (string-match "yasnippet-snippets" x)) load-path)
                  "/snippets/"))
           (all (let ((default-directory path))
                  (directory-files path nil (rx bol (not ".")))))
           (unused (seq-filter (lambda (x) (not (member (intern x) used))) all))
           (to-remove (mapcar (lambda (x) (concat path x)) unused)))
      (when to-remove
        (apply #'call-process "rm" nil nil nil "-rf" to-remove))))

  (use-package ivy
    :bind (("C-x C-b"   . ivy-switch-buffer)
           :map minibuffer-inactive-mode-map
           ("<escape>" . abort-recursive-edit)
           :map ivy-minibuffer-map
           ("<escape>" . minibuffer-keyboard-quit)
           ("C-j"      . ivy-partial)
           ("TAB"      . ivy-alt-done))
    :init
    (evil-leader/set-key
      "b" 'ivy-switch-buffer)
    :config
    (setq ivy-height 15
          ivy-height-alist '((t . 15))
          ivy-wrap t
          ivy-fixed-height-minibuffer t
          ;; Don't use ^ as initial input
          ivy-initial-inputs-alist nil
          ;; disable magic slash on non-match
          ivy-magic-slash-non-match-action nil
          ;; prefix match first
          ivy-sort-matches-functions-alist
          '((t . ivy--prefix-sort)
            (ivy-switch-buffer . ivy-sort-function-buffer)))
    (ivy-mode 1)
    (when (display-graphic-p)
      (ivy-posframe-mode 1))
    (advice-add 'ivy-thing-at-point :around
                (lambda (old &rest r)
                  (if (> (- (pos-eol) (pos-bol)) 10000)
                      ""
                    (apply old r))))
    (defun sk-ivy-buffer-transformer (str)
      (let* ((nmax 35)
             (buf (get-buffer str))
             (buf-name (if (>= (length str) (+ nmax 2))
                           (concat (substring str 0 (- nmax 2)) "..")
                         str))
             (buf-len (length buf-name))
             (buf-dir (buffer-local-value 'default-directory buf))
             (buf-mode (buffer-local-value 'major-mode buf))
             (mode (capitalize
                    (string-remove-suffix "-mode" (symbol-name buf-mode))))
             (max-path-len
              (max 0 (min 100 (- (frame-width)
                                 (+ nmax 30)
                                 (max 0 (- buf-len nmax))))))
             (path-dir (abbreviate-file-name (or buf-dir "~/")))
             (path-file (when-let ((name (buffer-file-name buf)))
                          (abbreviate-file-name name)))
             (path-opt (or path-file
                           (when (or (string-match-p "shell" str)
                                     (equal buf-mode 'dired-mode))
                             path-dir)))
             (path-prefix (if (string-prefix-p "~" path-opt)
                              "~/"
                            "/"))
             (path-len (length path-opt))
             (path-mod (if (<= path-len max-path-len)
                           nil
                         (substring path-opt (- path-len max-path-len) path-len)))
             (path-margin (max 0 (- 20 (max 0 (- buf-len nmax)))))
             (path (if path-mod
                       (concat path-prefix
                               "…"
                               (replace-regexp-in-string
                                (rx bol (* (not (or "~" "/"))))
                                ""
                                path-mod))
                     path-opt))
             (form (format "%%-%ds  %%-%ds  %%s" nmax path-margin)))
        (format form buf-name mode (or path ""))))
    (ivy-configure 'ivy-switch-buffer
      :display-transformer-fn 'sk-ivy-buffer-transformer)
    (ivy-add-actions
     'projectile-switch-project
     '(("d" (lambda (p) (projectile-remove-known-project p)) "delete"))))

  (use-package ivy-yasnippet
    :init
    (evil-leader/set-key "/" 'ivy-yasnippet)
    :config
    (advice-add 'ivy-yasnippet :before 'yas-minor-mode-on)
    (advice-add 'ivy-yasnippet :after 'evil-insert-state))

  (use-package ivy-posframe
    :custom-face
    (ivy-posframe
     ((((background light)) :background "LightGray" :foreground "black")
      (((background dark)) :background "#282a36" :foreground "gray80")))
    (ivy-posframe-border ((t (:inherit ivy-posframe))) face-defface-spec)
    :config
    (setq ivy-truncate-lines nil
          ivy-posframe-border-width 20
          ivy-posframe-display-functions-alist
          '((complete-symbol . ivy-posframe-display-at-point)
            (ivy-yasnippet   . ivy-display-function-fallback)
            (swiper          . ivy-display-function-fallback)
            (t               . ivy-posframe-display-at-frame-center))))

  (use-package posframe)

  (use-package counsel
    :commands (counsel-find-dir-here
               counsel-fzf-here
               counsel--browse-history
               my-counsel-fzf
               my-counsel-fzf-here
               my-counsel-switch-shell-buffer)
    :bind (("M-x"     . counsel-M-x)
           ("C-x d"   . counsel-find-file)
           ("C-x C-f" . counsel-find-file)
           ("C-h b"   . counsel-descbinds)
           ("C-h v"   . counsel-describe-variable)
           ("C-h f"   . counsel-describe-function)
           ("<f5>"    . sk-compile)
           :map minibuffer-local-map
           ("C-r"     . counsel-minibuffer-history))
    :init
    (evil-leader/set-key
      "<SPC>" 'counsel-M-x
      "M-m"   'counsel-M-x
      "d"     'counsel-find-file
      "f"     'counsel-find-file
      "o"     'counsel-git
      "r"     'counsel-recentf
      "ha"    'counsel-describe-face
      "hb"    'counsel-descbinds
      "hv"    'counsel-describe-variable
      "hf"    'counsel-describe-function
      "nx"    'counsel-org-capture
      "jD"    'counsel-find-dir-here
      "jh"    'my-counsel-fzf-here
      "jo"    'my-counsel-fzf
      "sb"    'my-counsel-switch-shell-buffer)
    :config
    (setq sk-compile-history nil)
    (ivy-add-actions
     'counsel-shell-history
     '(("d" (lambda (x) (ring-remove comint-input-ring
                                     (ring-member comint-input-ring (car x))))
        "delete")))
    (ivy-add-actions
     'counsel-find-file
     '(("d" counsel-find-file-delete "delete")
       ("k" counsel-find-file-mkdir-action "mkdir")
       ("e" (lambda (_) (find-file ".dir-locals.el")) ".dir-locals")))
    (ivy-add-actions
     'ivy-switch-buffer
     '(("d" ivy--kill-buffer-action "delete")))

    (defun my-counsel-fzf ()
      "Fzf on project root."
      (interactive)
      (counsel-fzf nil (sk-project-root)))
    (defun my-counsel-fzf-here ()
      "Fzf on current directory."
      (interactive)
      (counsel-fzf nil default-directory))
    (defun my-counsel-switch-shell-buffer ()
      "Switch to a shell buffer, or create one."
      (interactive)
      (ivy-read "Shell buffer: "
                (append (counsel--buffers-with-mode #'shell-mode)
                        (counsel--buffers-with-mode #'eshell-mode))
                :action #'counsel--switch-to-shell
                :caller 'ivy-switch-buffer))

    (defun sk-compile-candidates ()
      (if-let ((sbin (find-file-in-tree default-directory ".sbin")))
          (let ((files-alist)
                (files (directory-files sbin t "\\.sh$"))
                (cand (alist-get sbin sk-compile-history nil nil #'equal)))
            (dolist (f files)
              (setq files-alist
                    (nconc files-alist
                           (list (cons (file-name-nondirectory f) f)))))
            (when cand
              (push (cons (file-name-nondirectory cand) cand) files-alist))
            (delete-dups files-alist))
        (user-error "Couldn't find .sbin folder")))

    (defun sk-compile-action (cmd-alist)
      (let* ((cmd (cdr cmd-alist))
             (dir (file-name-directory cmd)))
        (setf (alist-get dir sk-compile-history nil 'remove #'equal) cmd)
        (compile cmd)))

    (defun sk-compile (&optional dir)
      (interactive)
      (ivy-read "Compile script: "
                (sk-compile-candidates)
                :require-match t
                :action  #'sk-compile-action
                :keymap counsel-compile-map
                :caller 'sk-compile))

    (defun counsel-find-dir-here ()
      "Find all folders under current directory."
      (interactive)
      (ivy-read "Find dir: "
                (split-string
                 (shell-command-to-string "find * ! -path '*.*' -type d"))
                :action #'counsel-find-file-action
                :caller 'counsel-find-dir-here)))

  (use-package swiper)

  (use-package which-key
    :custom (which-key-dont-use-unicode t)
    :init
    (sk-defer-init (which-key-mode 1)))

  (use-package auctex)

  (use-package graphviz-dot-mode)

  (use-package org-roam
    :custom
    (org-roam-directory "~/Dropbox/org-roam")
    :init
    (evil-leader/set-key
      "nf" 'org-roam-node-find
      "ni" 'org-roam-node-insert)
    :config
    (org-roam-db-autosync-enable)
    (evil-leader/set-key-for-mode 'org-mode
      "nl" 'org-roam-buffer-toggle))

  (use-package xclip
    :init
    (when (and (not (display-graphic-p))
               (executable-find "xclip"))
      (xclip-mode 1)))
#+END_SRC
* Development packages - built-in
#+BEGIN_SRC emacs-lisp
  (use-package prog-mode
    :ensure nil
    :config
    (evil-leader/set-key (kbd "<DEL>") 'sk-hungry-backspace)
    (evil-define-key 'normal prog-mode-map
      "gd" 'xref-find-definitions
      "gp" 'xref-go-back
      "gr" 'xref-find-reference-here
      "g[" 'xref-go-back)
    (add-hook 'before-save-hook (lambda () (when (derived-mode-p 'prog-mode)
                                             (delete-trailing-whitespace))))
    (defun sk-hungry-backspace (n)
      (interactive "p")
      (call-interactively 'c-hungry-backspace)
      (when n (insert " "))))

  (use-package elec-pair
    :ensure nil
    :hook (prog-mode . electric-pair-mode)
    :config
    (defun electric-pair-delete-pair (arg &optional killp)
      "Custom pair-delete. Delete a closing braket in case of (|), delete a pair
  of inner braket in case of ((|))."
      (interactive "*p\nP")
      (if (memq (char-after (1+ (point))) '(?\) ?\" ?\] ?\} ?\$))
          (delete-char 1)
        (forward-char))
      (backward-delete-char-untabify arg killp)))

  (use-package octave
    :ensure nil
    :mode ("\\.m\\'" . octave-mode)
    :config
    (sk-switch-buffer-repl sk-octave-buffer-repl-toggle
      octave-mode inferior-octave-mode run-octave)
    (evil-leader/set-key-for-mode 'octave-mode
      "eb" 'octave-send-buffer
      "ee" 'octave-send-line
      "ef" 'octave-send-defun
      "er" 'octave-send-region))

  (use-package python
    :ensure nil
    :hook (python-mode . my-python-mode-hook)
    :bind (:map python-mode-map
            ("S-<left>"  . python-indent-shift-left)
            ("S-<right>" . python-indent-shift-right))
    :config
    (setq imenu-create-index-function 'python-imenu-create-index
          python-indent-guess-indent-offset-verbose nil)
    (defun my-python-mode-hook ()
      (setq-local tab-width 4)
      (eglot-ensure))
    (sk-switch-buffer-repl sk-python-buffer-repl-toggle
      python-mode inferior-python-mode
      (lambda ()
        (interactive)
        (pop-to-buffer (call-interactively 'run-python))))
    (defun my-python-shell-send-line-or-region (n)
      (interactive "p")
      (if (region-active-p)
          (call-interactively 'python-shell-send-region)
        (python-shell-send-region
         (line-beginning-position) (line-end-position n)))
      (setq deactivate-mark t))
    (defun my-python-help-repl ()
      (interactive)
      (move-beginning-of-line 1)
      (insert "help(")
      (move-end-of-line 1)
      (insert ")")
      (comint-send-input))
    (defun my-python-send-line-to-repl ()
      (interactive)
      (let ((process (python-shell-get-process-or-error)))
        (comint-send-string process (thing-at-point 'line)))
      (move-beginning-of-line 2))
    (evil-leader/set-key-for-mode 'python-mode
      "cd" 'python-describe-at-point
      "eb" 'python-shell-send-buffer
      "ee" 'my-python-shell-send-line-or-region
      "ef" 'python-shell-send-defun
      "er" 'python-shell-send-region
      "es" 'my-python-send-line-to-repl)
    (evil-define-key 'normal inferior-python-mode-map
      "gh" 'python-describe-at-point))

  (use-package xref
    :ensure nil
    :commands xref-find-reference-here
    :bind (:map xref--xref-buffer-mode-map
            ("<return>" . xref-quit-and-goto-xref)
            ("<RET>"    . xref-quit-and-goto-xref))
    :config
    (remove-hook 'xref-backend-functions #'etags--xref-backend)
    (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
    (defun xref-find-reference-here ()
      (interactive)
      (xref-find-references (thing-at-point 'symbol)))
    (advice-add 'xref--goto-char :after
                (lambda (&rest _) (which-func-update))))

  (use-package gdb-mi
    :ensure nil
    :init
    (advice-add 'gdb-setup-windows :after
                (lambda (&rest _)
                  (set-window-dedicated-p (selected-window) t)))
    :config
    (setq gdb-debuginfod-enable-setting nil)
    (gdb-many-windows t)
    (dolist (mm '(gdb-edit-locals-map-1
                  gdb-locals-mode-map
                  gdb-locals-watch-map
                  gdb-registers-mode-map
                  gdb-frames-mode-map
                  gdb-breakpoints-mode-map
                  gdb-threads-mode-map))
      (bind-keys :map (symbol-value mm)
                 ("j" . next-line)
                 ("k" . previous-line)))
    (evil-leader/set-key-minor-mode 'gdb-many-windows
      "ab" 'gud-break
      "ad" 'gud-remove
      "af" 'gud-finish
      "ai" 'gud-stempi
      "aj" 'gud-jump
      "al" 'gud-refresh
      "an" 'gud-next
      "ap" 'gud-print
      "ar" 'gud-cont
      "as" 'gud-step
      "at" 'gud-tbreak
      "au" 'gud-until
      "aw" 'gud-watch))

  (use-package make-mode
    :ensure nil
    :mode ("Makefile.*" . makefile-gmake-mode))

  (use-package which-func
    :ensure nil
    :hook (prog-mode . my-which-function-setup)
    :custom-face (which-func ((t :inherit font-lock-function-name-face))
                             face-defface-spec)
    :config
    (setq which-func-unknown "N/A"
          which-func-update-timer nil)
    (defun my-which-function-setup ()
      (unless (equal major-mode 'lisp-interaction-mode)
        (which-function-mode)
        (setq-local header-line-format 'which-func-format))))

  (use-package sh-script
    :ensure nil
    :hook (sh-mode . (lambda () (sh-electric-here-document-mode -1)))
    :mode (("\\.direnvrc\\'" . sh-mode)
           ("\\.envrc\\'" . sh-mode)
           ("\\.te\\'" . sh-mode)))

  (use-package elisp-mode
    :ensure nil
    :config
    (defun my-describe-symbol-at-point ()
      (interactive)
      (describe-symbol (symbol-at-point)))
    (dolist (mm '(emacs-lisp-mode lisp-interaction-mode))
      (evil-leader/set-key-for-mode mm
        "eb" 'eval-buffer
        "ee" 'eval-last-sexp
        "ef" 'eval-defun
        "em" 'pp-macroexpand-last-sexp
        "ep" 'pp-eval-last-sexp
        "er" 'eval-region))
    (evil-define-key 'normal emacs-lisp-mode-map
      "gh" 'my-describe-symbol-at-point)
    (evil-define-key 'normal lisp-interaction-mode-map
      "gh" 'my-describe-symbol-at-point))

  (use-package lisp-mode
    :ensure nil
    :custom (emacs-lisp-docstring-fill-column 80))

  (use-package cc-mode
    :ensure nil
    :mode (("\\.aidl\\'" . java-mode)
           ("\\.hal\\'" . c++-mode))
    :config
    (c-add-style "my-bsd" '("bsd"
                            (c-offsets-alist
                             (case-label . +)
                             (inextern-lang . 0))))
    (setq c-basic-offset tab-width
          c-default-style "my-bsd")
    (defvaralias 'c-basic-offset 'tab-width))

  (use-package compile
    :ensure nil
    :config
    (setq compilation-scroll-output t
          compilation-process-setup-function
          (lambda ()
            (setq-local scroll-conservatively 10000
                        scroll-step 1)))
    (evil-add-hjkl-bindings compilation-mode-map))

  (use-package scheme
    :ensure nil
    :config
    (setq scheme-program-name "chicken-csi")
    (require 'cmuscheme)
    (sk-switch-buffer-repl sk-scheme-buffer-repl-toggle
      scheme-mode inferior-scheme-mode run-scheme)
    (sk-define-lisp-eval sk-scheme-eval scheme-send-region)
    (defun scheme-send-buffer ()
      (interactive)
      (scheme-send-region (point-min) (point-max)))
    (evil-define-key 'normal inferior-scheme-mode
      (kbd "<return>") 'my-comint-return)
    (evil-leader/set-key-for-mode 'scheme-mode
      "eb" 'scheme-send-buffer
      "ee" 'sk-scheme-eval
      "ef" 'scheme-send-definition
      "er" 'scheme-send-region))

  (use-package project
    :ensure nil
    :config
    (setq project-find-functions '(sk-project-root))
    (cl-defmethod project-root (&rest r)
      (sk-project-root)))

  (use-package ielm
    :ensure nil
    :config
    (evil-define-key 'insert inferior-emacs-lisp-mode-map
      (kbd "<return>") 'ielm-return))
#+END_SRC
* Development packages - external
#+BEGIN_SRC emacs-lisp
  (use-package ggtags
    :hook ((c-mode-common asm-mode) . ggtags-mode)
    :commands (sk-create-ggtags sk-set-c-project)
    :config
    (defun sk-create-ggtags (root)
      (interactive "DRoot directory: ")
      (let ((default-directory root))
        (async-shell-command-callback
         "gtags"
         (lambda ()
           (clrhash ggtags-projects)
           (message (concat "GTAGS generated in " default-directory))))))
    (defun sk-set-c-project (root)
      (interactive "DRoot directory: ")
      (let ((default-directory root))
        (sk-create-ggtags root)
        (sk-clang-complete-make)))
    (advice-add 'move-to-column :around
                (lambda (func column &rest r)
                  (let ((col (max column 0)))
                    (apply func col r)))))

  (use-package irony
    :hook ((c++-mode c-mode objc-mode) . irony-mode)
    :config
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
    (setq irony-cdb-compilation-databases
          '(irony-cdb-clang-complete irony-cdb-libclang)))

  (use-package paredit
    :hook ((emacs-lisp-mode
            clojure-mode cider-repl-mode janet-mode inf-janet-mode
            lisp-mode scheme-mode inferior-emacs-lisp-mode)
           . enable-paredit-mode)
    :bind (:map paredit-mode-map
            ("M-b" . paredit-backward)
            ("M-f" . paredit-forward)
            ("C-c <left>"  . paredit-forward-barf-sexp)
            ("C-c <right>" . paredit-forward-slurp-sexp))
    :commands (sk-janet-mode-hook)
    :config
    (defun evil-paredit-kill (&rest _)
      (interactive)
      (let ((evil-execute-in-emacs-state-buffer t)
            (pos (point)))
        (when (equal pos (1- (line-end-position)))
          (goto-char (1+ pos)))
        (call-interactively 'paredit-kill)))
    (defun janet-insert-semicolon ()
      (interactive)
      (insert-and-inherit ?\;))
    (defun sk-janet-mode-hook ()
      (setq-local paredit-comment-prefix-toplevel "### "
                  paredit-comment-prefix-code "## "
                  paredit-comment-prefix-margin "#")
      (evil-local-set-key 'insert ";" 'janet-insert-semicolon))
    (evil-leader/set-key-minor-mode 'paredit-mode
      "k"  'evil-paredit-kill)
    (evil-define-key 'insert paredit-mode-map
      (kbd "C-k") 'paredit-kill))

  (use-package clojure-mode
    :config
    (require 'cider)
    (sk-define-lisp-eval sk-cider-eval cider-eval-region)
    (sk-C-c-map-to-leader-c-map 'clojure-mode cider-mode-map)
    (sk-C-c-map-to-leader-c-map 'clojurescript-mode cider-mode-map)
    (dolist (m (list clojure-mode-map clojurescript-mode-map))
      (evil-define-key* 'normal m
        "gd"  'cider-find-dwim
        "gp"  'cider-pop-back
        "ghc" 'cider-clojuredocs
        "ghe" 'cider-apropos-documentation-select
        "ghh" 'cider-doc
        "ghj" 'cider-javadoc
        "ghw" 'cider-clojuredocs-web))
    (dolist (m '(clojure-mode clojurescript-mode))
      (evil-leader/set-key-for-mode m
        "z"   'cider-switch-to-repl-buffer
        "cj"  'cider
        "eb"  'cider-eval-buffer
        "ee"  'sk-cider-eval
        "ef"  'cider-eval-defun-at-point
        "er"  'cider-eval-region
        "epc" 'cider-pprint-eval-last-sexp-to-comment
        "epf" 'cider-pprint-eval-defun-at-point
        "epp" 'cider-pprint-eval-last-sexp
        "esb" 'cider-browse-ns
        "esf" 'cider-find-ns
        "ess" 'cider-repl-set-ns
        "eta" 'cider-test-rerun-test
        "etn" 'cider-test-run-ns-tests
        "etp" 'cider-test-run-project-tests
        "etr" 'cider-test-rerun-failed-tests
        "ett" 'cider-test-run-test
        "evv" 'cider-eval-sexp-at-point
        "evx" 'cider-eval-last-sexp-and-replace)))

  (use-package cider
    :config
    (evil-set-initial-state 'cider-auto-test-mode           'emacs)
    (evil-set-initial-state 'cider-browse-ns-mode           'emacs)
    (evil-set-initial-state 'cider-browse-spec-example-mode 'emacs)
    (evil-set-initial-state 'cider-browse-spec-mode         'emacs)
    (evil-set-initial-state 'cider-browse-spec-view-mode    'emacs)
    (evil-set-initial-state 'cider-docview-mode             'emacs)
    (evil-set-initial-state 'cider-enlighten-mode           'emacs)
    (evil-set-initial-state 'cider-inspector-mode           'emacs)
    (evil-set-initial-state 'cider-repl-history-mode        'emacs)
    (evil-set-initial-state 'cider-stacktrace-mode          'emacs)
    (evil-set-initial-state 'cider-test-report-mode         'emacs)
    (evil-define-key 'normal cider-repl-mode-map
      "gd"  'cider-find-dwim
      "gp"  'cider-pop-back
      "ghc" 'cider-clojuredocs
      "ghe" 'cider-apropos-documentation-select
      "ghh" 'cider-doc
      "ghj" 'cider-javadoc
      "ghw" 'cider-clojuredocs-web
      (kbd "RET") 'my-comint-return)
    (evil-define-minor-mode-key 'normal 'cider-popup-buffer-mode
      "q" 'quit-window)
    (evil-leader/set-key-for-mode 'cider-repl-mode
      "z"  'cider-switch-to-last-clojure-buffer
      "cs" 'cider-repl-set-ns))

  (use-package sly
    :init
    (setq inferior-lisp-program "sbcl")
    :config
    (setq sly-mrepl-history-file-name
          (expand-file-name ".sly-mrepl-history" user-emacs-directory))
    (evil-set-initial-state 'sly-db-mode                'emacs)
    (evil-set-initial-state 'sly-inspector-mode         'emacs)
    (evil-set-initial-state 'sly-stickers--replay-mode  'emacs)
    (evil-set-initial-state 'sly-xref-mode              'emacs)
    (evil-set-initial-state 'sly-xref-mode              'emacs)
    (sk-define-lisp-eval sk-sly-eval sly-eval-region)
    (defun my-sly-mrepl ()
      (interactive)
      (call-interactively (if (sly-connected-p) 'sly-mrepl 'sly)))
    (sk-C-c-map-to-leader-c-map 'lisp-mode sly-mode-map)
    (evil-leader/set-key-minor-mode 'sly-mode
      "z"   'my-sly-mrepl
      "cb"  'sly-compile-file
      "cf"  'sly-compile-defun
      "cr"  'sly-compile-region
      "eb"  'sly-eval-buffer
      "ee"  'sk-sly-eval
      "ef"  'sly-eval-defun
      "er"  'sly-eval-region
      "es"  'sly-mrepl-sync
      "csd" 'sly-stickers-clear-defun-stickers
      "csk" 'sly-stickers-clear-buffer-stickers
      "csr" 'sly-stickers-replay
      "css" 'sly-stickers-dwim
      "csF" 'sly-stickers-forget)
    (evil-leader/set-key-for-mode 'sly-mrepl-mode
      "l"  'my-comint-history
      "z"  'sly-switch-to-most-recent
      "es" 'sly-mrepl-set-package)
    (evil-define-key 'normal sly-mode-map
      "gd" 'sly-edit-definition
      "gh" 'sly-documentation
      "gp" 'sly-pop-find-definition-stack
      "gr" 'sly-edit-uses)
    (evil-define-key 'normal sly-mrepl-mode-map
      "gj" 'sly-mrepl-next-prompt
      "gk" 'sly-mrepl-previous-prompt
      "gd" 'sly-edit-definition
      "gp" 'sly-pop-find-definition-stack
      "gr" 'sly-edit-uses
      (kbd "RET") 'my-comint-return)
    (evil-define-minor-mode-key 'normal 'sly-popup-buffer-mode
      "q"  'quit-window))

  (use-package web-mode
    :mode (("\\.html\\'"    . web-mode)
           ("\\.ejs\\'"     . web-mode)
           ("\\.svelte\\'"  . web-mode)
           ("\\.vue\\'"     . web-mode))
    :config
    (setq web-mode-style-padding 0
          web-mode-script-padding 0
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-enable-current-element-highlight t)
    (sk-C-c-map-to-leader-c-map 'web-mode web-mode-map))

  (use-package js2-mode
    :mode (("\\.js\\'" . js2-mode)
           ("\\.jsx\\'" . js2-jsx-mode))
    :hook (js2-mode . eglot-ensure)
    :config
    (setq js2-basic-offset 2)
    (add-hook 'js2-mode-hook 'js2-imenu-extras-mode))

  (use-package emmet-mode
    :hook ((web-mode js2-mode css-mode) . emmet-mode))

  (use-package go-mode
    :hook (go-mode . eglot-ensure)
    :config
    (setq gofmt-command "goimports")
    (defun my-go-code-hook ()
      (make-local-variable 'before-save-hook)
      (add-hook 'before-save-hook 'gofmt-before-save)
      (setq-local compile-command
                  "go build -v && go test -v && go vet"))
    (add-hook 'go-mode-hook 'my-go-code-hook))

  (use-package format-all)

  (use-package plantuml-mode
    :mode ("\\.puml\\'" . plantuml-mode)
    :bind (:map plantuml-mode-map
            ("C-c C-e" . plantuml-make-output))
    :config
    (setq plantuml-default-exec-mode 'jar
          plantuml-indent-level 4
          plantuml-jar-path "/usr/share/java/plantuml/plantuml.jar")
    (evil-leader/set-key-for-mode 'plantuml-mode
      "ce" 'plantuml-make-output)
    (defun plantuml-make-output ()
      (interactive)
      (set-process-sentinel
       (start-process "plantuml" nil "plantuml" (buffer-file-name))
       (lambda (&rest _) (message "PlantUML process is done")))))

  (use-package haskell-mode
    :hook (haskell-mode . my-haskell-mode-hook)
    :bind (:map haskell-mode-map
            ("M-j" . my-haskell-newline-and-indent-or-guard))
    :config
    (defun my-haskell-mode-hook ()
      (setq-local tab-width 4))
    (defun my-haskell-newline-and-indent-or-guard ()
      (interactive)
      (if (nth 4 (syntax-ppss))         ; if in comment area
          (default-indent-new-line)
        (let ((ch (save-excursion
                    (back-to-indentation)
                    (char-after (point)))))
          (haskell-indentation-newline-and-indent)
          (when (equal ch ?|)
            (insert "| ")))))
    (defun my-haskell-prompt-history ()
      (interactive)
      (my-comint-history 'haskell-interactive-mode-history))
    (defun my-haskell-prompt-kill-whole-line ()
      (interactive)
      (haskell-interactive-mode-bol)
      (execute-kbd-macro "C"))
    (defun my-haskell-prompt-prev (&optional arg)
      (interactive "^p")
      (dotimes (_ (or arg 1))
        (haskell-interactive-mode-prompt-previous)))
    (defun my-haskell-prompt-next (&optional arg)
      (interactive "^p")
      (dotimes (_ (or arg 1))
        (haskell-interactive-mode-prompt-next)))
    (evil-define-key 'normal haskell-mode-map
      "]e" 'haskell-goto-next-error
      "[e" 'haskell-goto-prev-error
      "gd" 'haskell-mode-jump-to-def
      "gh" 'haskell-process-do-info)
    (evil-define-key 'normal haskell-interactive-mode-map
      "0"  'haskell-interactive-mode-bol
      "S"  'my-haskell-prompt-kill-whole-line
      "gd" 'haskell-mode-jump-to-def
      "gj" 'my-haskell-prompt-next
      "gk" 'my-haskell-prompt-prev
      (kbd "RET") 'my-comint-return)
    (evil-leader/set-key-for-mode 'haskell-mode
      "z"  'haskell-interactive-switch
      "ef" 'haskell-process-load-file)
    (evil-leader/set-key-for-mode 'haskell-interactive-mode
      "l" 'my-haskell-prompt-history
      "z" 'haskell-interactive-switch-back))

  (use-package restclient
    :mode ("\\.rest\\'" . restclient-mode)
    :hook (restclient-mode . my-restclient-mode-hook)
    :config
    (defvar restclient-imenu-generic-expression
      '(("GET" "^\\(GET\\)\\(.*\\)" 2)
        ("PUT" "^\\(PUT\\)\\(.*\\)" 2)
        ("POST" "^\\(POST\\)\\(.*\\)" 2)
        ("DELETE" "^\\(DELETE\\)\\(.*\\)" 2)
        ("Variables" "^:\\(.*\\)" 1)))
    (defun my-restclient-mode-hook ()
      (setq imenu-generic-expression restclient-imenu-generic-expression
            imenu-case-fold-search nil))
    (evil-leader/set-key-for-mode 'restclient-mode
      "ec" 'restclient-http-send-current-raw
      "ee" 'restclient-http-send-current-stay-in-window)
    (evil-define-key 'motion restclient-mode-map
      "gj" 'restclient-jump-next
      "gk" 'restclient-jump-prev)
    (evil-define-minor-mode-key 'normal 'restclient-response-mode
      "q"  'quit-window))

  (use-package eglot
    :config
    (require 'projectile)
    (setq eglot-autoshutdown t
          eglot-events-buffer-size 0
          eglot-ignored-server-capabilities
          '(:documentHighlightProvider
            :documentSymbolProvider
            :inlayHintProvider
            :signatureHelpProvider)
          eglot-server-programs
          (append
           `((python-mode
              . (eglot-pyright . ("pyright-langserver" "--stdio"))))
           eglot-server-programs)
          eglot-sync-connect 0)
    (fset #'jsonrpc--log-event #'ignore)
    (defun my-find-python-project-root ()
      (find-file-in-tree default-directory '("setup.py" "requirements.txt") t))
    (defclass eglot-pyright (eglot-lsp-server) ()
      :documentation "MS pyright Language Server.")
    (cl-defmethod eglot-client-capabilities ((server eglot-pyright))
      "EGLOT LSP client supports for pyright."
      `(:workspace
        (:didChangeWatchedFiles
         (:dynamicRegistration
          ,(if (my-find-python-project-root)
               t
             :json-false)))))
    (evil-leader/set-key-minor-mode 'eglot--managed-mode
      "ex" 'eglot-code-action-quickfix)
    (evil-define-minor-mode-key 'normal 'eglot--managed-mode
      "gh" 'eldoc-doc-buffer))

  (use-package rust-mode
    :hook (rust-mode . eglot-ensure)
    :config
    (evil-leader/set-key-for-mode 'rust-mode
      "ee" 'rust-compile
      "er" 'rust-run
      "et" 'rust-test-nocapture)
    (defun rust-test-nocapture ()
      "Test using `cargo test -- --nocapture`"
      (interactive)
      (rust--compile "%s test -- --nocapture" rust-cargo-bin)))

  (use-package lua-mode)

  (use-package cmake-mode
    :config
    (setq cmake-tab-width 4))

  (use-package gnuplot)

  (use-package yaml-mode)

  (use-package eros
    :init (sk-defer-init (eros-mode 1)))

  (use-package dts-mode)

  (use-package inf-elixir
    :commands (run-iex inf-elixir-send-line-or-region
                       inf-elixir-compile-and-load-module)
    :config
    (defun run-iex ()
      (interactive)
      (if (inf-elixir--find-project-root)
          (call-interactively 'inf-elixir-project)
        (call-interactively 'inf-elixir)))
    (defun inf-elixir--send (cmd)
      "Re-write function not to pop iex buffer."
      (when-let ((buf (inf-elixir--determine-repl-buf)))
        (with-current-buffer buf
          (comint-send-string buf (concat cmd "\n")))))
    (defun inf-elixir-send-line-or-region (n)
      (interactive "p")
      (if (region-active-p)
          (call-interactively 'inf-elixir-send-region)
        (inf-elixir--send
         (buffer-substring
          (line-beginning-position) (line-end-position n))))
      (setq deactivate-mark t))
    (defun inf-elixir-compile-and-load-module ()
      "Compile and load the module."
      (interactive)
      (if-let* ((buffer (inf-elixir--determine-repl-buf))
                (module (substring-no-properties
                         (nth 0 (inf-elixir--matches-in-buffer
                                 "defmodule \\([A-Z][A-Za-z0-9\._]+\\)\s+"))))
                (compile-file
                 (replace-regexp-in-string
                  (rx "\\" (group anything))
                  "\\1"
                  (format "c \"%s\" \n" buffer-file-name)))
                (load-module (format "r %s\n" module)))
          (with-current-buffer buffer
            (comint-send-string buffer compile-file)
            (comint-send-string buffer load-module)))))

  (use-package elixir-mode
    :config
    (sk-switch-buffer-repl sk-elixir-buffer-iex-toggle
      elixir-mode inf-elixir-mode run-iex)
    (evil-leader/set-key-for-mode 'elixir-mode
      "eb" 'inf-elixir-send-buffer
      "ee" 'inf-elixir-send-line-or-region
      "em" 'inf-elixir-compile-and-load-module
      "er" 'inf-elixir-send-region))

  (use-package janet-mode
    :config
    (require 'inf-janet)
    (sk-switch-buffer-repl sk-janet-buffer-repl-toggle
      janet-mode inf-janet-mode inf-janet)
    (evil-leader/set-key-for-mode 'janet-mode
      "eb" 'inf-janet-eval-buffer
      "ee" 'sk-janet-eval
      "ef" 'inf-janet-eval-defun
      "er" 'inf-janet-eval-region)
    (evil-define-key 'normal janet-mode-map
      "gh" 'sk-janet-describe-symbol)
    (add-hook 'janet-mode-hook 'sk-janet-mode-hook))

  (use-package inf-janet
    :ensure nil
    :load-path (lambda () (expand-file-name "inf-janet/" emacs-etc-dir))
    :commands (sk-janet-eval sk-janet-describe-symbol)
    :config
    (sk-define-lisp-eval sk-janet-eval inf-janet-eval-region)
    (add-hook 'inf-janet-mode-hook 'sk-janet-mode-hook)
    (defun sk-janet-describe-symbol ()
      (interactive)
      (when-let ((sym (symbol-at-point)))
        (inf-janet-eval-string (format "(doc %s)" sym))
        (display-buffer inf-janet-buffer)))
    (evil-define-key 'normal inf-janet-mode-map
      "gh" 'sk-janet-describe-symbol))

  (use-package dart-mode
    :hook (dart-mode . eglot-ensure))
#+END_SRC
* End
** Provide a feature
Make =config.el= available to load by =require=.

#+BEGIN_SRC emacs-lisp
  (provide 'config)

  ;;; config.el ends here
#+END_SRC
