#+TITLE: SK Emacs configuration
#+AUTHOR: SeungKi Kim
#+EMAIL: tttuuu888@gmail.com
#+PROPERTY: header-args :tangle yes

* About
This is my personal Emacs setting.

=init.el= will generate =config.el= from =config.org= and then will load
=config.el=.

=file-name-handler-alist= will be set to =nil= and =gc-cons-threshold= will be
set to =most-positive-fixnum= in order to boost up the speed during the boot
time.

All the other settings will be located in =config.org=.
* Initial settings
** Commentary
This comment will be added on the top of =config.el=.

#+BEGIN_SRC emacs-lisp
  ;;; config.el --- generated from config.org -*- lexical-binding: t -*-
  ;;
  ;;; Code:
#+END_SRC

** Emacs -init
If Emacs is executed with an =-init= argument, =parallel install= process is
performed.

#+BEGIN_SRC emacs-lisp
  (when (member "-init" command-line-args)
    (delete "-init" command-line-args)
    (require 'pinstall "~/.emacs.d/etc/pinstall.el")
    (pinstall-init))
#+END_SRC

** Package initialize
Process =package-initialize= before setting =package-archives= to speed up Emacs
start up time. So =package-read-all-archive-contents= should be called after
start up to use of updated =package-archives=.

#+BEGIN_SRC emacs-lisp
  (unless package--activated
    (package-initialize))

  (setq package-archives
        '(("gnu"   . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

** User-emacs-directory setting
From this point, =user-emacs-directory= is set to =~/.emacs.d/.local/= so that
all package local files would be hidden under the path.

=emacs-config-dir= would be used instead of =user-emacs-directory=.

#+BEGIN_SRC emacs-lisp
  (defvar emacs-config-dir user-emacs-directory)
  (setq user-emacs-directory (expand-file-name ".local/" emacs-config-dir))
  (unless (file-exists-p user-emacs-directory)
    (make-directory-internal user-emacs-directory))
#+END_SRC

Set =emacs-etc-dir= to indicate a folder containing extra files.

#+BEGIN_SRC emacs-lisp
  (defvar emacs-etc-dir (expand-file-name "etc/" emacs-config-dir))
  (unless (file-exists-p emacs-etc-dir)
    (make-directory-internal emacs-etc-dir))
#+END_SRC

** Custom file
=custom.el= will be saved under =~/.emacs.d/.local/= but will not be used.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Instead of using =custom.el=, insert the contents of the file directly here.

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(auth-source-save-behavior nil)
   '(backup-directory-alist '((".*" . "/tmp/")))
   '(blink-cursor-mode nil)
   '(browse-url-browser-function 'browse-url-chrome)
   '(completion-styles '(basic partial-completion emacs22 initials))
   '(css-indent-offset 2)
   '(fill-column 80)
   '(font-use-system-font t)
   '(indent-tabs-mode nil)
   '(inhibit-startup-screen t)
   '(make-backup-files nil)
   '(mouse-wheel-progressive-speed nil)
   '(password-cache-expiry 900)
   '(safe-local-variable-values '((tab-width . 2)))
   '(send-mail-function 'smtpmail-send-it)
   '(size-indication-mode t)
   '(split-height-threshold nil)
   '(split-width-threshold 140)
   '(tab-always-indent 'complete)
   '(tab-width 4)
   '(use-file-dialog nil))
#+END_SRC

** User information
If =USER_FULL_NAME= and =USER_MAIL_ADDRESS= environment variables exist, update
=user_full_name= and =user_mail_address= variables.

#+BEGIN_SRC emacs-lisp
  (let ((name (getenv "USER_FULL_NAME"))
        (mail (getenv "USER_MAIL_ADDRESS")))
    (when name (setq user-full-name name))
    (when mail (setq user-mail-address mail)))
#+END_SRC

** Color setting
Simple color setting function which has 'dark' and 'light' theme.

#+BEGIN_SRC emacs-lisp
  (defun my-theme-setting (&optional light-theme)
    (let ((fg-color (if light-theme "Black"  "Gray80"))
          (bg-color (if light-theme "Ivory2" "Gray23")))
      (set-face-attribute 'default nil
                          :foreground fg-color :background bg-color)
      (set-face-attribute 'fringe nil
                          :background bg-color)
      (set-face-attribute 'header-line nil
                          :background bg-color :underline nil)
      (set-face-attribute 'vertical-border nil
                          :background bg-color)))
  (defun sk-light-theme () (interactive) (my-theme-setting t))
  (defun sk-dark-theme  () (interactive) (my-theme-setting))
#+END_SRC

Enable dark theme.

#+BEGIN_SRC emacs-lisp
  (my-theme-setting)
#+END_SRC
** Font setting
#+BEGIN_SRC emacs-lisp
  (defvar sk-font "D2Coding")

  (when (display-graphic-p)
    (set-fontset-font t 'unicode "Unifont")
    (set-fontset-font t '(#x10000 . #xFFFFF) "Unifont Upper")
    (set-fontset-font t 'hangul sk-font)
    (set-face-attribute 'fixed-pitch nil :family sk-font))
#+END_SRC
** Yes-or-no -> y-or-n
Use =y-or-n= instead of =yes-or-no=.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** M-up, M-down, M-left, and M-right keys.
M-up,down,left,right keys for moving to windows.

#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings 'meta)
#+END_SRC

** SK-utils
Various useful functions.

#+BEGIN_SRC emacs-lisp
  (defun sharp-ifdef-insert (start end pre)
    (save-excursion
      (goto-char (1- end))
      (end-of-line)
      (unless (equal (point) (line-beginning-position))
        (insert "\n"))
      (insert "#endif")
      (goto-char start)
      (beginning-of-line)
      (insert pre "\n")))

  (defun izero-insert (start end)
    "Wrap a region with #if 0 and #endif."
    (interactive "r")
    (sharp-ifdef-insert start end "#if 0"))

  (defun idef-insert (start end in)
    "Wrap a region with #ifdef and #endif."
    (interactive "r\nsDefine : ")
    (sharp-ifdef-insert start end (concat "#ifdef " in)))

  (defun find-file-in-tree (dir filename &optional return-include-file)
    "Find file FILENAME up to home or root folder."
    (let ((file (expand-file-name filename dir))
          (parent (unless (or (equal "~/" dir) (equal "/" dir))
                    (file-name-directory (directory-file-name dir)))))
      (cond ((file-exists-p file)
             (when (file-directory-p file)
               (setq file (file-name-as-directory file)))
             (if return-include-file file dir))
            (parent (find-file-in-tree parent filename return-include-file))
            (t nil))))

  (defun sk-sbin-dired ()
    (interactive)
    (let ((sbin (find-file-in-tree default-directory ".sbin" t)))
      (if sbin
          (dired sbin)
        (message "Folder .sbin not found."))))

  (defun sk-clang-complete-make ()
    "Generate .clang_complete file."
    (interactive)
    (let ((file "./.clang_complete")
          (includes (shell-command-to-string
                     "find -type f -name '*.h' -printf '-I%h\n' | sort -u")))
      (write-region includes nil file)))

  (defun insert-date ()
    "Insert date at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %A")))

  (defun insert-date-and-time ()
    "Insert date and time at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %a %p %l:%M")))

  (defun nuke-all-buffers ()
    "kill all buffers, leaving *scratch* only"
    (interactive)
    (mapc #'kill-buffer (buffer-list))
    (delete-other-windows))

  (defun hide-ctrl-M ()
    "Hides the disturbing '^M' showing up in files containing mixed UNIX and DOS
  line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  (defun move-line (n)
    "Move the current line up or down by N lines."
    (interactive "p")
    (let ((col (current-column))
          (txt (delete-and-extract-region (line-beginning-position)
                                          (line-beginning-position 2))))
      (forward-line n)
      (insert txt)
      ;; restore point to original column in moved line
      (forward-line -1)
      (forward-char col)))

  (defun transpose-windows ()
    "Swap positions of 2 windows."
    (interactive)
    (let ((buffer1 (window-buffer (selected-window)))
          (buffer2 (window-buffer (select-window (next-window)))))
      (switch-to-buffer buffer1)
      (switch-to-buffer-other-window buffer2)))

  (defun buffer-save-or-load (num &optional restore)
    (if restore
        (progn
          (jump-to-register num)
          (message "Windows are Restored by F%d" num))
      (window-configuration-to-register num)
      (message "Windows are saved to F%d" num)))

  (defun tmux-running-p ()
    "Check if tmux is currently running or not."
    (zerop (call-process "tmux" nil nil nil "has-session")))

  (defun tmux-new-pane-here ()
    "Open tmux pane of the current path."
    (interactive)
    (if (not (tmux-running-p))
        (message "Tmux is not running!")
      (call-process "tmux" nil nil nil "new-window")
      (message "New tmux pane is opened.")))

  (defun get-week-form (&optional offset date)
    "Create a string with the week number and the date range of the week. OFFSET
  is a integer number indicating offset from today. DATE is a list in a form
  of (month day year). OFFSET is ignored if DATE is provided."
    (require 'cal-iso)
    (let* ((d (calendar-absolute-from-gregorian
               (or date (calendar-current-date offset))))
           (day (% d 7))
           (week-number (car (calendar-iso-from-absolute d)))
           (monday (calendar-gregorian-from-absolute (- d (- day 1))))
           (friday (calendar-gregorian-from-absolute (+ d (- 5 day))))
           (month-of-monday (format "%2d월 " (car monday)))
           (month-of-friday (if (equal (car monday) (car friday))
                                ""
                              (format "%2d월 " (car friday))))
           (start (format "%s%2d일" month-of-monday (nth 1 monday)))
           (end (format "%s%2d일" month-of-friday (nth 1 friday))))
      (format "%2d주차  %s ~ %s" week-number start end)))

  (defun sk-insert-current-week-form ()
    (interactive)
    (insert (get-week-form)))

  (defun sk-insert-next-week-form ()
    (interactive)
    (insert (get-week-form 7)))

  (defmacro sk-switch-buffer-repl (name mode repl run-repl &optional nobind)
    "Create NAME function which switch between a file of MODE and a REPL. Open
  REPL with RUN-REPL function if REPL is not yet opened. Evil-Leader z binding
  will be added to toggle MODE and REPL buffer unless NOBIND is not nil."
    (declare (indent defun))
    `(let ((last-mode "")
           (last-repl ""))
       (unless ,nobind
         (evil-leader/set-key-for-mode ',mode "z" ',name)
         (evil-leader/set-key-for-mode ',repl "z" ',name))
       (defun ,name ()
         (interactive)
         (cond ((equal major-mode ',mode)
                (setq last-mode (buffer-name))
                (if (get-buffer last-repl)
                    (pop-to-buffer last-repl)
                  (call-interactively ',run-repl)))
               ((equal major-mode ',repl)
                (setq last-repl (buffer-name))
                (when (get-buffer last-mode)
                  (pop-to-buffer last-mode)))
               (t nil)))))

  (let ((cnt 0))
    (defmacro sk-defer-init (&rest body)
      "Defer BODY until the very first command after init."
      (declare (indent defun))
      (let ((name (intern (format "sk-defer-init-%d" (setq cnt (1+ cnt))))))
        `(progn
           (defun ,name ()
             ,@body
             (remove-hook 'pre-command-hook ',name)
             (unintern ',name nil))
           (add-hook 'pre-command-hook #',name)))))

  (defun git-tracked-file-p (&optional file-name)
    (let ((file (or file-name buffer-file-name)))
      (and file
           (file-exists-p file)
           (zerop (process-file "git" nil nil nil
                                "ls-files" "--error-unmatch"
                                (file-name-nondirectory file))))))

  (defun git-branch-of-file (file)
    (when (git-tracked-file-p file)
      (let* ((default-directory (file-name-directory file))
             (branch (shell-command-to-string "git branch --show-current"))
             (hash (when (equal branch "")
                     (shell-command-to-string "git rev-parse HEAD"))))
        (if hash
            (substring hash 0 7)
          (substring branch 0 (1- (length branch)))))))

  (defun sk-C-c-map-to-leader-c-map (mode mode-map)
    "Change C-c ... key map to <leader> c... key map"
    (let* ((ret nil)
           (target (alist-get ?\C-c mode-map))
           (cm (number-sequence ?\C-a ?\C-z))
           (ks (append cm (number-sequence ?A ?Z) (number-sequence ?a ?z))))
      (defun ctrl-map-search (elt pre)
        (if (symbolp elt)
            (setq ret (append ret (list (cons pre elt))))
          (dolist (k ks)
            (let ((nelt (alist-get k elt))
                  (npre (if (member k cm) (+ k 96) k)))
              (when nelt
                (ctrl-map-search nelt (append pre (list npre))))))))
      (ctrl-map-search target (list ?\c))
      (dolist (e ret)
        (let ((key (mapconcat 'single-key-description (car e) "")))
          (evil-leader/set-key-for-mode mode key (cdr e))))))

  (defun sk-project-root (&optional dir)
    (let ((dir (or dir default-directory))
          (found nil)
          (checks '(".git" ".projectile")))
      (cl-loop for c in checks
               until found
               do (when-let ((root (find-file-in-tree dir c)))
                    (setq found root)))
      (file-truename (or found dir))))

  (defun sk-set-dir-to-project ()
    "Set current directory to the project root directory."
    (interactive)
    (unless (file-exists-p ".projectile")
      (write-region "" nil ".projectile"))
    (message (concat default-directory " is set to the project root directory.")))

  (defun my-find-file-in-git-project (regex root)
    (when (zerop (shell-command "git -C . rev-parse"))
      (let* ((default-directory root)
             (ret (shell-command-to-string
                   (concat "git ls-files|grep -E '" regex "'"))))
        (unless (string= ret "")
          (split-string (substring ret 0 (1- (length ret))))))))

  (defun my-find-other-file-git ()
    "Switch betwen .c|cpp and .h files in git project."
    (if-let* ((file (buffer-file-name))
              (ext (when file (file-name-extension file)))
              (base (file-name-base file))
              (dir (file-name-directory file))
              (root (sk-project-root))
              (root (substring root 0 (1- (length root))))
              (regex (cond ((member ext '("h" "hpp"))
                            (concat "(^|/)" (file-name-base file) ".(c|cpp)$"))
                           ((member ext '("c" "cpp"))
                            (concat "(^|/)" (file-name-base file) ".(h|hpp)$"))
                           (t nil)))
              (others (my-find-file-in-git-project regex root)))
        (if (= (length others) 1)
            (find-file (expand-file-name (car others) root))
          (ivy-read "Switch to: " others
                    :action (lambda (file)
                              (find-file (expand-file-name file root)))
                    :caller #'my-find-other-file-git))))

  (defun my-find-other-file-dir ()
    "Switch betwen .c|cpp and .h files in same directory"
    (if-let* ((file (buffer-file-name))
              (ext (when file (file-name-extension file)))
              (base (file-name-base file))
              (fs (cond ((member ext '("h" "hpp"))
                         (mapcar (lambda (f) (concat base f)) '(".c" ".cpp")))
                        ((member ext '("c" "cpp"))
                         (mapcar (lambda (f) (concat base f)) '(".h" ".hpp")))
                        (t nil)))
              (others (seq-filter #'file-exists-p fs)))
        (if (= (length others) 1)
            (find-file (car others))
          (ivy-read "Switch to: " others
                    :action (lambda (file)
                              (find-file file))
                    :caller #'my-find-other-file-dir))))

  (defun sk-find-other-file (&optional FLEX-MATCHING)
    "Switch betwen .c|cpp and .h files."
    (interactive)
    (let ((inhibit-message t))
      (or (my-find-other-file-dir)
          (my-find-other-file-git)
          (error "No other file found"))))
#+END_SRC

** SK-mode-line
Simple mode line setting function.

#+BEGIN_SRC emacs-lisp
  ;;; sk-vc-mode for sk-mode-line
  (defvar sk-vc-mode nil)
  (put 'sk-vc-mode 'risky-local-variable t)
  (make-variable-buffer-local 'sk-vc-mode)
  (put 'sk-vc-mode 'permanent-local t)

  (defun sk-vc-refresh-state ()
    (setq sk-vc-mode (git-branch-of-file (buffer-file-name))))

  (add-hook 'find-file-hook #'sk-vc-refresh-state)

  ;;; sk-mode-line
  (defun sk-mode-line ()
    (set-face-attribute 'mode-line nil :box nil)
    (set-face-attribute 'mode-line-inactive nil :box nil)
    (setq-default
     mode-line-format
     '("%e"
       (:eval
        (let* ((evil-info (and (featurep 'evil) evil-mode
                               (concat " " (upcase (symbol-name evil-state)))))
               (buffer-info (concat " %* %I " current-input-method-title))
               (buffer-name (propertize " %b " 'face 'mode-line-emphasis))
               (vc-info (and sk-vc-mode (concat " (" sk-vc-mode ") ")))
               (mode-and-vc (propertize
                             (concat " "
                                     (format-mode-line mode-name)
                                     vc-info
                                     " ")
                             'face 'mode-line-inactive))
               (line-info (format-mode-line " %l,%3c  "))
               (pos-info (format-mode-line "%p%% "))
               (right-info (concat line-info pos-info))
               (right-length (length right-info))
               (center-fill (propertize
                             " "
                             'face 'mode-line-inactive
                             'display
                             `((space :align-to
                                      (- (+ right right-fringe right-margin)
                                         ,right-length))))))
          (concat evil-info buffer-info buffer-name mode-and-vc
                  center-fill
                  right-info))))))
#+END_SRC

Enable =sk-mode-line=.

#+BEGIN_SRC emacs-lisp
  (sk-mode-line)
#+END_SRC
** Use-package
Install =use-package= if not exists. Set some default settings for
=use-package=.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-always-defer t
        use-package-always-ensure t
        use-package-enable-imenu-support t)
  (put :map 'lisp-indent-function 'defun)
#+END_SRC

Load =use-package=. From this point, only =use-package= will be used for
settings.

#+BEGIN_SRC emacs-lisp
  (require 'use-package)
#+END_SRC

* Evil and Evil-leader packages
#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :init
    (defvar sk-evil-sub-leader "M-m")
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "<escape>" 'keyboard-quit
      "0"  'delete-window
      "1"  'delete-other-windows
      "2"  'split-window-below
      "3"  'split-window-right
      ","  'other-window
      "q"  'kill-current-buffer
      "Q"  'kill-emacs
      "u"  'pop-to-mark-command
      "w"  'save-buffer
      "cc" (kbd "\C-c\C-c")
      "st" 'tmux-new-pane-here
      "hk" 'describe-key
      "hm" 'describe-mode
      "xr" 'read-only-mode
      "xv" 'evil-reload-file)
    (defun sk-evil-leader-describe-bindings ()
      (interactive)
      (let ((current-buffer (current-buffer)))
        (with-help-window (help-buffer)
          (with-current-buffer (help-buffer)
            (describe-buffer-bindings current-buffer)
            (keep-lines "^SPC" (point-min) (point-max))
            (delete-matching-lines "Prefix Command" (point-min) (point-max))))))
    (defun evil-sub-leader-mode ()
      (let* ((sub-leader (kbd sk-evil-sub-leader))
             (mode-map (cdr (assoc major-mode evil-leader--mode-maps)))
             (map (or mode-map evil-leader--default-map)))
        (evil-normalize-keymaps)
        (define-key evil-motion-state-local-map sub-leader map)
        (define-key evil-insert-state-local-map sub-leader map)
        (define-key evil-emacs-state-local-map sub-leader map)))
    (add-hook 'evil-local-mode-hook 'evil-sub-leader-mode t)
    (defun evil-leader/set-key-minor-mode (mode key def &rest bindings)
      (declare (indent defun))
      (while key
        (let ((k1 (kbd (concat evil-leader/leader key)))
              (k2 (kbd (concat sk-evil-sub-leader " " key))))
          (evil-define-minor-mode-key 'motion mode k1 def)
          (evil-define-minor-mode-key 'motion mode k2 def)
          (evil-define-minor-mode-key 'insert mode k2 def)
          (evil-define-minor-mode-key 'emacs mode k2 def))
        (setq key (pop bindings)
              def (pop bindings))))
    (setq evil-leader/no-prefix-mode-rx
          '("magit-.*-mode" "gnus-.*-mode" "package-.*-mode" "dired-mode")))

  (use-package evil
    :bind (:map evil-insert-state-map
            ("C-k" . kill-line)
            :map evil-visual-state-map
            ("p"   . evil-paste-pgvy)
            :map evil-ex-completion-map
            ("C-a" . move-beginning-of-line)
            ("C-b" . backward-char)
            ("C-d" . delete-char)
            ("C-k" . kill-line)
            ("M-n" . next-complete-history-element)
            ("M-p" . previous-complete-history-element))
    :custom
    (evil-undo-system 'undo-tree)
    (evil-want-C-u-scroll t)
    :init
    (evil-mode)
    :config
    (setq evil-insert-state-modes (delete 'wdired-mode evil-insert-state-modes))
    (evil-leader/set-key "C-v" 'my-evil-visual-block)
    (push '("*eldoc*" . emacs) evil-buffer-regexps)
    (add-hook 'evil-insert-state-entry-hook
              (lambda () (when buffer-read-only (read-only-mode -1))))
    (defun evil-reload-file ()
      (interactive)
      (let ((p (point)))
        (find-alternate-file (buffer-file-name))
        (goto-char p)))
    (defun evil-paste-pgvy ()
      "Paste and restore visual block and yank."
      (interactive)
      (call-interactively 'evil-paste-after)
      (evil-visual-restore)
      (call-interactively 'evil-yank))
    (defun evil-swap-key (map key1 key2)
      "Swap KEY1 and KEY2 in MAP"
      (let  ((def1 (lookup-key map key1))
             (def2 (lookup-key map key2)))
        (define-key map key1 def2)
        (define-key map key2 def1)))
    (defun undo-at-here (n)
      (interactive "p")
      (save-excursion (undo-tree-undo-1 n)))
    (defun my-evil-visual-block (&optional arg)
      (interactive)
      (evil-execute-in-emacs-state)
      (rectangle-mark-mode arg))
    (evil-define-text-object evil-a-c-func (count &optional beg end type)
      (save-excursion
        (move-end-of-line 1)
        (let ((p1 (and (evil-backward-section-begin) (point)))
              (p2 (ignore-errors (and (search-forward "{") (evil-jump-item)))))
          (if p2
              (evil-range p1 (1+ p2) type :expanded t)
            (error "Can't find c function.")))))
    (evil-define-text-object evil-inner-c-func (count &optional beg end type)
      (save-excursion
        (move-end-of-line 1)
        (evil-backward-section-begin)
        (let* ((p1 (ignore-errors (search-forward "{")))
               (p2 (ignore-errors (and p1 (evil-jump-item)))))
          (if p2
              (evil-range p1 p2 type :expanded t)
            (error "Can't find c function.")))))
    (define-key evil-inner-text-objects-map "d" 'evil-inner-bracket)
    (define-key evil-outer-text-objects-map "d" 'evil-a-bracket)
    (define-key evil-inner-text-objects-map "j" 'evil-inner-curly)
    (define-key evil-outer-text-objects-map "j" 'evil-a-curly)
    (define-key evil-inner-text-objects-map "f" 'evil-inner-c-func)
    (define-key evil-outer-text-objects-map "f" 'evil-a-c-func)
    (define-key evil-inner-text-objects-map "k" 'evil-inner-angle)
    (define-key evil-outer-text-objects-map "k" 'evil-an-angle)
    (evil-swap-key evil-motion-state-map "j" "gj")
    (evil-swap-key evil-motion-state-map "k" "gk")
    (evil-global-set-key 'normal "U" 'undo-at-here)
    (evil-global-set-key 'normal "Y" (kbd "y$"))
    (evil-global-set-key 'motion "$" 'end-of-line)
    (dolist (m '(image-mode diff-mode special-mode))
      (evil-set-initial-state m 'emacs)))

  (use-package evil-anzu
    :demand t
    :after anzu)

  (use-package evil-visualstar
    :bind (:map evil-visual-state-map
            ("n" . evil-visualstar/begin-search-forward)
            ("N" . evil-visualstar/begin-search-backward))
    :config
    (global-evil-visualstar-mode))

  (use-package evil-surround
    :init
    (sk-defer-init (global-evil-surround-mode 1))
    :config
    (setq-default evil-surround-pairs-alist
                  (append evil-surround-pairs-alist
                          '((?` . ("`" . "`"))
                            (?d . ("[" . "]"))
                            (?j . ("{" . "}"))
                            (?k . ("<" . ">")))))
    (evil-define-key 'visual evil-surround-mode-map
      "gs" 'evil-surround-region))

  (use-package evil-commentary
    :init
    (sk-defer-init (evil-commentary-mode 1)))
#+END_SRC
* General packages - built-in
#+BEGIN_SRC emacs-lisp
  ;;; Personal packages
  (use-package company-sql
    :ensure nil
    :load-path emacs-etc-dir
    :hook ((sql-mode sql-interactive-mode) . my-sql-mode-hook)
    :config
    (defun my-sql-mode-hook ()
      (add-to-list 'company-backends 'company-sql)))

  ;;; Built-in packages
  (use-package korea-util
    :ensure nil
    :bind ("C-\\" . toggle-korean-input-method)
    :init
    (setq default-korean-keyboard "3")
    (setup-korean-environment-internal))

  (use-package recentf
    :ensure nil
    :hook (find-file . recentf-mode)
    :custom (recentf-max-saved-items 100)
    :config
    (add-to-list 'recentf-exclude
                 (expand-file-name "elpa/.*" emacs-config-dir)))

  (use-package calendar
    :ensure nil
    :bind (:map calendar-mode-map
            ("h"       . calendar-backward-day)
            ("j"       . calendar-forward-week)
            ("k"       . calendar-backward-week)
            ("l"       . calendar-forward-day)
            ("C-f"     . calendar-scroll-left-three-months)
            ("C-b"     . calendar-scroll-right-three-months)
            ("<left>"  . calendar-scroll-right)
            ("<right>" . calendar-scroll-left))
    :config
    (setq calendar-date-display-form
          '((format "%s-%.2d-%.2d%s" year
                    (string-to-number month)
                    (string-to-number day)
                    (if dayname (concat " " dayname) "")))
          diary-file "~/Dropbox/org/diary")
    (evil-set-initial-state 'calendar-mode 'emacs))

  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
            ("M-o"   . dired-omit-mode)
            ("j"     . dired-next-line)
            ("k"     . dired-previous-line)
            ("r"     . ora-dired-rsync)
            ("/"     . swiper)
            ("^"     . dired-up-and-close-dir)
            ("bp"    . my-dired-pdf-size-down)
            ("<DEL>" . dired-up-and-close-dir)
            ("<RET>" . dired-visit-file-or-dir))
    :init
    (add-to-list 'magic-mode-alist
                 '((lambda () (< large-file-warning-threshold (buffer-size)))
                   . fundamental-mode))
    :config
    (require 'dired-x)
    (setq dired-listing-switches "-alh --group-directories-first"
          dired-omit-extensions '("~")
          dired-omit-files (rx bol (or "#" ".")))
    (add-hook 'dired-mode-hook 'dired-omit-mode)

    (evil-set-initial-state 'dired-mode 'emacs)
    (evil-leader/set-key-for-mode 'dired-mode
      "cy" 'my-dired-copy-path            ; copy current folder path
      "cY" 'my-dired-copy-filepath        ; copy selected file path
      "ee" 'wdired-change-to-wdired-mode
      "ec" 'wdired-finish-edit
      "eq" 'wdired-exit)

    (defun my-dired-copy-path ()
      (interactive)
      (let ((path (expand-file-name default-directory)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun my-dired-copy-filepath ()
      (interactive)
      (let ((path (dired-filename-at-point)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun dired-visit-file-or-dir ()
      (interactive)
      (if (file-directory-p (dired-get-filename nil t))
          (dired-find-alternate-file)
        (dired-find-file-other-window)))

    (defun dired-up-and-close-dir (n)
      (interactive "p")
      (let* ((buf (get-buffer (buffer-name)))
             (curr (dired-current-directory))
             (dest (file-name-directory (directory-file-name curr))))
        (dotimes (_ (- n 1))
          (setq curr dest)
          (setq dest (file-name-directory (directory-file-name dest))))
        (dired dest)
        (dired-goto-file curr)
        (kill-buffer buf)))

    (defun ora-dired-rsync ()
      (interactive)
      (let* ((dest (read-file-name "Rsync to: " (dired-dwim-target-directory)))
             (files (dired-get-marked-files nil current-prefix-arg))
             (regex (rx bol "/" (or "ssh" "scp") (? any) ":"))
             (prefix (cond ((string-match-p regex dest)
                            (replace-regexp-in-string regex "" dest))
                           ((string-match-p ".@.*:" dest) dest)
                           (t (expand-file-name dest))))
             (cmd (concat "rsync -ahrsvzP "
                          (mapconcat
                           (lambda (f)
                             (concat
                              "\"" (replace-regexp-in-string regex "" f) "\"" ))
                           files " ")
                          " \"" prefix "\""))
             (remote-p (string-match-p regex default-directory))
             (default-directory (if remote-p "~/" default-directory)))
        ;; Run rsync in home folder if remote-p.
        ;; Available for local to local, local to remote, remote to local.
        ;; Remote to remote is not available.
        (async-shell-command cmd "*rsync*")
        (other-window 1)
        (view-mode)))

    (defun my-dired-pdf-size-down ()
      (interactive)
      (let ((display-buffer-alist
             '(("\\*Async Shell Command\\*.*" display-buffer-no-window)))
            (file (dired-filename-at-point))
            (temp (make-temp-file ".temp" nil ".pdf")))
        (if (not (equal (file-name-extension file) "pdf"))
            (message "Not a PDF file.")
          (async-shell-command
           (concat
            "gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 "
            "-dPDFSETTINGS=/printer -dNOPAUSE -dQUIET -dBATCH -dPrinted=false "
            "-sOutputFile=" temp " " file " && "
            "mv " temp " " file))))))

  (use-package org
    :ensure nil
    :bind (:map org-mode-map
            ("C-c a"   . org-agenda)
            ("C-c b"   . org-switchb)
            ("C-c l"   . org-store-link)
            ("C-c r"   . org-remember)
            ("C-c t"   . org-table-create)
            ("C-c u"   . org-up-element))
    :init
    (evil-leader/set-key
      "na" 'org-agenda)
    :config
    (require 'ox)
    (require 'ox-beamer)
    (setq
     my-org-path "~/Dropbox/org/"
     my-org-note (expand-file-name "notes.org" my-org-path)
     org-agenda-files (list my-org-path)
     org-babel-load-languages '((C . t)
                                (css . t)
                                (dot . t)
                                (gnuplot . t)
                                (emacs-lisp . t)
                                (latex . t)
                                (octave . t)
                                (plantuml . t)
                                (python . t)
                                (shell . t))

     org-blank-before-new-entry '((heading . nil)
                                  (plain-list-item . nil))
     org-confirm-babel-evaluate nil
     org-capture-templates
     `(("t" "Todo" entry (file+headline ,my-org-note "ToDos")
        "* TODO %?\n%U" :empty-lines 1)
       ("w" "Wait" entry (file+headline ,my-org-note "ToDos")
        "* WAIT %?\n%t" :empty-lines 1)
       ("n" "Note" entry (file+headline ,my-org-note "Notes")
        "* %?\n%U" :empty-lines 1)
       ("e" "Event" entry (file+headline ,my-org-note "Events")
        "* %?\n%U" :empty-lines 1))
     org-default-notes-file my-org-note
     org-export-default-language "kr"
     org-export-headline-levels 2
     org-export-time-stamp-file nil
     org-export-with-email t
     org-export-with-section-numbers nil
     org-export-with-sub-superscripts nil
     org-export-with-toc 1
     org-html-inline-image-rules
     '(("file" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("http" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'"))
     org-html-metadata-timestamp-format "%Y-%m-%d"
     org-html-validation-link ""
     org-latex-listings 'minted
     org-latex-packages-alist '(("" "kotex" nil)
                                ("" "parskip" nil)
                                ("margin=2cm" "geometry" nil)
                                ("cachedir=/tmp/minted" "minted"))
     org-latex-pdf-process
     '("%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "%latex -shell-escape -interaction nonstopmode -output-directory %o %f")
     org-latex-tables-centered nil
     org-latex-title-command "\\maketitle \\clearpage"
     org-latex-toc-command "\\tableofcontents \\clearpage"
     org-log-done 'time
     org-plantuml-jar-path "/usr/share/java/plantuml/plantuml.jar"
     org-src-lang-modes (cons '("dot" . graphviz-dot) org-src-lang-modes)
     org-src-window-setup 'current-window
     org-startup-folded t
     org-startup-indented t
     org-startup-with-inline-images t
     org-todo-keywords
     '((sequence "TODO(t)" "PROG(p)" "WAIT(w)" "|" "DONE(d)" "KILL(k)")))

    (evil-leader/set-key-for-mode 'org-mode
      "c <SPC>" 'org-table-blank-field
      "cb"  'org-switchb
      "ce"  'org-export-dispatch
      "ci"  'org-insert-link
      "cl"  'org-store-link
      "cs"  'my-org-capture-image
      "ct"  'org-todo
      "cw"  'org-refile
      "ee"  'org-edit-src-code
      "ei"  'org-insert-structure-template
      "tc"  'org-table-create
      "tl"  'org-tags-view
      "ts"  'org-set-tags-command
      "cdd" 'org-deadline
      "cds" 'org-schedule
      "cd." 'org-time-stamp)
    (evil-leader/set-key-minor-mode 'org-src-mode
      "ec" 'org-edit-src-exit
      "eq" 'org-edit-src-abort)
    (evil-leader/set-key-minor-mode 'org-capture-mode
      "ck" 'org-capture-kill
      "cw" 'org-capture-refile)
    (evil-define-key 'motion org-mode-map
      (kbd "TAB") 'org-cycle
      "gh" 'org-up-element
      "gl" 'org-down-element
      "gj" 'org-forward-element
      "gk" 'org-backward-element)
    (add-hook 'org-mode-hook
              (lambda ()
                (evil-local-set-key 'insert (kbd "<tab>") 'my-org-tab)
                (evil-local-set-key 'insert (kbd "TAB") 'my-org-tab)))
    (evil-declare-motion 'org-up-element)
    (evil-declare-motion 'org-down-element)
    (evil-declare-motion 'org-forward-element)
    (evil-declare-motion 'org-backward-element)

    (dolist (mode '("js" "javascript"))
      (add-to-list 'org-src-lang-modes `(,mode . js2)))
    (dolist (mode '("css" "html" "vue" "web"))
      (add-to-list 'org-src-lang-modes `(,mode . web)))

    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages)
    (defun my-org-tab (arg)
      (interactive "P")
      (if (org-at-table-p)
          (org-cycle arg)
        (company-indent-or-complete-common arg)))
    (defun my-org-inline-image-hook ()
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun my-org-before-process-hook (exporter)
      (cond
       ((eq exporter 'html)
        (setq-local org-html-head-include-default-style nil
                    org-html-head
                    (concat
                     "<style type=\"text/css\">\n"
                     "<!--/*--><![CDATA[/*><!--*/\n"
                     (with-temp-buffer
                       (insert-file-contents
                        (expand-file-name "org.css" emacs-etc-dir))
                       (buffer-string))
                     (apply #'format
                            "\n.src {background-color: %s; color: %s;}\n"
                            (mapcar
                             (lambda (x)
                               (apply #'color-rgb-to-hex
                                      (append (color-name-to-rgb x) '(2))))
                             (list (face-background 'default)
                                   (face-foreground 'default))))
                     "/*]]>*/-->\n"
                     "</style>\n")))
       ((eq exporter 'latex)
        (setq-local org-export-with-section-numbers t
                    org-export-with-toc 2))))
    (defun my-org-capture-image ()
      (interactive)
      (let* ((pre (concat
                   (if (buffer-file-name)
                       (file-name-base (buffer-file-name))
                     (buffer-name))
                   "_" (format-time-string "%y%m%d") "_"))
             (img (concat "imgs/"(make-temp-name pre) ".png")))
        (unless (file-exists-p "imgs")
          (make-directory "imgs"))
        (call-process "import" nil nil nil img)
        (when (file-exists-p img)
          (insert (concat "[[file:" img "]]")))))
    (add-hook 'org-babel-after-execute-hook 'my-org-inline-image-hook)
    (add-hook 'org-export-before-processing-hook 'my-org-before-process-hook))

  (use-package ibuffer
    :ensure nil
    :bind ("C-x C-b" . ibuffer)
    :init
    (evil-leader/set-key
      "xb" 'ibuffer)
    :config
    (setq ibuffer-expert t
          ibuffer-sorting-mode 'alphabetic
          ibuffer-default-sorting-mode 'major-mode
          ibuffer-saved-filter-groups
          '(("home"
             ("Emacs-config" (or (filename . ".emacs")
                                 (filename . ".emacs.d")
                                 (filename . "emacs-config")))
             ("Org / MD" (or (mode . org-mode)
                             (mode . markdown-mode)
                             (filename . "OrgMode")))
             ("Magit" (mode . magit-status-mode))
             ("Code" (derived-mode . prog-mode))
             ("Shell" (or (mode . shell-mode)
                          (mode . eshell-mode)))
             ("Dired" (mode . dired-mode))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
    (defun my-ibuffer-unmark-all ()
      "Unmark all immdiately"
      (interactive)
      (ibuffer-unmark-all ?\s))
    (define-key ibuffer-mode-map (kbd "* *") 'my-ibuffer-unmark-all)
    (define-ibuffer-column size
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "home"))))

  (use-package shell
    :ensure nil
    :init
    (evil-leader/set-key
      "ss" 'shell)
    :config
    (evil-leader/set-key-for-mode 'shell-mode
      "l"  'my-comint-history))

  (use-package eshell
    :ensure nil
    :hook (eshell-mode . my-eshell-setup)
    :init
    (evil-leader/set-key
      "se" 'eshell)
    :config
    (defun eshell/clear ()
      "Clear Eshell buffer"
      (interactive)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (execute-kbd-macro (kbd "<RET>"))))
    (defun my-eshell-change-whole-line ()
      (interactive)
      (execute-kbd-macro (kbd "0C")))
    (defun my-eshell-history ()
      (interactive)
      (my-comint-history eshell-history-ring))
    (defun my-eshell-setup ()
      (setenv "TERM" "screen-256color")
      (evil-define-key 'insert eshell-mode-map (kbd "C-a") 'eshell-bol)
      (evil-define-key 'normal eshell-mode-map "S" 'my-eshell-change-whole-line)
      (evil-define-key 'motion eshell-mode-map
        "0"  'eshell-bol
        "gk" 'eshell-previous-prompt
        "gj" 'eshell-next-prompt
        (kbd "M-p") (lambda () (interactive) nil)
        (kbd "M-n") (lambda () (interactive) nil)
        (kbd "RET") 'my-comint-return))
    (evil-leader/set-key-for-mode 'eshell-mode
      "l"  'my-eshell-history))

  (use-package term
    :ensure nil
    :custom-face
    (term-color-blue ((t :foreground "skyblue3" :background "skyblue3")))
    :config
    (evil-set-initial-state 'term-mode 'emacs)
    (defun term-send-esc ()
      "Send ESC in term mode."
      (interactive)
      (term-send-raw-string "\e"))
    (define-key term-raw-map (kbd "<escape>") 'term-send-esc))

  (use-package paren
    :ensure nil
    :init
    (sk-defer-init (show-paren-mode 1)))

  (use-package hl-line
    :ensure nil
    :init
    (sk-defer-init (global-hl-line-mode 1)))

  (use-package ansi-color
    :ensure nil
    :hook (compilation-filter . my-ansi-colorize-buffer)
    :custom
    (ansi-color-names-vector
     ["black" "red3" "green3" "yellow3" "skyblue3" "magenta3" "cyan3" "gray90"])
    :config
    (defun my-ansi-colorize-buffer ()
      (let ((buffer-read-only nil))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (use-package display-line-numbers
    :ensure nil
    :custom-face
    (line-number ((t :foreground "gray51" :inherit 'default)))
    (line-number-current-line ((t (:inherit 'default))))
    :hook
    ((find-file prog-mode) . display-line-numbers-mode)
    :config
    (setq-default display-line-numbers-width 3
                  display-line-numbers-type 'visual
                  display-line-numbers-current-absolute nil))

  (use-package tramp
    :ensure nil
    :config
    (setq tramp-auto-save-directory "/tmp/tramp/"
          tramp-chunksize 2000
          tramp-completion-reread-directory-timeout nil
          tramp-verbose 1)
    ;; TRAMP respect PATH variable on remote machine.
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path))

  (use-package autorevert
    :ensure nil
    :hook (find-file . global-auto-revert-mode)
    :config
    (setq auto-revert-check-vc-info t
          auto-revert-verbose nil))

  (use-package view
    :ensure nil
    :hook (view-mode . evil-motion-state))

  (use-package flymake
    :ensure nil
    :config
    (evil-set-initial-state 'flymake-diagnostics-buffer-mode 'emacs)
    (evil-define-key 'motion flymake-mode-map
      "]e" 'flymake-goto-next-error
      "[e" 'flymake-goto-prev-error)
    (add-hook 'flymake-mode-hook (lambda () (evil-normalize-keymaps))))

  (use-package comint
    :ensure nil
    :commands my-comint-history
    :config
    (defun my-comint-history (&optional ring)
      (interactive)
      (let ((input-ring (if ring ring comint-input-ring)))
        (cl-letf (((symbol-function 'ivy-completion-in-region-action)
                   (lambda (cmd) (my-comint-return) (insert cmd))))
          (counsel--browse-history input-ring
                                   :caller #'counsel-shell-history))))
    (defun my-comint-return ()
      (interactive)
      (evil-goto-line)
      (evil-append-line 1))
    (evil-leader/set-key-for-mode 'comint-mode
      "l"  'my-comint-history)
    (evil-define-key 'normal comint-mode-map
      "gj" 'comint-next-prompt
      "gk" 'comint-previous-prompt
      (kbd "RET") 'my-comint-return))

  (use-package package
    :ensure nil
    :init
    (sk-defer-init (package-read-all-archive-contents)))

  (use-package ediff
    :ensure nil
    :custom-face
    (ediff-odd-diff-A ((((background light)) (:background "grey"))
                       (((background dark)) (:background "gray35"))))
    (ediff-odd-diff-B ((((background light)) (:background "light grey"))
                       (((background dark)) (:background "gray55"))))
    (ediff-odd-diff-C ((((background light)) (:background "grey"))
                       (((background dark)) (:background "gray35"))))
    (ediff-even-diff-Ancestor ((((background light)) (:background "grey"))
                               (((background dark)) (:background "gray35"))))
    (ediff-even-diff-A ((((background light)) (:background "light grey"))
                        (((background dark)) (:background "gray55"))))
    (ediff-even-diff-B ((((background light)) (:background "grey"))
                        (((background dark)) (:background "gray35"))))
    (ediff-even-diff-C ((((background light)) (:background "light grey"))
                        (((background dark)) (:background "gray55"))))
    (ediff-fine-diff-B ((((background light)) (:background "#aaffaa"))
                        (((background dark)) (:background "#227722"))))
    :config
    (setq ediff-split-window-function 'split-window-horizontally
          ediff-window-setup-function 'ediff-setup-windows-plain))

  (use-package eldoc
    :ensure nil
    :config
    (setq eldoc-echo-area-use-multiline-p 1))

  (use-package help-mode
    :ensure nil
    :config
    (evil-define-key 'motion help-mode-map
      "q"  'quit-window
      "[g" 'help-go-back
      "]g" 'help-go-forward
      (kbd "<tab>") 'forward-button))

  (use-package smerge-mode
    :ensure nil
    :custom-face
    (smerge-refined-added ((((background light)) (:background "grey"))
                           (((background dark)) (:background "gray35")))))

  (use-package vc
    :ensure nil
    :custom
    (vc-follow-symlinks nil)
    (vc-handled-backends nil)
    :init
    (defalias 'vc-refresh-state 'sk-vc-refresh-state)
    (defun sk-vc-refresh-state ()
      (setq sk-vc-mode (git-branch-of-file (buffer-file-name))))
    (add-hook 'find-file-hook #'sk-vc-refresh-state))

  (use-package tex-mode
    :ensure nil
    :config
    (setq-default TeX-master nil)
    (setq TeX-parse-self t
          TeX-PDF-mode t)
    (evil-leader/set-key-for-mode 'latex-mode
      "cc" 'my-latex-compile
      "ce" 'LaTeX-environment
      "cj" 'LaTeX-insert-item
      "cs" 'LaTeX-section
      "cv" 'TeX-view
      "cz" 'LaTeX-command-section)
    (defun my-latex-compile ()
      (interactive)
      (TeX-command "LaTeX" 'TeX-master-file)))
#+END_SRC
* General packages - external
#+BEGIN_SRC emacs-lisp
  (use-package bind-key
    :init
    (bind-keys*
     ("<mouse-1>"        . nil)
     ("<mouse-3>"        . nil)
     ("<down-mouse-1>"   . nil)
     ("<down-mouse-3>"   . nil)
     ("<drag-mouse-1>"   . nil)
     ("<drag-mouse-3>"   . nil)
     ("<C-down-mouse-1>" . nil)
     ("<M-down-mouse-1>" . nil)
     ("<S-down-mouse-1>" . nil)
     ("C-c <escape>"     . keyboard-quit)
     ("C-x <escape>"     . keyboard-quit)
     ("M-,"              . my-other-window)
     ("M-<f5>"           . sk-sbin-dired)
     ("C-M-,"            . transpose-windows)
     ("M-S-<up>"         . (lambda () (interactive) (move-line -1)))
     ("M-S-<down>"       . (lambda () (interactive) (move-line  1)))
     ("<f7>"             . (lambda () (interactive) (buffer-save-or-load 7 t)))
     ("<f8>"             . (lambda () (interactive) (buffer-save-or-load 8 t)))
     ("C-<f7>"           . (lambda () (interactive) (buffer-save-or-load 7)))
     ("C-<f8>"           . (lambda () (interactive) (buffer-save-or-load 8)))
     :map minibuffer-local-map
     ("<escape>"         . minibuffer-keyboard-quit))
    (defun my-other-window ()
      (interactive)
      (if (minibufferp)
          (abort-recursive-edit)
        (when (or (evil-insert-state-p) (evil-visual-state-p))
          (evil-normal-state))
        (call-interactively 'other-window))))

  (use-package package-loading-notifier
    :custom  (package-loading-notifier-packages '(helm org magit yasnippet))
    :init
    (package-loading-notifier-mode 1))

  (use-package company
    :init
    (sk-defer-init (global-company-mode 1))
    :config
    (setq company-format-margin-function nil
          company-idle-delay 0.2)
    (defun my-company-abort ()
      (when (company--active-p)
        (company-cancel 'abort)))
    (defun my-company-yas-expand ()
      (interactive)
      (when (company--active-p) (company-cancel))
      (yas-minor-mode-on)
      (let ((company-backends '(company-yasnippet)))
        (company-complete-common)))
    (add-hook 'evil-insert-state-exit-hook #'my-company-abort)
    (define-key company-active-map (kbd "M-n") 'company-select-next)
    (define-key company-active-map (kbd "M-p") 'company-select-previous)
    (evil-define-key 'insert company-mode-map
      (kbd "M-/") 'my-company-yas-expand
      (kbd "TAB") 'company-indent-or-complete-common))

  (use-package company-irony
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony))

  (use-package company-irony-c-headers
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony-c-headers))

  (use-package company-web
    :demand t
    :after web-mode)

  (use-package company-go
    :demand t
    :after go-mode
    :config
    (add-to-list 'company-backends 'company-go))

  (use-package company-ghc
    :demand t
    :after haskell-mode
    :config
    (add-to-list 'company-backends 'company-ghc))

  (use-package undo-tree
    :init
    (sk-defer-init (global-undo-tree-mode 1))
    :config
    (add-hook 'evil-local-mode-hook 'turn-on-undo-tree-mode)
    (evil-set-initial-state 'undo-tree-visualizer-mode 'emacs)
    (evil-leader/set-key
      "xu" 'undo-tree-visualize))

  (use-package wgrep
    :commands wgrep-change-to-wgrep-mode
    :bind (:map helm-git-grep-map
            ("C-c C-e" . wgrep-change-to-wgrep-mode)
            ("C-c C-s" . wgrep-save-all-buffers))
    :config
    (evil-leader/set-key-for-mode 'helm-git-grep-mode
      "ce" 'wgrep-change-to-wgrep-mode
      "cs" 'wgrep-save-all-buffers
      "ck" 'wgrep-abort-changes)
    (advice-add 'wgrep-change-to-wgrep-mode :after 'evil-normal-state))

  (use-package helm
    :bind (("M-y"     . helm-show-kill-ring)
           ("C-x C-r" . helm-recentf)
           :map minibuffer-local-map
           ("M-l"     . helm-minibuffer-history)
           ("M-y"     . yank-pop)
           :map helm-map
           ("<escape>". helm-keyboard-quit))
    :init
    (evil-leader/set-key
      "i"  'helm-semantic-or-imenu
      "y"  'helm-show-kill-ring
      "ho" 'helm-occur
      "hr" 'helm-resume)
    :config
    (require 'helm-files)
    (setq helm-imenu-execute-action-at-once-if-one nil
          helm-split-window-default-side 'right
          helm-show-completion-display-function nil)
    (advice-add 'helm-occur-goto-line :after
                (lambda (_) (when which-function-mode
                              (which-func-update)))))

  (use-package helm-ag
    :commands (helm-ag-project-or-here helm-ag-here)
    :init
    (evil-leader/set-key
      "jp" 'helm-ag-project-or-here
      "jP" 'helm-ag-here)
    :config
    (setq helm-ag-insert-at-point 'symbol
          helm-ag-base-command "ag --nocolor --nogroup --follow"
          helm-ag-use-grep-ignore-list t)
    (defun helm-ag-project-or-here ()
      (interactive)
      (helm-do-ag
       (my-project-root-or-dir)
       (car (projectile-parse-dirconfig-file))))
    (defun helm-ag-here ()
      (interactive)
      (helm-do-ag default-directory)))

  (use-package helm-git-grep
    :init
    (evil-leader/set-key
      "p" 'helm-git-grep-at-point))

  (use-package projectile
    :commands (my-project-root-or-dir
               sk-add-known-project
               sk-remove-known-project)
    :hook (c-mode-common
           . (lambda () (local-set-key (kbd "M-o") 'sk-find-other-file)))
    :init
    (evil-leader/set-key
      "jd" 'projectile-find-dir
      "jk" 'projectile-kill-buffers
      "jb" 'projectile-switch-to-buffer
      "js" 'projectile-switch-project
      "jS" 'projectile-save-project-buffers)
    :config
    (setq projectile-completion-system 'ivy
          projectile-require-project-root nil
          projectile-switch-project-action 'projectile-dired
          projectile-track-known-projects-automatically nil)
    (projectile-mode 1)
    (defun my-project-root-or-dir ()
      (or (projectile-project-root) default-directory))
    (defun sk-add-known-project (project-root)
      "Make .projectile file and add the project to known projects list."
      (interactive (list (read-directory-name "Add to known projects: ")))
      (let ((pfile (concat project-root ".projectile")))
        (unless (file-exists-p pfile)
          (write-region "" nil pfile)))
      (projectile-add-known-project project-root))
    (defalias 'sk-remove-known-project 'projectile-remove-known-project)
    (defalias 'projectile-project-root 'sk-project-root))

  (use-package markdown-mode)

  (use-package markdown-toc)

  (use-package ox-reveal
    :demand t
    :after org
    :config
    (setq org-reveal-hlevel 2
          org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"
          org-reveal-title-slide "<h2>%t</h2><h4>%a&nbsp(%e)</h4>"
          org-reveal-transition "none"))

  (use-package magit
    :bind ("<f12>" . magit-status)
    :hook (with-editor-mode . evil-normal-state)
    :init
    (evil-leader/set-key
      "gs" 'magit-status
      "gd" 'magit-file-dispatch)
    :config
    (setq magit-log-section-commit-count 5
          magit-completing-read-function #'ivy-completing-read)
    (evil-leader/set-key-minor-mode 'with-editor-mode
      "ck" 'with-editor-cancel)
    (bind-key "<escape>" 'transient-quit-one transient-map)
    (evil-make-overriding-map magit-blame-read-only-mode-map 'normal)
    (add-hook 'magit-blame-mode-hook 'evil-normalize-keymaps)
    (add-hook 'with-editor-mode-hook 'flyspell-mode))

  (use-package expand-region
    :bind (("C-="   . er/expand-region))
    :init
    (evil-leader/set-key
      "=" 'er/expand-region))

  (use-package smex)

  (use-package anzu
    :init
    (sk-defer-init (global-anzu-mode 1))
    :config
    (setq anzu-search-threshold 1000
          anzu-replace-threshold 1000))

  (use-package htmlize
    :demand t
    :after org)

  (use-package korean-holidays
    :init
    (setq calendar-holidays korean-holidays))

  (use-package fzf
    :bind (("C-c j h" . fzf-here))
    :config
    (defun fzf-here ()
      (interactive)
      (fzf/start default-directory #'fzf/action-find-file)))

  (use-package yasnippet
    :commands yas-expand yas-minor-mode-on
    :config
    (advice-add 'yas-expand-snippet :around
                (lambda (old &rest r)
                  (let ((org-src-tab-acts-natively nil))
                    (yas-minor-mode-on)
                    (apply old r))))
    (let ((my-yasnippet-dir (expand-file-name "snippets/" emacs-etc-dir)))
      (add-to-list 'yas-snippet-dirs my-yasnippet-dir)
      (yas-load-directory my-yasnippet-dir t)))

  (use-package yasnippet-snippets
    :demand t
    :after yasnippet)

  (use-package ivy
    :bind (("C-x b"    . ivy-switch-buffer)
           :map minibuffer-inactive-mode-map
           ("<escape>" . abort-recursive-edit)
           :map ivy-minibuffer-map
           ("<escape>" . minibuffer-keyboard-quit)
           ("C-j"      . ivy-partial)
           ("TAB"      . ivy-alt-done))
    :init
    (defalias 'completing-read 'ivy-completing-read)
    (evil-leader/set-key
      "b" 'ivy-switch-buffer)
    :config
    (setq ivy-height 15
          ivy-height-alist '((t . 15))
          ivy-wrap t
          ivy-fixed-height-minibuffer t
          ;; Don't use ^ as initial input
          ivy-initial-inputs-alist nil
          ;; disable magic slash on non-match
          ivy-magic-slash-non-match-action nil
          ;; prefix match first
          ivy-sort-matches-functions-alist
          '((t . ivy--prefix-sort)
            (ivy-switch-buffer . ivy-sort-function-buffer)))
    (ivy-mode 1)
    (when (display-graphic-p)
      (ivy-posframe-mode 1))
    (advice-add 'ivy-thing-at-point :around
                (lambda (old &rest r)
                  (if (> (- (point-at-eol) (point-at-bol)) 10000)
                      ""
                    (apply old r))))
    (defun sk-ivy-buffer-transformer (str)
      (let* ((nmax 35)
             (buf (get-buffer str))
             (buf-name (if (>= (length str) (+ nmax 2))
                           (concat (substring str 0 (- nmax 2)) "..")
                         str))
             (buf-len (length buf-name))
             (buf-dir (buffer-local-value 'default-directory buf))
             (buf-mode (buffer-local-value 'major-mode buf))
             (mode (capitalize
                    (string-remove-suffix "-mode" (symbol-name buf-mode))))
             (max-path-len
              (max 0 (min 100 (- (frame-width) (+ nmax 30) (max 0 (- buf-len nmax))))))
             (path-dir (abbreviate-file-name (or buf-dir "~/")))
             (path-file (when-let ((name (buffer-file-name buf)))
                          (abbreviate-file-name name)))
             (path-opt (or path-file
                           (when (or (string-match-p "shell" str)
                                     (equal buf-mode 'dired-mode))
                             path-dir)))
             (path-prefix (if (string-prefix-p "~" path-opt)
                              "~/"
                            "/"))
             (path-len (length path-opt))
             (path-mod (if (<= path-len max-path-len)
                           nil
                         (substring path-opt (- path-len max-path-len) path-len)))
             (path-margin (max 0 (- 20 (max 0 (- buf-len nmax)))))
             (path (if path-mod
                       (concat path-prefix
                               "…"
                               (replace-regexp-in-string (rx bol (* (not (or "~" "/"))))
                                                         ""
                                                         path-mod))
                     path-opt))
             (form (format "%%-%ds  %%-%ds  %%s" nmax path-margin)))
        (format form buf-name mode (or path ""))))
    (ivy-configure 'ivy-switch-buffer
      :display-transformer-fn 'sk-ivy-buffer-transformer)
    (ivy-set-actions
     'projectile-switch-project
     '(("d" (lambda (p) (projectile-remove-known-project p)) "delete"))))

  (use-package ivy-yasnippet
    :init
    (evil-leader/set-key "/" 'ivy-yasnippet)
    :config
    (advice-add 'ivy-yasnippet :before 'yas-minor-mode-on)
    (advice-add 'ivy-yasnippet :after 'evil-insert-state))

  (use-package ivy-posframe
    :bind (:map ivy-posframe-mode-map
            ("M-y" . yank-pop))
    :custom-face
    (ivy-posframe
     ((((background light)) :background "ivory3" :foreground "black")
      (((background dark)) :background "#282a36" :foreground "gray80")))
    (ivy-posframe-border ((t (:inherit ivy-posframe))))
    :config
    (setq ivy-truncate-lines nil
          ivy-posframe-border-width 20
          ivy-posframe-display-functions-alist
          '((complete-symbol . ivy-posframe-display-at-point)
            (ivy-yasnippet   . ivy-display-function-fallback)
            (swiper          . ivy-display-function-fallback)
            (t               . ivy-posframe-display-at-frame-center))))

  (use-package posframe)

  (use-package counsel
    :commands (counsel-fzf-here
               counsel--browse-history
               my-counsel-switch-shell-buffer)
    :bind (("M-x"     . counsel-M-x)
           ("C-x d"   . counsel-find-file)
           ("C-x C-f" . counsel-find-file)
           ("C-h b"   . counsel-descbinds)
           ("C-h v"   . counsel-describe-variable)
           ("C-h f"   . counsel-describe-function)
           ("<f5>"    . sk-compile))
    :init
    (evil-leader/set-key
      "<SPC>" 'counsel-M-x
      "M-m"   'counsel-M-x
      "d"     'counsel-find-file
      "f"     'counsel-find-file
      "o"     'counsel-git
      "r"     'counsel-recentf
      "hb"    'counsel-descbinds
      "hv"    'counsel-describe-variable
      "hf"    'counsel-describe-function
      "nx"    'counsel-org-capture
      "jh"    'counsel-fzf-here
      "jo"    'counsel-fzf
      "sb"    'my-counsel-switch-shell-buffer)
    :config
    (setq ivy-initial-inputs-alist nil
          ivy-height-alist '((t . 15))
          sk-compile-history nil)
    (defun counsel-fzf-here ()
      (interactive)
      (counsel-fzf nil default-directory))
    (defun my-counsel-switch-shell-buffer ()
      "Switch to a shell buffer, or create one."
      (interactive)
      (ivy-read "Shell buffer: "
                (append (counsel--buffers-with-mode #'shell-mode)
                        (counsel--buffers-with-mode #'eshell-mode))
                :action #'counsel--switch-to-shell
                :caller 'ivy-switch-buffer))
    (ivy-set-actions
     'counsel-shell-history
     '(("d" (lambda (x) (ring-remove comint-input-ring
                                     (ring-member comint-input-ring (car x))))
        "delete")))

    (defun sk-compile-candidates ()
      (if-let ((sbin (find-file-in-tree default-directory ".sbin" t)))
          (let ((files-alist)
                (files (directory-files sbin t "\\.sh$"))
                (cand (alist-get sbin sk-compile-history nil nil #'equal)))
            (dolist (f files)
              (setq files-alist
                    (nconc files-alist
                           (list (cons (file-name-nondirectory f) f)))))
            (when cand
              (push (cons (file-name-nondirectory cand) cand) files-alist))
            (delete-dups files-alist))
        (error "Couldn't find .sbin folder")))

    (defun sk-compile-action (cmd-alist)
      (let* ((cmd (cdr cmd-alist))
             (dir (file-name-directory cmd)))
        (setf (alist-get dir sk-compile-history nil 'remove #'equal) cmd)
        (compile cmd)))

    (defun sk-compile (&optional dir)
      (interactive)
      (ivy-read "Compile script: "
                (sk-compile-candidates)
                :require-match t
                :action  #'sk-compile-action
                :keymap counsel-compile-map
                :caller 'sk-compile)))

  (use-package which-key
    :init
    (sk-defer-init (which-key-mode 1)))

  (use-package auctex)

  (use-package graphviz-dot-mode)
#+END_SRC
* Development packages - built-in
#+BEGIN_SRC emacs-lisp
  (use-package prog-mode
    :ensure nil
    :config
    (evil-leader/set-key (kbd "<DEL>") 'c-hungry-backspace)
    (evil-define-key 'normal prog-mode-map
      "gd" 'xref-find-definitions
      "gp" 'xref-pop-marker-stack
      "gr" 'xref-find-reference-here
      "g[" 'xref-pop-marker-stack)
    (add-hook 'before-save-hook (lambda () (when (derived-mode-p 'prog-mode)
                                             (delete-trailing-whitespace)))))

  (use-package elec-pair
    :ensure nil
    :hook (prog-mode . electric-pair-mode)
    :config
    (defun electric-pair-delete-pair (arg &optional killp)
      "Custom pair-delete. Delete a closing braket in case of (|), delete a pair
  of inner braket in case of ((|))."
      (interactive "*p\nP")
      (if (memq (char-after (1+ (point))) '(?\) ?\" ?\] ?\} ?\$))
          (delete-char 1)
        (forward-char))
      (backward-delete-char-untabify arg killp)))

  (use-package octave
    :ensure nil
    :mode ("\\.m\\'" . octave-mode)
    :config
    (sk-switch-buffer-repl sk-octave-buffer-repl-toggle
      octave-mode inferior-octave-mode run-octave)
    (evil-leader/set-key-for-mode 'octave-mode
      "eb" 'octave-send-buffer
      "ee" 'octave-send-line
      "ef" 'octave-send-defun
      "er" 'octave-send-region))

  (use-package python
    :ensure nil
    :hook (python-mode . my-python-mode-hook)
    :bind (:map python-mode-map
            ("S-<left>"  . python-indent-shift-left)
            ("S-<right>" . python-indent-shift-right))
    :config
    (setq imenu-create-index-function 'python-imenu-create-index
          python-indent-guess-indent-offset-verbose nil)
    (defun my-python-mode-hook ()
      (setq-local tab-width 4)
      (eglot-ensure))
    (sk-switch-buffer-repl sk-python-buffer-repl-toggle
      python-mode inferior-python-mode
      (lambda ()
        (interactive)
        (pop-to-buffer (process-buffer (call-interactively 'run-python)))))
    (defun my-python-shell-send-line-or-region (n)
      (interactive "p")
      (if (region-active-p)
          (call-interactively 'python-shell-send-region)
        (python-shell-send-region
         (line-beginning-position) (line-end-position n)))
      (setq deactivate-mark t))
    (defun my-python-help-repl ()
      (interactive)
      (move-beginning-of-line 1)
      (insert "help(")
      (move-end-of-line 1)
      (insert ")")
      (comint-send-input))
    (evil-leader/set-key-for-mode 'inferior-python-mode
      "l"  'my-comint-history
      "cd" 'python-describe-at-point
      "ch" 'my-python-help-repl)
    (evil-leader/set-key-for-mode 'python-mode
      "cd" 'python-describe-at-point
      "eb" 'python-shell-send-buffer
      "ee" 'my-python-shell-send-line-or-region
      "ef" 'python-shell-send-defun
      "er" 'python-shell-send-region))

  (use-package xref
    :ensure nil
    :commands xref-find-reference-here
    :bind (:map xref--xref-buffer-mode-map
            ("<return>" . xref-quit-and-goto-xref)
            ("<RET>"    . xref-quit-and-goto-xref))
    :config
    (remove-hook 'xref-backend-functions #'etags--xref-backend)
    (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
    (defun xref-find-reference-here ()
      (interactive)
      (xref-find-references (thing-at-point 'symbol))))

  (use-package gdb-mi
    :ensure nil
    :init
    (advice-add 'gdb-setup-windows :after
                (lambda (&rest _)
                  (set-window-dedicated-p (selected-window) t)))
    :config
    (gdb-many-windows t)
    (dolist (mm '(gdb-edit-locals-map-1
                  gdb-locals-mode-map
                  gdb-locals-watch-map
                  gdb-registers-mode-map
                  gdb-frames-mode-map
                  gdb-breakpoints-mode-map
                  gdb-threads-mode-map))
      (bind-keys :map (symbol-value mm)
                 ("j" . next-line)
                 ("k" . previous-line)))
    (evil-leader/set-key-for-mode 'gud-mode
      "l"  'my-comint-history)
    (evil-leader/set-key-minor-mode 'gdb-many-windows
      "ab" 'gud-break
      "ad" 'gud-remove
      "af" 'gud-finish
      "ai" 'gud-stempi
      "aj" 'gud-jump
      "al" 'gud-refresh
      "an" 'gud-next
      "ap" 'gud-print
      "ar" 'gud-cont
      "as" 'gud-step
      "at" 'gud-tbreak
      "au" 'gud-until
      "aw" 'gud-watch))

  (use-package make-mode
    :ensure nil
    :mode ("Makefile.*" . makefile-gmake-mode))

  (use-package which-func
    :ensure nil
    :hook (prog-mode . my-which-function-setup)
    :custom-face (which-func ((t :inherit font-lock-function-name-face)))
    :config
    (setq which-func-unknown "N/A"
          which-func-update-timer nil)
    (defun my-which-function-setup ()
      (unless (equal major-mode 'lisp-interaction-mode)
        (which-function-mode)
        (setq-local header-line-format 'which-func-format))))

  (use-package sh-script
    :ensure nil
    :hook (sh-mode . (lambda () (sh-electric-here-document-mode -1))))

  (use-package elisp-mode
    :ensure nil
    :config
    (defun my-describe-symbol-at-point ()
      (interactive)
      (describe-symbol (symbol-at-point)))
    (dolist (mm '(emacs-lisp-mode lisp-interaction-mode))
      (evil-leader/set-key-for-mode mm
        "eb" 'eval-buffer
        "ee" 'eval-last-sexp
        "ef" 'eval-defun
        "er" 'eval-region))
    (evil-define-key 'normal emacs-lisp-mode-map
      "gh" 'my-describe-symbol-at-point)
    (evil-define-key 'normal lisp-interaction-mode-map
      "gh" 'my-describe-symbol-at-point))

  (use-package lisp-mode
    :ensure nil
    :custom (emacs-lisp-docstring-fill-column 80))

  (use-package sql
    :ensure nil
    :config
    (evil-leader/set-key-for-mode 'sql-interactive-mode
      "l" 'my-comint-history))

  (use-package cc-mode
    :ensure nil
    :config
    (setq c-basic-offset tab-width
          c-default-style "bsd")
    (defvaralias 'c-basic-offset 'tab-width))

  (use-package compile
    :ensure nil
    :config
    (setq compilation-scroll-output t
          compilation-process-setup-function
          (lambda ()
            (setq-local scroll-conservatively 10000
                        scroll-step 1)))
    (evil-add-hjkl-bindings compilation-mode-map))

  (use-package scheme
    :ensure nil
    :config
    (setq scheme-program-name "chicken-csi")
    (require 'cmuscheme)
    (sk-switch-buffer-repl sk-scheme-buffer-repl-toggle
      scheme-mode inferior-scheme-mode run-scheme)
    (defun my-scheme-eval-last-sexp-or-region (n)
      (interactive "p")
      (let* ((evil-execute-in-emacs-state-buffer t)
             (pos (min (1+ (point)) (point-max)))
             (back (save-excursion (goto-char pos) (backward-sexp) (point))))
        (if (region-active-p)
            (call-interactively 'scheme-send-region)
          (scheme-send-region back pos)))
      (setq deactivate-mark t))
    (defun scheme-send-buffer ()
      (interactive)
      (scheme-send-region (point-min) (point-max)))
    (evil-define-key 'normal inferior-scheme-mode
      (kbd "<return>") 'my-comint-return)
    (evil-leader/set-key-for-mode 'scheme-mode
      "eb" 'scheme-send-buffer
      "ee" 'my-scheme-eval-last-sexp-or-region
      "ef" 'scheme-send-definition
      "er" 'scheme-send-region)
    (evil-leader/set-key-for-mode 'inferior-scheme-mode
      "l" 'my-comint-history))
#+END_SRC
* Development packages - external
#+BEGIN_SRC emacs-lisp
  (use-package ggtags
    :hook ((c-mode-common asm-mode) . ggtags-mode))

  (use-package irony
    :hook ((c++-mode c-mode objc-mode) . irony-mode)
    :config
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

  (use-package paredit
    :hook ((clojure-mode cider-repl-mode emacs-lisp-mode geiser-repl-mode
                         lisp-mode scheme-mode sly-mrepl-mode)
           . enable-paredit-mode)
    :bind (:map paredit-mode-map
            ("M-b" . paredit-backward)
            ("M-f" . paredit-forward)
            ("C-c <left>"  . paredit-forward-barf-sexp)
            ("C-c <right>" . paredit-forward-slurp-sexp))
    :config
    (defun evil-paredit-kill (&rest _)
      (interactive)
      (let ((evil-execute-in-emacs-state-buffer t)
            (pos (point)))
        (when (equal pos (1- (line-end-position)))
          (goto-char (1+ pos)))
        (call-interactively 'paredit-kill)))
    (evil-leader/set-key-minor-mode 'paredit-mode
      "k"  'evil-paredit-kill)
    (evil-define-key 'insert paredit-mode-map
      (kbd "C-k") 'paredit-kill))

  (use-package clojure-mode
    :config
    (require 'cider)
    (defun my-cider-eval-last-sexp-or-region (&rest _)
      (interactive "p")
      (if (region-active-p)
          (call-interactively 'cider-eval-region)
        (save-excursion
          (when (member (clojure-char-at-point)
                        '("\)" "\}" "\]" "\""))
            (goto-char (1+ (point))))
          (call-interactively 'cider-eval-last-sexp)))
      (setq deactivate-mark t))
    (sk-C-c-map-to-leader-c-map 'clojure-mode cider-mode-map)
    (sk-C-c-map-to-leader-c-map 'clojurescript-mode cider-mode-map)
    (dolist (m (list clojure-mode-map clojurescript-mode-map))
      (evil-define-key* 'normal m
        "gd"  'cider-find-dwim
        "gp"  'cider-pop-back
        "ghc" 'cider-clojuredocs
        "ghe" 'cider-apropos-documentation-select
        "ghh" 'cider-doc
        "ghj" 'cider-javadoc
        "ghw" 'cider-clojuredocs-web))
    (dolist (m '(clojure-mode clojurescript-mode))
      (evil-leader/set-key-for-mode m
        "z"   'cider-switch-to-repl-buffer
        "cj"  'cider
        "eb"  'cider-eval-buffer
        "ee"  'my-cider-eval-last-sexp-or-region
        "ef"  'cider-eval-defun-at-point
        "er"  'cider-eval-region
        "epc" 'cider-pprint-eval-last-sexp-to-comment
        "epf" 'cider-pprint-eval-defun-at-point
        "epp" 'cider-pprint-eval-last-sexp
        "esb" 'cider-browse-ns
        "esf" 'cider-find-ns
        "ess" 'cider-repl-set-ns
        "eta" 'cider-test-rerun-test
        "etn" 'cider-test-run-ns-tests
        "etp" 'cider-test-run-project-tests
        "etr" 'cider-test-rerun-failed-tests
        "ett" 'cider-test-run-test
        "evv" 'cider-eval-sexp-at-point
        "evx" 'cider-eval-last-sexp-and-replace)))

  (use-package cider
    :config
    (evil-set-initial-state 'cider-auto-test-mode           'emacs)
    (evil-set-initial-state 'cider-browse-ns-mode           'emacs)
    (evil-set-initial-state 'cider-browse-spec-example-mode 'emacs)
    (evil-set-initial-state 'cider-browse-spec-mode         'emacs)
    (evil-set-initial-state 'cider-browse-spec-view-mode    'emacs)
    (evil-set-initial-state 'cider-docview-mode             'emacs)
    (evil-set-initial-state 'cider-enlighten-mode           'emacs)
    (evil-set-initial-state 'cider-inspector-mode           'emacs)
    (evil-set-initial-state 'cider-repl-history-mode        'emacs)
    (evil-set-initial-state 'cider-stacktrace-mode          'emacs)
    (evil-set-initial-state 'cider-test-report-mode         'emacs)
    (evil-define-key 'normal cider-repl-mode-map
      "gd"  'cider-find-dwim
      "gp"  'cider-pop-back
      "ghc" 'cider-clojuredocs
      "ghe" 'cider-apropos-documentation-select
      "ghh" 'cider-doc
      "ghj" 'cider-javadoc
      "ghw" 'cider-clojuredocs-web
      (kbd "RET") 'my-comint-return)
    (evil-define-minor-mode-key 'normal 'cider-popup-buffer-mode
      "q" 'quit-window)
    (evil-leader/set-key-for-mode 'cider-repl-mode
      "z"  'cider-switch-to-last-clojure-buffer
      "cs" 'cider-repl-set-ns))

  (use-package clj-refactor
    :disabled t
    :mode ("\\.clj\\'" . clojure-mode))

  (use-package sly
    :init
    (setq inferior-lisp-program "sbcl")
    :config
    (setq sly-mrepl-history-file-name
          (expand-file-name ".sly-mrepl-history" user-emacs-directory))
    (evil-set-initial-state 'sly-db-mode                'emacs)
    (evil-set-initial-state 'sly-inspector-mode         'emacs)
    (evil-set-initial-state 'sly-stickers--replay-mode  'emacs)
    (evil-set-initial-state 'sly-xref-mode              'emacs)
    (evil-set-initial-state 'sly-xref-mode              'emacs)
    (defun my-sly-mrepl ()
      (interactive)
      (call-interactively (if (sly-connected-p) 'sly-mrepl 'sly)))
    (sk-C-c-map-to-leader-c-map 'lisp-mode sly-mode-map)
    (evil-leader/set-key-minor-mode 'sly-mode
      "z"   'my-sly-mrepl
      "cb"  'sly-compile-file
      "cf"  'sly-compile-defun
      "cr"  'sly-compile-region
      "eb"  'sly-eval-buffer
      "ee"  'sly-eval-last-expression
      "ef"  'sly-eval-defun
      "er"  'sly-eval-region
      "es"  'sly-mrepl-sync
      "csd" 'sly-stickers-clear-defun-stickers
      "csk" 'sly-stickers-clear-buffer-stickers
      "csr" 'sly-stickers-replay
      "css" 'sly-stickers-dwim
      "csF" 'sly-stickers-forget)
    (evil-leader/set-key-for-mode 'sly-mrepl-mode
      "l"  'my-comint-history
      "z"  'sly-switch-to-most-recent
      "es" 'sly-mrepl-set-package)
    (evil-define-key 'normal sly-mode-map
      "gd" 'sly-edit-definition
      "gh" 'sly-documentation
      "gp" 'sly-pop-find-definition-stack
      "gr" 'sly-edit-uses)
    (evil-define-key 'normal sly-mrepl-mode-map
      "gj" 'sly-mrepl-next-prompt
      "gk" 'sly-mrepl-previous-prompt
      "gd" 'sly-edit-definition
      "gp" 'sly-pop-find-definition-stack
      "gr" 'sly-edit-uses
      (kbd "RET") 'my-comint-return)
    (evil-define-minor-mode-key 'normal 'sly-popup-buffer-mode
      "q"  'quit-window))

  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.ejs\\'" . web-mode)
           ("\\.vue\\'" . web-mode))
    :config
    (setq web-mode-style-padding 0
          web-mode-script-padding 0
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-enable-current-element-highlight t)
    ;; C-c ... bindings to <leader> c... bindings
    (sk-C-c-map-to-leader-c-map 'web-mode web-mode-map))

  (use-package js2-mode
    :mode (("\\.js\\'" . js2-mode)
           ("\\.jsx\\'" . js2-jsx-mode))
    :hook (js2-mode . eglot-ensure)
    :config
    (setq js2-basic-offset 2)
    (add-hook 'js2-mode-hook 'js2-imenu-extras-mode))

  (use-package js2-refactor
    :disabled t
    :config
    (js2r-add-keybindings-with-prefix "C-c C-n"))

  (use-package rjsx-mode
    :disabled
    :hook (find-file
           . (lambda ()
               (and (string-match "\\.js\\'" buffer-file-name)
                    (find-file-in-tree default-directory "next.config.js")
                    (rjsx-mode))))
    :init
    (add-to-list 'auto-mode-alist '("components\\/.*\\.js\\'" . rjsx-mode)))

  (use-package emmet-mode
    :hook ((web-mode js2-mode css-mode) . emmet-mode))

  (use-package go-mode
    :hook (go-mode . eglot-ensure)
    :config
    (setq gofmt-command "goimports")
    (defun my-go-code-hook ()
      (make-local-variable 'before-save-hook)
      (add-hook 'before-save-hook 'gofmt-before-save)
      (setq-local compile-command
                  "go build -v && go test -v && go vet"))
    (add-hook 'go-mode-hook 'my-go-code-hook))

  (use-package format-all)

  (use-package plantuml-mode
    :mode ("\\.puml\\'" . plantuml-mode)
    :bind (:map plantuml-mode-map
            ("C-c C-e" . plantuml-make-output))
    :config
    (setq plantuml-default-exec-mode 'jar
          plantuml-indent-level 4
          plantuml-jar-path "/usr/share/java/plantuml/plantuml.jar")
    (evil-leader/set-key-for-mode 'plantuml-mode
      "ce" 'plantuml-make-output)
    (defun plantuml-make-output ()
      (interactive)
      (set-process-sentinel
       (start-process "plantuml" nil "plantuml" (buffer-file-name))
       (lambda (&rest _) (message "PlantUML process is done")))))

  (use-package haskell-mode
    :hook (haskell-mode . my-haskell-mode-hook)
    :bind (:map haskell-mode-map
            ("M-j" . my-haskell-newline-and-indent-or-guard))
    :config
    (defun my-haskell-mode-hook ()
      (setq-local tab-width 4))
    (defun my-haskell-newline-and-indent-or-guard ()
      (interactive)
      (if (nth 4 (syntax-ppss))         ; if in comment area
          (default-indent-new-line)
        (let ((ch (save-excursion
                    (back-to-indentation)
                    (char-after (point)))))
          (haskell-indentation-newline-and-indent)
          (when (equal ch ?|)
            (insert "| ")))))
    (defun my-haskell-prompt-history ()
      (interactive)
      (my-comint-history 'haskell-interactive-mode-history))
    (defun my-haskell-prompt-kill-whole-line ()
      (interactive)
      (haskell-interactive-mode-bol)
      (execute-kbd-macro "C"))
    (defun my-haskell-prompt-prev (&optional arg)
      (interactive "^p")
      (dotimes (_ (or arg 1))
        (haskell-interactive-mode-prompt-previous)))
    (defun my-haskell-prompt-next (&optional arg)
      (interactive "^p")
      (dotimes (_ (or arg 1))
        (haskell-interactive-mode-prompt-next)))
    (evil-define-key 'normal haskell-mode-map
      "]e" 'haskell-goto-next-error
      "[e" 'haskell-goto-prev-error
      "gd" 'haskell-mode-jump-to-def
      "gh" 'haskell-process-do-info)
    (evil-define-key 'normal haskell-interactive-mode-map
      "0"  'haskell-interactive-mode-bol
      "S"  'my-haskell-prompt-kill-whole-line
      "gd" 'haskell-mode-jump-to-def
      "gj" 'my-haskell-prompt-next
      "gk" 'my-haskell-prompt-prev
      (kbd "RET") 'my-comint-return)
    (evil-leader/set-key-for-mode 'haskell-mode
      "z"  'haskell-interactive-switch
      "ef" 'haskell-process-load-file)
    (evil-leader/set-key-for-mode 'haskell-interactive-mode
      "l" 'my-haskell-prompt-history
      "z" 'haskell-interactive-switch-back))

  (use-package restclient
    :mode ("\\.rest\\'" . restclient-mode)
    :hook (restclient-mode . my-restclient-mode-hook)
    :config
    (defvar restclient-imenu-generic-expression
      '(("GET" "^\\(GET\\)\\(.*\\)" 2)
        ("PUT" "^\\(PUT\\)\\(.*\\)" 2)
        ("POST" "^\\(POST\\)\\(.*\\)" 2)
        ("DELETE" "^\\(DELETE\\)\\(.*\\)" 2)
        ("Variables" "^:\\(.*\\)" 1)))
    (defun my-restclient-mode-hook ()
      (setq imenu-generic-expression restclient-imenu-generic-expression
            imenu-case-fold-search nil))
    (evil-leader/set-key-for-mode 'restclient-mode
      "ec" 'restclient-http-send-current-raw
      "ee" 'restclient-http-send-current-stay-in-window)
    (evil-define-key 'motion restclient-mode-map
      "gj" 'restclient-jump-next
      "gk" 'restclient-jump-prev)
    (evil-define-minor-mode-key 'normal 'restclient-response-mode
      "q"  'quit-window))

  (use-package eglot
    :config
    (require 'projectile)
    (setq my-eglot-projects (make-hash-table :test 'equal)
          eglot-autoshutdown t
          eglot-server-programs
          (append '(((c++-mode c-mode) "ccls")
                    (python-mode
                     . (eglot-pyright . ("pyright-langserver" "--stdio")))
                    ((rust-mode) "rust-analyzer"))
                  eglot-server-programs))
    (defun my-projectile-project-find (dir)
      (let ((root (projectile-project-root dir)))
        (and root (cons 'transient root))))
    (defclass eglot-pyright (eglot-lsp-server) ()
      :documentation "MS pyright Language Server.")
    (cl-defmethod eglot-client-capabilities ((server eglot-pyright))
      "EGLOT LSP client supports for pyright."
      `(:workspace
        (:didChangeWatchedFiles
         (:dynamicRegistration
          ,(if (my-projectile-project-find default-directory)
               t
             :json-false)))))
    (evil-define-minor-mode-key 'normal 'eglot--managed-mode
      "gh" 'eldoc-doc-buffer))

  (use-package rust-mode
    :hook (rust-mode . eglot-ensure)
    :config
    (evil-leader/set-key-for-mode 'rust-mode
      "ee" 'rust-compile
      "er" 'rust-run
      "et" 'rust-test-nocapture)
    (defun rust-test-nocapture ()
      "Test using `cargo test -- --nocapture`"
      (interactive)
      (rust--compile "%s test -- --nocapture" rust-cargo-bin)))

  (use-package lua-mode)

  (use-package cmake-mode
    :config
    (setq cmake-tab-width 4))

  (use-package gnuplot)

  (use-package yaml-mode)

  (use-package eros
    :init (sk-defer-init (eros-mode 1)))
#+END_SRC
* End
** Provide a feature
Make =config.el= available to load by =require=.

#+BEGIN_SRC emacs-lisp
  (provide 'config)
#+END_SRC
