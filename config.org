#+title: SK Emacs configuration
#+author: SeungKi Kim
#+email: tttuuu888@gmail.com

* About
This is my personal Emacs setting.
* Init.el
=init.el= will generate =config.el= from =config.org= and then will load
=config.el=.

=file-name-handler-alist= will be set to =nil= and =gc-cons-threshold= will be
set to =most-positive-fixnum= in order to boost up the speed during the boot
time.

All the other settings will be located in =config.org=.
* Initial settings
** Commentary
This comment will be added on the top of =config.el=.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; config.el --- generated from config.org -*- lexical-binding: t -*-
  ;;
  ;;; Code:
#+END_SRC

** Emacs -init
If Emacs is executed with an =-init= argument, =parallel install= process is
performed.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (member "-init" command-line-args)
    (delete "-init" command-line-args)
    (require 'pinstall "~/.emacs.d/etc/pinstall.el")
    (pinstall-init))
#+END_SRC

** Remove menu-bar, tool-bar, scroll-bar
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (not window-system)
      (custom-set-variables '(menu-bar-mode nil)
                            '(scroll-bar-mode nil)
                            '(tool-bar-mode nil))
    (add-to-list 'default-frame-alist '(menu-bar-lines . 0))
    (add-to-list 'default-frame-alist '(tool-bar-lines . 0))
    (add-to-list 'default-frame-alist '(vertical-scroll-bars)))
#+END_SRC
** Package initialize
Process =package-initialize= first and set =package-archives= for boot time
speed up. =package--initialized= would be set to =nil= at the end of boot up.

#+BEGIN_SRC emacs-lisp :tangle yes
  (package-initialize)
  (setq package-archives
        '(("gnu"   . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org"   . "https://orgmode.org/elpa/")))
#+END_SRC

** User-emacs-directory setting
From this point, =user-emacs-directory= is set to =~/.emacs.d/.local/= so that
all package local files would be hidden under the path.

=emacs-config-dir= would be used instead of =user-emacs-directory=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar emacs-config-dir user-emacs-directory)
  (setq user-emacs-directory (expand-file-name "~/.emacs.d/.local/"))
  (unless (file-exists-p user-emacs-directory)
    (make-directory-internal user-emacs-directory))
#+END_SRC

Set =emacs-etc-dir= to indicate a folder containing extra files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar emacs-etc-dir (expand-file-name "etc/" emacs-config-dir))
  (unless (file-exists-p emacs-etc-dir)
    (make-directory-internal emacs-etc-dir))
#+END_SRC

** Custom file
=custom.el= will be saved under =~/.emacs.d/.local/= but will not be used.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Instead of using =custom.el=, insert the contents of the file directly here.

#+BEGIN_SRC emacs-lisp :tangle yes
  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(ansi-color-names-vector
     ["black" "red3" "green3" "yellow3" "dodger blue" "magenta3" "cyan3" "gray90"])
   '(backup-directory-alist (quote ((".*" . "/tmp/"))))
   '(blink-cursor-mode nil)
   '(c-basic-offset 4)
   '(c-default-style "bsd")
   '(completion-styles (quote (basic partial-completion emacs22 initials)))
   '(css-indent-offset 2)
   '(diary-file "~/Dropbox/org/diary")
   '(ediff-split-window-function (quote split-window-horizontally))
   '(fill-column 80)
   '(font-use-system-font t)
   '(indent-tabs-mode nil)
   '(inhibit-startup-screen t)
   '(make-backup-files nil)
   '(mouse-wheel-progressive-speed nil)
   '(password-cache-expiry 900)
   '(send-mail-function (quote smtpmail-send-it))
   '(size-indication-mode t)
   '(split-height-threshold nil)
   '(split-width-threshold 140)
   '(tab-always-indent (quote complete))
   '(tab-width 4)
   '(use-file-dialog nil)
   '(vc-follow-symlinks nil))
#+END_SRC

** User information
If =USER_FULL_NAME= and =USER_MAIL_ADDRESS= environment variables exist, update
=user_full_name= and =user_mail_address= variables.

#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((name (getenv "USER_FULL_NAME"))
        (mail (getenv "USER_MAIL_ADDRESS")))
    (when name (setq user-full-name name))
    (when mail (setq user-mail-address mail)))
#+END_SRC

** Color setting
Simple color setting function which has 'dark' and 'light' theme.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my-theme-setting (&optional dark-theme)
    (let ((fg-color (if (or dark-theme (not window-system)) "Gray80" "Black"))
          (bg-color (if (or dark-theme (not window-system)) "Gray23" "Ivory2")))
      (set-face-attribute 'default nil
                          :foreground fg-color :background bg-color)
      (set-face-attribute 'fringe nil
                          :background bg-color)
      (set-face-attribute 'header-line nil
                          :background bg-color :underline nil)
      (set-face-attribute 'vertical-border nil
                          :background bg-color)))
  (defun sk-light-theme () (interactive) (my-theme-setting))
  (defun sk-dark-theme  () (interactive) (my-theme-setting t))
#+END_SRC

Enable dark theme.

#+BEGIN_SRC emacs-lisp :tangle yes
  (my-theme-setting t)
#+END_SRC

** Yes-or-no -> y-or-n
Use =y-or-n= instead of =yes-or-no=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** M-up, M-down, M-left, and M-right keys.
M-up,down,left,right keys for moving to windows.

#+BEGIN_SRC emacs-lisp :tangle yes
  (windmove-default-keybindings 'meta)
#+END_SRC

** SK-mode-line
Simple mode line setting function.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun sk-mode-line ()
    (set-face-attribute 'mode-line nil
                        :foreground "Gray2"
                        :box nil)
    (set-face-attribute 'mode-line-inactive nil
                        :foreground "Gray55"
                        :box nil)
    (setq-default
     mode-line-format
     '("%e"
       (:eval
        (let* ((evil-info (if (and (featurep 'evil) evil-mode)
                              (concat " " (upcase (symbol-name evil-state)))
                            ""))
               (buffer-info (concat " %* %I " current-input-method-title))
               (buffer-name (propertize " %b " 'face 'mode-line-emphasis))
               (git-branch (format-mode-line '(vc-mode vc-mode)))
               (vc-info (if vc-mode
                            (concat " (" (substring git-branch 5) ") ")
                          ""))
               (mode-info (propertize
                           (concat " " (format-mode-line mode-name) " ")
                           'face 'mode-line-inactive))
               (line-info (format-mode-line " %l,%3c  "))
               (pos-info (format-mode-line "%p%% "))
               (right-info (concat line-info pos-info))
               (right-length (length right-info))
               (center-fill (propertize
                             " "
                             'face 'mode-line-inactive
                             'display
                             `((space :align-to
                                      (- (+ right right-fringe right-margin)
                                         ,right-length))))))
          (concat
           evil-info
           buffer-info
           buffer-name
           vc-info
           mode-info
           center-fill
           right-info))))))
#+END_SRC

Enable =sk-mode-line=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (sk-mode-line)
#+END_SRC
** SK-utils
Various useful functions.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun sharp-ifdef-insert (start end pre)
    (save-excursion
      (let ((end2 (if (and (equal evil-state 'visual)
                           (equal end (line-beginning-position)))
                      (1- end)
                    end)))
        (goto-char end2) (end-of-line) (insert "\n#endif")
        (goto-char start) (beginning-of-line) (insert pre "\n"))))

  (defun izero-insert (start end)
    "Intesrt #if 0 at the beginning of region and #endif at the end of region"
    (interactive "r")
    (sharp-ifdef-insert start end "#if 0"))

  (defun idef-insert (start end in)
    "Intesrt #ifdef at the beginning of region and #endif at the end of region"
    (interactive "r\nsDefine : ")
    (sharp-ifdef-insert start end (concat "#ifdef " in)))

  (defun find-file-in-tree (dir fname &optional project-root)
    "Find a file looking up to the HOME folder or root folder."
    (let ((file (concat dir fname))
          (parent (unless (or (equal "~" dir) (equal "/" dir))
                    (file-name-directory (directory-file-name dir)))))
      (cond ((and project-root
                  (file-exists-p (concat project-root fname)))
             project-root)
            ((file-exists-p file) dir)
            (parent (find-file-in-tree parent fname))
            (t nil))))

  (defun sk-make ()
    "Find a Makefile path and perform Make"
    (interactive)
    (let ((dir (find-file-in-tree default-directory
                                  "Makefile"
                                  (my-project-root-or-dir))))
      (if (equal dir nil)
          (message "Makefile is not found")
        (compile (concat "export LANG=en_US && make -j8 -C " dir)))))

  (defun sk-clean ()
    "Find a Makefile path and perform Clean"
    (interactive)
    (let ((dir (find-file-in-tree default-directory
                                  "Makefile"
                                  (my-project-root-or-dir))))
      (if (equal dir nil)
          (message "Makefile is not found")
        (compile (concat "export LANG=en_US && make -C " dir " clean")))))

  (defun sk-rebuild ()
    "Find a Makefile path, clean the project and rebuild it."
    (interactive)
    (let ((dir (find-file-in-tree default-directory
                                  "Makefile"
                                  (my-project-root-or-dir))))
      (if (equal dir nil)
          (message "Makefile is not found")
        (call-process "make" nil nil nil "-C" dir "clean")
        (compile (concat "export LANG=en_US && make -j8 -C " dir)))))

  (defun sk-clang-complete-make ()
    "Generate .clang_complete file."
    (interactive)
    (let ((file "./.clang_complete")
          (includes (shell-command-to-string
                     "find -type f -name '*.h' -printf '-I%h\n' | sort -u")))
      (write-region includes nil file)))

  (defun insert-date ()
    "Insert date at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %A")))

  (defun insert-date-and-time ()
    "Insert date and time at point."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %a %p %l:%M")))

  (defun nuke-all-buffers ()
    "kill all buffers, leaving *scratch* only"
    (interactive)
    (mapc (lambda (x) (kill-buffer x))
          (buffer-list))
    (delete-other-windows))

  (defun hide-ctrl-M ()
    "Hides the disturbing '^M' showing up in files containing mixed
  UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))

  (defun move-line (n)
    "Move the current line up or down by N lines."
    (interactive "p")
    (let ((col (current-column))
          (line-text
           (delete-and-extract-region (line-beginning-position)
                                      (line-beginning-position 2))))
      (forward-line n)
      (insert line-text)
      ;; restore point to original column in moved line
      (forward-line -1)
      (forward-char col)))

  (defun transpose-windows ()
    "Swap positions of 2 windows."
    (interactive)
    (let ((buffer1 (window-buffer (selected-window)))
          (buffer2 (window-buffer (select-window (next-window)))))
      (switch-to-buffer buffer1)
      (switch-to-buffer-other-window buffer2)))

  (defun buffer-save-or-load (num &optional restore)
    (if restore
        (progn
          (jump-to-register num)
          (message (concat "Windows are Restored by F" (number-to-string num))))
      (window-configuration-to-register num)
      (message (concat "Windows are saved to F" (number-to-string num)))))

  (defun tmux-running-p ()
    "Check if tmux is currently running or not."
    (zerop (process-file "tmux" nil nil nil "has-session")))

  (defun tmux-new-pane-here ()
    "Open tmux pane of the current path."
    (interactive)
    (if (tmux-running-p)
        (call-process "tmux" nil nil nil "new-window")
      (message "Tmux is not running!")))

  (defun get-week-form (&optional offset date)
    (let* ((_ (require 'cal-iso))
           (d (calendar-absolute-from-gregorian
               (or date (calendar-current-date offset))))
           (day (% d 7))
           (week-number (car (calendar-iso-from-absolute d)))
           (monday (calendar-gregorian-from-absolute (- d (- day 1))))
           (friday (calendar-gregorian-from-absolute (+ d (- 5 day))))
           (month-of-next-friday (if (equal (car monday) (car friday))
                                     ""
                                   (format "%2d월 " (car friday))))
           (start (format "%2d주차  %2d월 %2d일 ~ "
                          week-number
                          (car monday)
                          (nth 1 monday)))
           (end (format "%s%2d일"
                        month-of-next-friday
                        (nth 1 friday))))
      (format "%s%s" start end)))

  (defun sk-insert-current-week-form ()
    (interactive)
    (insert (get-week-form)))

  (defun sk-insert-next-week-form ()
    (interactive)
    (insert (get-week-form 7)))

  (defmacro sk-switch-buffer-repl (name mode repl run-repl)
    "Create NAME function which switch between a file of MODE and a
  REPL. Open REPL with RUN-REPL function if REPL is not yet
  opened."
    (let ((last-mode (intern (concat "my-last-buffer-" (symbol-name mode))))
          (last-repl (intern (concat "my-last-repl-" (symbol-name repl)))))
      `(progn
         (defvar ,last-mode "")
         (defvar ,last-repl "")
         (defun ,name ()
           (interactive)
           (cond ((equal major-mode ',mode)
                  (setq ,last-mode (buffer-name))
                  (if (get-buffer ,last-repl)
                      (pop-to-buffer ,last-repl)
                    (call-interactively ',run-repl)))
                 ((equal major-mode ',repl)
                  (setq ,last-repl (buffer-name))
                  (if (get-buffer ,last-mode)
                      (pop-to-buffer ,last-mode)
                    nil))
                 (t nil))))))
#+END_SRC
** Use-package
Install =use-package= if not exists. Set some default settings for
=use-package=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-always-defer t
        use-package-always-ensure t
        use-package-enable-imenu-support t)
  (put :map 'lisp-indent-function 'defun)
#+END_SRC

Load =use-package=. From this point, only =use-package= will be used for
settings.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'use-package)
#+END_SRC
* General settings
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; Evil-leader and evil
  (use-package evil-leader
    :init
    (defvar sk-evil-sub-leader "M-m")
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "<escape>" 'keyboard-quit
      "0"  'delete-window
      "1"  'delete-other-windows
      "2"  'split-window-below
      "3"  'split-window-right
      ","  'other-window
      "q"  'kill-buffer
      "Q"  'kill-emacs
      "u"  'pop-to-mark-command
      "w"  'save-buffer
      "cc" (kbd "\C-c\C-c")
      "se" 'eshell
      "ss" 'shell
      "st" 'tmux-new-pane-here
      "hk" 'describe-key
      "hm" 'describe-mode
      "xr" 'read-only-mode
      "xv" 'evil-reload-file)
    (defun evil-sub-leader-mode ()
      (let* ((sub-leader (kbd sk-evil-sub-leader))
             (mode-map (cdr (assoc major-mode evil-leader--mode-maps)))
             (map (or mode-map evil-leader--default-map)))
        (evil-normalize-keymaps)
        (define-key evil-motion-state-local-map sub-leader map)
        (define-key evil-insert-state-local-map sub-leader map)
        (define-key evil-emacs-state-local-map sub-leader map)))
    (add-hook 'evil-local-mode-hook #'evil-sub-leader-mode t)
    (defun evil-leader/set-key-minor-mode (mode key def &rest bindings)
      (while key
        (evil-define-minor-mode-key 'motion mode
          (kbd (concat evil-leader/leader key)) def)
        (evil-define-minor-mode-key 'emacs mode
          (kbd (concat sk-evil-sub-leader " " key)) def)
        (evil-define-minor-mode-key 'motion mode
          (kbd (concat sk-evil-sub-leader " " key)) def)
        (evil-define-minor-mode-key 'insert mode
          (kbd (concat sk-evil-sub-leader " " key)) def)
        (setq key (pop bindings)
              def (pop bindings))))
    (put 'evil-leader/set-key-minor-mode 'lisp-indent-function 'defun)
    (setq evil-leader/no-prefix-mode-rx
          '("magit-.*-mode" "gnus-.*-mode" "package-.*-mode" "dired-mode")))

  (use-package evil
    :bind (:map evil-insert-state-map
            ("C-a" . move-beginning-of-line)
            ("C-e" . move-end-of-line)
            ("C-k" . kill-line)
            :map evil-visual-state-map
            ("p"   . evil-paste-pgvy)
            :map evil-ex-completion-map
            ("C-a" . move-beginning-of-line)
            ("C-b" . backward-char)
            ("C-d" . delete-char)
            ("C-k" . kill-line)
            ("M-n" . next-complete-history-element)
            ("M-p" . previous-complete-history-element))
    :custom
    (evil-want-C-u-scroll t)
    :init
    (evil-mode)
    :config
    (setq evil-insert-state-modes (delete 'wdired-mode evil-insert-state-modes))
    (add-hook 'evil-insert-state-entry-hook
              (lambda () (when buffer-read-only (read-only-mode -1))))
    (defun my-shell-return ()
      (interactive)
      (evil-goto-line)
      (evil-append-line 1))
    (defun evil-reload-file ()
      (interactive)
      (find-alternate-file (buffer-file-name)))
    (defun evil-paste-pgvy ()
      "Paste and restore visual block and yank."
      (interactive)
      (call-interactively 'evil-paste-after)
      (evil-visual-restore)
      (call-interactively 'evil-yank))
    (defun evil-swap-key (map key1 key2)
      "Swap KEY1 and KEY2 in MAP"
      (let  ((def1 (lookup-key map key1))
             (def2 (lookup-key map key2)))
        (define-key map key1 def2)
        (define-key map key2 def1)))
    (evil-swap-key evil-motion-state-map "j" "gj")
    (evil-swap-key evil-motion-state-map "k" "gk")
    (evil-global-set-key 'normal "Y" (kbd "y$"))
    (evil-global-set-key 'motion "$" 'end-of-line)
    (dolist (m '(image-mode term-mode))
      (evil-set-initial-state m 'emacs)))


  ;;; Personal packages
  (use-package company-sql
    :ensure nil
    :load-path emacs-etc-dir
    :hook ((sql-mode sql-interactive-mode) . my-sql-mode-hook)
    :config
    (defun my-sql-mode-hook ()
      (add-to-list 'company-backends 'company-sql)))


  ;;; Built-in packages
  (use-package korea-util
    :ensure nil
    :bind ("C-\\" . toggle-korean-input-method)
    :init
    (setq default-korean-keyboard "3")
    (when window-system
      (set-fontset-font t 'hangul (font-spec :name "D2Coding"))
      (set-fontset-font "fontset-default"
                        'greek-iso8859-7
                        '("Unifont Upper" . "iso10646-1")))
    (setup-korean-environment-internal))

  (use-package recentf
    :ensure nil
    :hook (find-file . recentf-mode)
    :custom (recentf-max-saved-items 100)
    :config
    (add-to-list 'recentf-exclude
                 (expand-file-name "elpa/.*" emacs-config-dir)))

  (use-package ido
    :ensure nil
    :config
    (ivy-mode 1)
    (defalias 'ido-completing-read 'ivy-completing-read))

  (use-package calendar
    :ensure nil
    :bind (:map calendar-mode-map
            ("h"       . calendar-backward-day)
            ("j"       . calendar-forward-week)
            ("k"       . calendar-backward-week)
            ("l"       . calendar-forward-day)
            ("C-f"     . calendar-scroll-left-three-months)
            ("C-b"     . calendar-scroll-right-three-months)
            ("<left>"  . calendar-scroll-right)
            ("<right>" . calendar-scroll-left))
    :config
    (evil-set-initial-state 'calendar-mode 'emacs))

  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
            ("M-o"   . dired-omit-mode)
            ("j"     . dired-next-line)
            ("k"     . dired-previous-line)
            ("r"     . ora-dired-rsync)
            ("/"     . evil-search-forward)
            ("^"     . dired-up-and-close-dir)
            ("bp"    . my-dired-pdf-size-down)
            ("<DEL>" . dired-up-and-close-dir)
            ("<RET>" . dired-visit-file-or-dir))
    :init
    (add-to-list 'magic-mode-alist
                 '((lambda () (< large-file-warning-threshold (buffer-size)))
                   . fundamental-mode))
    :config
    (setq dired-listing-switches "-alh --group-directories-first"
          dired-omit-extensions '("~")
          dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..+$")

    (require 'dired-x)
    (add-hook 'dired-mode-hook (lambda () (dired-omit-mode)))

    (evil-set-initial-state 'dired-mode 'emacs)
    (evil-leader/set-key-for-mode 'dired-mode
      "c"  'my-dired-copy-path            ; copy current folder path
      "C"  'my-dired-copy-filepath        ; copy selected file path
      "ee" 'wdired-change-to-wdired-mode
      "ec" 'wdired-finish-edit
      "eq" 'wdired-exit)

    (defun my-dired-copy-path ()
      (interactive)
      (let ((path (expand-file-name default-directory)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun my-dired-copy-filepath ()
      (interactive)
      (let ((path (dired-filename-at-point)))
        (kill-new path)
        (message "Copied path : %s" path)))

    (defun dired-visit-file-or-dir ()
      (interactive)
      (if (file-directory-p (dired-get-filename nil t))
          (dired-find-alternate-file)
        (dired-find-file-other-window)))

    (defun dired-up-and-close-dir (&optional other-window)
      (interactive "P")
      (let ((dir (buffer-name)))
        (dired-up-directory other-window)
        (kill-buffer dir)))

    (defun ora-dired-rsync (&optional arg)
      (interactive "P")
      (let* ((dest (read-file-name "Rsync to: " (dired-dwim-target-directory)))
             (files (dired-get-marked-files nil current-prefix-arg))
             (regex "\\(^/scp.?:\\)\\|\\(^/ssh.?:\\)")
             (prefix (cond ((string-match-p regex dest)
                            (replace-regexp-in-string regex "" dest))
                           ((string-match-p ".@.*:" dest) dest)
                           (t (expand-file-name dest))))
             (cmd (concat "rsync -ahrsvzP "
                          (mapconcat
                           (lambda (f)
                             (concat
                              "\"" (replace-regexp-in-string regex "" f) "\"" ))
                           files " ")
                          " \"" prefix "\""))
             (remote-p (string-match-p regex default-directory))
             (default-directory (if remote-p "~/" default-directory)))
        ;; Run rsync in home folder if remote-p.
        ;; Available for local to local, local to remote, remote to local.
        ;; Remote to remote is not available.
        (async-shell-command cmd "*rsync*")
        (other-window 1)
        (view-mode)))

    (defun my-dired-pdf-size-down ()
      (interactive)
      (let ((display-buffer-alist
             (list (cons
                    "\\*Async Shell Command\\*.*"
                    (cons #'display-buffer-no-window nil))))
            (file (dired-filename-at-point))
            (temp (make-temp-file ".temp" nil ".pdf")))
        (if (not (equal (file-name-extension file) "pdf"))
            (message "Not a PDF file.")
          (async-shell-command
           (concat
            "gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 "
            "-dPDFSETTINGS=/printer -dNOPAUSE -dQUIET -dBATCH -dPrinted=false "
            "-sOutputFile=" temp " " file " && "
            "mv " temp " " file))))))

  (use-package org
    :ensure nil
    :bind (:map org-mode-map
            ("C-c a"   . org-agenda)
            ("C-c b"   . org-switchb)
            ("C-c l"   . org-store-link)
            ("C-c r"   . org-remember)
            ("C-c t"   . org-table-create)
            ("C-c u"   . org-up-element)
            ("C-c e e" . org-edit-src-code))
    :config
    (setq
     org-agenda-files '("~/Dropbox/org/")
     org-babel-load-languages '((css . t)
                                (emacs-lisp . t)
                                (octave . t)
                                (plantuml . t)
                                (python . t)
                                (shell . t))
     org-confirm-babel-evaluate nil
     org-export-default-language "kr"
     org-export-headline-levels 2
     org-export-time-stamp-file nil
     org-export-with-email t
     org-export-with-section-numbers nil
     org-export-with-sub-superscripts nil
     org-footnote-definition-re "^\\[fn:[-_[:word:]]+\\]"
     org-footnote-re (concat "\\[\\(?:fn:\\([-_[:word:]]+\\)?:"
                             "\\|"
                             "\\(fn:[-_[:word:]]+\\)\\)")
     org-html-inline-image-rules
     '(("file" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("http" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'")
       ("https" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|bmp\\)\\'"))
     org-html-metadata-timestamp-format "%Y-%m-%d"
     org-html-validation-link ""
     org-latex-packages-alist '(("" "parskip" nil) ("" "kotex" nil))
     org-log-done 'time
     org-plantuml-jar-path (getenv "PLANTUML_PATH")
     org-src-window-setup 'current-window
     org-startup-indented t
     org-startup-with-inline-images t)
    (evil-leader/set-key-for-mode 'org-mode
      "ca" 'org-agenda
      "cb" 'org-switchb
      "ce" 'org-export-dispatch
      "ci" 'org-insert-link
      "cl" 'org-store-link
      "cr" 'org-remember
      "ct" 'org-table-create
      "ee" 'org-edit-src-code
      "ei" 'org-insert-structure-template
      "tl" 'org-tags-view
      "ts" 'org-set-tags)
    (evil-define-key 'insert org-mode-map
      (kbd "<tab>") 'company-indent-or-complete-common)
    (evil-define-key 'motion org-mode-map
      (kbd "TAB") 'org-cycle
      "gh" 'org-up-element
      "gl" 'org-down-element
      "gj" 'org-forward-element
      "gk" 'org-backward-element)
    (evil-leader/set-key-minor-mode 'org-src-mode
      "ec" 'org-edit-src-exit
      "eq" 'org-edit-src-abort)
    (evil-declare-motion 'org-up-element)
    (evil-declare-motion 'org-down-element)
    (evil-declare-motion 'org-forward-element)
    (evil-declare-motion 'org-backward-element)

    (dolist (mode '("js" "javascript"))
      (add-to-list 'org-src-lang-modes `(,mode . js2)))
    (dolist (mode '("css" "html" "vue" "web"))
      (add-to-list 'org-src-lang-modes `(,mode . web)))

    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages)

    (defun my-org-inline-image-hook ()
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun my-org-inline-css-hook (exporter)
      (when (eq exporter 'html)
        (setq-local org-html-head-include-default-style nil)
        (setq-local org-html-head
                    (concat "<style type=\"text/css\">\n"
                            "<!--/*--><![CDATA[/*><!--*/\n"
                            (with-temp-buffer
                              (insert-file-contents
                               (expand-file-name "org.css" emacs-etc-dir))
                              (buffer-string))
                            "/*]]>*/-->\n"
                            "</style>\n")))
      (when (eq exporter 'reveal)
        (setq-local org-export-with-toc nil)))
    (add-hook 'org-babel-after-execute-hook 'my-org-inline-image-hook)
    (add-hook 'org-export-before-processing-hook 'my-org-inline-css-hook))

  (use-package ibuffer
    :ensure nil
    :bind ("C-x C-b" . ibuffer)
    :init
    (evil-leader/set-key
      "xb" 'ibuffer)
    :config
    (setq ibuffer-expert t
          ibuffer-sorting-mode 'alphabetic
          ibuffer-default-sorting-mode 'major-mode
          ibuffer-saved-filter-groups
          '(("home"
             ("Emacs-config" (or (filename . ".emacs")
                                 (filename . ".emacs.d")
                                 (filename . "emacs-config")))
             ("Org / MD" (or (mode . org-mode)
                             (mode . markdown-mode)
                             (filename . "OrgMode")))
             ("Magit" (mode . magit-status-mode))
             ("Code" (derived-mode . prog-mode))
             ("Shell" (or (mode . shell-mode)
                          (mode . eshell-mode)))
             ("Dired" (mode . dired-mode))
             ("Help" (or (name . "\*Help\*")
                         (name . "\*Apropos\*")
                         (name . "\*info\*"))))))
    (defun my-ibuffer-unmark-all ()
      "Unmark all immdiately"
      (interactive)
      (ibuffer-unmark-all ?\s))
    (define-key ibuffer-mode-map (kbd "* *") 'my-ibuffer-unmark-all)
    (define-ibuffer-column size
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))
    (add-hook 'ibuffer-mode-hook
              '(lambda ()
                 (ibuffer-auto-mode 1)
                 (ibuffer-switch-to-saved-filter-groups "home"))))

  (use-package shell
    :ensure nil
    :config
    (defun my-shell-history ()
      (interactive)
      (my-shell-return)
      (counsel-shell-history))
    (evil-leader/set-key-for-mode 'shell-mode
      "l"  'my-shell-history)
    (evil-define-key 'motion shell-mode-map
      "gk" 'comint-previous-prompt
      "gj" 'comint-next-prompt)
    (evil-define-key 'normal shell-mode-map
      (kbd "RET") 'my-shell-return))

  (use-package eshell
    :ensure nil
    :hook (eshell-mode . my-eshell-setup)
    :config
    (defun eshell/clear ()
      "Clear Eshell buffer"
      (interactive)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (execute-kbd-macro (kbd "<RET>"))))
    (defun my-eshell-change-whole-line ()
      (interactive)
      (execute-kbd-macro (kbd "0C")))
    (defun my-eshell-history ()
      (interactive)
      (my-shell-return)
      (counsel-esh-history))
    (defun my-eshell-setup ()
      (setenv "TERM" "screen-256color")
      (evil-define-key 'insert eshell-mode-map (kbd "C-a") 'eshell-bol)
      (evil-define-key 'normal eshell-mode-map "S" 'my-eshell-change-whole-line)
      (evil-define-key 'motion eshell-mode-map
        "0"  'eshell-bol
        "gk" 'eshell-previous-prompt
        "gj" 'eshell-next-prompt
        (kbd "M-p") (lambda () (interactive) nil)
        (kbd "M-n") (lambda () (interactive) nil)
        (kbd "RET") 'my-shell-return))
    (evil-leader/set-key-for-mode 'eshell-mode
      "l"  'my-eshell-history))

  (use-package cc-cmds
    :ensure nil
    :bind (("C-<backspace>" . c-hungry-backspace)
           ("C-c <DEL>"     . c-hungry-backspace))
    :init
    (evil-leader/set-key (kbd "<DEL>") 'c-hungry-backspace))

  (use-package paren
    :ensure nil
    :init
    (show-paren-mode 1))

  (use-package hl-line
    :ensure nil
    :init
    (global-hl-line-mode 1))

  (use-package ansi-color
    :ensure nil
    :hook (compilation-filter . my-ansi-colorize-buffer)
    :config
    (defun my-ansi-colorize-buffer ()
      (let ((buffer-read-only nil))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (use-package display-line-numbers
    :ensure nil
    :custom-face
    (line-number ((t (:foreground "gray51" :inherit 'default))))
    (line-number-current-line ((t (:inherit 'default))))
    :hook
    ((find-file prog-mode) . display-line-numbers-mode)
    :config
    (setq-default display-line-numbers-width 3
                  display-line-numbers-type 'visual
                  display-line-numbers-current-absolute nil))

  (use-package tramp
    :ensure nil
    :config
    ;; TRAMP respect PATH variable on remote machine.
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path))

  (use-package autorevert
    :hook (find-file . global-auto-revert-mode))

  (use-package view
    :ensure nil
    :hook (view-mode . evil-motion-state))

  (use-package flymake
    :ensure nil
    :config
    (evil-set-initial-state 'flymake-diagnostics-buffer-mode 'emacs)
    (evil-define-key 'motion flymake-mode-map
      "]e" 'flymake-goto-next-error
      "[e" 'flymake-goto-prev-error))



  ;;; External packages
  (use-package evil-anzu
    :demand t
    :after anzu)

  (use-package evil-visualstar
    :bind (:map evil-visual-state-map
            ("n" . evil-visualstar/begin-search-forward)
            ("N" . evil-visualstar/begin-search-backward))
    :config
    (global-evil-visualstar-mode))

  (use-package evil-surround
    :init
    (global-evil-surround-mode 1))

  (use-package evil-commentary
    :init
    (evil-commentary-mode))

  (use-package bind-key
    :init
    (bind-keys*
     ("<mouse-1>"        . nil)
     ("<mouse-3>"        . nil)
     ("<down-mouse-1>"   . nil)
     ("<down-mouse-3>"   . nil)
     ("<drag-mouse-1>"   . nil)
     ("<drag-mouse-3>"   . nil)
     ("<C-down-mouse-1>" . nil)
     ("<M-down-mouse-1>" . nil)
     ("<S-down-mouse-1>" . nil)
     ("C-c <escape>"     . keyboard-quit)
     ("C-x <escape>"     . keyboard-quit)
     ("M-,"              . my-other-window)
     ("<f5>"             . sk-make)
     ("C-<f5>"           . sk-rebuild)
     ("C-M-,"            . transpose-windows)
     ("M-S-<up>"         . (lambda () (interactive) (move-line -1)))
     ("M-S-<down>"       . (lambda () (interactive) (move-line  1)))
     ("<f7>"             . (lambda () (interactive) (buffer-save-or-load 7 t)))
     ("<f8>"             . (lambda () (interactive) (buffer-save-or-load 8 t)))
     ("C-<f7>"           . (lambda () (interactive) (buffer-save-or-load 7)))
     ("C-<f8>"           . (lambda () (interactive) (buffer-save-or-load 8)))
     :map minibuffer-local-map
     ("<escape>"         . minibuffer-keyboard-quit))
    (defun my-other-window ()
      (interactive)
      (if (minibufferp)
          (abort-recursive-edit)
        (call-interactively 'other-window))))

  (use-package company
    :custom-face
    (company-tooltip ((t (:foreground "Black" :background "Yellow3"))))
    :init
    (global-company-mode 1)
    :config
    (setq company-idle-delay 0.3)
    (evil-define-key 'insert company-mode-map
      (kbd "TAB") 'company-indent-or-complete-common))

  (use-package company-irony
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony))

  (use-package company-irony-c-headers
    :demand t
    :after irony
    :config
    (add-to-list 'company-backends 'company-irony-c-headers))

  (use-package company-tern
    :demand t
    :after tern
    :config
    (defun advice-company-tern (&rest _)
      (if (equal major-mode 'web-mode)
          (let ((web-mode-cur-language
                 (web-mode-language-at-pos)))
            (if (or (string= web-mode-cur-language "javascript")
                    (string= web-mode-cur-language "jsx"))
                (unless tern-mode (tern-mode))
              (if tern-mode (tern-mode -1))))))
    (advice-add 'company-tern :before #'advice-company-tern)
    (add-to-list 'company-backends 'company-tern))

  (use-package company-web
    :demand t
    :after web-mode)

  (use-package company-go
    :demand t
    :after go-mode
    :config
    (add-to-list 'company-backends 'company-go))

  (use-package company-ghc
    :demand t
    :after haskell-mode
    :config
    (add-to-list 'company-backends 'company-ghc))

  (use-package slime-company)

  (use-package undo-tree
    :config
    (evil-set-initial-state 'undo-tree-visualizer-mode 'emacs)
    (evil-leader/set-key
      "xu" 'undo-tree-visualize))

  (use-package wgrep
    :commands wgrep-change-to-wgrep-mode
    :bind (:map helm-git-grep-mode-map
            ("C-c C-e" . wgrep-change-to-wgrep-mode)
            ("C-c C-s" . wgrep-save-all-buffers)))

  (use-package helm
    :bind (("M-y"     . helm-show-kill-ring)
           ("C-c i"   . helm-semantic-or-imenu)
           ("C-x C-r" . helm-recentf)
           ("C-c h o" . helm-occur)
           ("C-c h r" . helm-resume)
           :map minibuffer-local-map
           ("M-l"     . helm-minibuffer-history)
           :map helm-map
           ("<escape>". helm-keyboard-quit))
    :init
    (evil-leader/set-key
      "i"  'helm-semantic-or-imenu
      "y"  'helm-show-kill-ring
      "ho" 'helm-occur
      "hr" 'helm-resume)
    :config
    (setq helm-imenu-execute-action-at-once-if-one nil
          helm-split-window-default-side 'right
          helm-show-completion-display-function nil))

  (use-package helm-ag
    :commands (helm-ag-project-or-here helm-ag-here)
    :bind (("C-c j p" . helm-ag-project-or-here)
           ("C-c j P" . helm-ag-here))
    :init
    (evil-leader/set-key
      "jp" 'helm-ag-project-or-here
      "jP" 'helm-ag-here)
    :config
    (setq helm-ag-insert-at-point 'symbol
          helm-ag-use-grep-ignore-list t)
    (defun helm-ag-project-or-here ()
      (interactive)
      (helm-do-ag
       (my-project-root-or-dir)
       (car (projectile-parse-dirconfig-file))))
    (defun helm-ag-here ()
      (interactive)
      (helm-do-ag default-directory)))

  (use-package helm-git-grep
    :bind (("C-c p" . helm-git-grep-at-point))
    :init
    (evil-leader/set-key
      "p" 'helm-git-grep-at-point))

  (use-package projectile
    :commands (my-project-root-or-dir
               sk-add-known-project
               sk-remove-known-project)
    :bind (("C-c j d" . projectile-find-dir)
           ("C-c j k" . projectile-kill-buffers)
           ("C-c j b" . projectile-switch-to-buffer)
           ("C-c j s" . projectile-switch-project)
           ("C-c j S" . projectile-save-project-buffers))
    :init
    (evil-leader/set-key
      "jd" 'projectile-find-dir
      "jk" 'projectile-kill-buffers
      "jb" 'projectile-switch-to-buffer
      "js" 'projectile-switch-project
      "jS" 'projectile-save-project-buffers)
    :config
    (setq projectile-completion-system 'ivy
          projectile-require-project-root nil
          projectile-switch-project-action 'projectile-dired
          projectile-track-known-projects-automatically nil)
    (projectile-mode 1)
    (defun my-project-root-or-dir ()
      (or (projectile-project-root) default-directory))
    (defun sk-add-known-project (project-root)
      "Make .projectile file and add the project to known projects list."
      (interactive (list (read-directory-name "Add to known projects: ")))
      (let ((pfile (concat project-root ".projectile")))
        (unless (file-exists-p pfile)
          (write-region "" nil pfile)))
      (projectile-add-known-project project-root))
    (defalias 'sk-remove-known-project 'projectile-remove-known-project))

  (use-package markdown-mode)

  (use-package markdown-toc)

  (use-package ox-reveal
    :demand t
    :after org
    :custom (org-reveal-note-key-char nil)
    :config
    (setq org-reveal-center t
          org-reveal-hlevel 2
          org-reveal-plugins '(classList markdown highlight zoom notes)
          org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"
          org-reveal-theme "moon"
          org-reveal-title-slide "<h2>%t</h2><h4>%a&nbsp(%e)</h4>"
          org-reveal-transition "none"))

  (use-package neotree
    :commands my-neotree-directory
    :bind (("C-c n" . my-neotree-directory)
           :map neotree-mode-map
           ("u" . neotree-select-up-node)
           ("y" . (lambda ()
                    "Copy the absolute path of the node at point."
                    (interactive)
                    (message "Copied path : %s"
                             (neotree-copy-filepath-to-yank-ring)))))
    :init
    (evil-leader/set-key
      "n" 'my-neotree-directory)
    :config
    (evil-set-initial-state 'neotree-mode 'emacs)
    (defun my-neotree-directory ()
      (interactive)
      (if (neo-global--window-exists-p)
          (neotree-hide)
        (neotree-dir (my-project-root-or-dir)))))

  (use-package magit
    :bind ("<f12>" . magit-status)
    :hook (with-editor-mode . evil-normal-state)
    :init
    (evil-leader/set-key
      "gs" 'magit-status
      "gb" 'magit-blame)
    :config
    (setq magit-log-section-commit-count 5
          magit-completing-read-function #'ivy-completing-read)
    (evil-leader/set-key-minor-mode 'with-editor-mode
      "ck" 'with-editor-cancel)
    (bind-key "<escape>" 'transient-quit-one transient-map)
    (evil-make-overriding-map magit-blame-read-only-mode-map 'normal)
    (add-hook 'magit-blame-mode-hook 'evil-normalize-keymaps))

  (use-package expand-region
    :bind (("C-="   . er/expand-region)
           ("C-c =" . er/expand-region))
    :init
    (evil-leader/set-key
      "=" 'er/expand-region)
    :config
    ;; redefine the function to ignore error
    (defun er/save-org-mode-excursion (action)
      "Save outline visibility while expanding in org-mode"
      (ignore-errors
        (org-save-outline-visibility t
          (funcall action)))))

  (use-package smex
    :commands smex)

  (use-package anzu
    :init
    (defun isearch-anzu-advice (&rest _)
      (global-anzu-mode 1))
    (advice-add #'isearch-forward :before #'isearch-anzu-advice)
    (advice-add #'isearch-backward :before #'isearch-anzu-advice)
    :config
    (setq anzu-search-threshold 1000
          anzu-replace-threshold 1000)
    (advice-remove #'isearch-forward #'isearch-anzu-advice)
    (advice-remove #'isearch-backward #'isearch-anzu-advice))

  (use-package htmlize
    :demand t
    :after org)

  (use-package korean-holidays
    :init
    (setq calendar-holidays korean-holidays))

  (use-package visual-regexp
    :bind (("C-c r" . vr/replace)
           ("C-c q" . vr/query-replace)
           :map evil-motion-state-map
           ("gR"    . vr/replace)
           ("gQ"    . vr/query-replace)))

  (use-package visual-regexp-steroids
    :demand t
    :after visual-regexp)

  (use-package fzf
    :bind (("C-c j o" . fzf)
           ("C-c j h" . fzf-here)
           ("C-c o"   . fzf-git-files))
    :init
    (evil-leader/set-key
      "jh" 'fzf-here
      "jo" 'fzf
      "o"  'fzf-git-files)
    :config
    (setq fzf/window-height 20)
    (require 'term)
    (defun term-send-esc ()
      "Send ESC in term mode."
      (interactive)
      (term-send-raw-string "\e"))
    ;; to quit fzf with ESC key
    (define-key term-raw-map (kbd "<escape>") 'term-send-esc)
    (defun fzf-here ()
      (interactive)
      (fzf/start default-directory)))

  (use-package yasnippet
    :commands yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs (expand-file-name "snippets/" emacs-etc-dir))
    (yas-reload-all))

  (use-package yasnippet-snippets
    :demand t
    :after yasnippet)

  (use-package ivy
    :bind (("C-x b"    . ivy-switch-buffer)
           :map minibuffer-inactive-mode-map
           ("<escape>" . abort-recursive-edit)
           :map ivy-minibuffer-map
           ("<escape>" . minibuffer-keyboard-quit)
           ("C-j"      . ivy-partial)
           ("TAB"      . ivy-alt-done))
    :init
    (evil-leader/set-key
      "b" 'ivy-switch-buffer)
    :config
    (setq ivy-height 15
          ivy-height-alist '((t . 15))
          ivy-wrap t
          ivy-fixed-height-minibuffer t
          ;; Don't use ^ as initial input
          ivy-initial-inputs-alist nil
          ;; disable magic slash on non-match
          ivy-magic-slash-non-match-action nil
          ;; prefix match first
          ivy-sort-matches-functions-alist
          '((t . ivy--prefix-sort)
            (ivy-switch-buffer . ivy-sort-function-buffer)))
    (require 'subr-x)
    (ivy-mode 1)
    (when window-system
      (ivy-posframe-mode 1))
    (defun my-comint-history ()
      (interactive)
      (my-shell-return)
      (ivy-read "Symbol name: " (ring-elements comint-input-ring)
                :action (lambda (cmd) (insert cmd))))
    (defun sk-ivy-buffer-transformer (str)
      (let* ((buf (get-buffer str))
             (buf-dir (buffer-local-value 'default-directory buf))
             (buf-mode (buffer-local-value 'major-mode buf))
             (mode (capitalize
                    (string-remove-suffix "-mode" (symbol-name buf-mode))))
             (max-path-len (max 0 (- (frame-width) 63)))
             (path-dir (abbreviate-file-name (or buf-dir "~/")))
             (path-file (when-let ((name (buffer-file-name buf)))
                          (abbreviate-file-name name)))
             (path-opt (or path-file
                           (when (or (string-match-p "shell" str)
                                     (equal buf-mode 'dired-mode))
                             path-dir)))
             (path-prefix (if (string-prefix-p "~" path-opt)
                              "~/"
                            "/"))
             (path-len (length path-opt))
             (path-mod (if (<= path-len max-path-len)
                           nil
                         (substring path-opt (- path-len max-path-len) path-len)))
             (path (if path-mod
                       (concat path-prefix
                               "…"
                               (replace-regexp-in-string "^[^~/]*" "" path-mod))
                     path-opt)))
        (format "%-35s %-20s %s" buf mode (or path ""))))
    (ivy-set-display-transformer 'ivy-switch-buffer 'sk-ivy-buffer-transformer))

  (use-package ivy-yasnippet
    :init
    (evil-leader/set-key "/" 'ivy-yasnippet)
    :config
    (advice-add 'ivy-yasnippet :before (lambda ()
                                         (yas-minor-mode 1)
                                         (evil-insert-state))))
  (use-package ivy-posframe
    :custom-face
    (ivy-posframe
     ((((class color) (min-colors 88) (background light))
       (:background "ivory3" :foreground "black"))
      (((class color) (min-colors 88) (background dark))
       (:background "#282a36" :foreground "gray80"))))
    (ivy-posframe-border ((t (:inherit ivy-posframe))))
    :config
    (setq ivy-posframe-border-width 20
          ivy-posframe-display-functions-alist
          '((complete-symbol . nil)
            (ivy-yasnippet   . nil)
            (swiper          . nil)
            (t               . ivy-posframe-display-at-frame-center))))

  (use-package posframe)

  (use-package counsel
    :commands counsel-fzf-here
    :bind (("M-x"     . counsel-M-x)
           ("C-x d"   . counsel-find-file)
           ("C-x C-f" . counsel-find-file)
           ("C-h b"   . counsel-descbinds)
           ("C-h v"   . counsel-describe-variable)
           ("C-h f"   . counsel-describe-function))
    :init
    (evil-leader/set-key
      "<SPC>" 'counsel-M-x
      "M-m"   'counsel-M-x
      "d"     'counsel-find-file
      "f"     'counsel-find-file
      "r"     'counsel-recentf
      "hb"    'counsel-descbinds
      "hv"    'counsel-describe-variable
      "hf"    'counsel-describe-function
      "jc"    'counsel-fzf-here)
    :config
    (setq ivy-height-alist '((t . 15)))
    (defun counsel-fzf-here ()
      (interactive)
      (counsel-fzf nil default-directory)))

  (use-package which-key
    :init
    (which-key-mode))
#+END_SRC
* Development settings
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; Built-in packages
  (use-package prog-mode
    :ensure nil
    :config
    (evil-define-key 'normal prog-mode-map
      "gd" 'xref-find-definitions
      "gp" 'xref-pop-marker-stack
      "gr" 'xref-find-reference-here
      "g[" 'xref-pop-marker-stack)
    (add-hook 'before-save-hook (lambda () (when (derived-mode-p 'prog-mode)
                                             (delete-trailing-whitespace)))))

  (use-package elec-pair
    :ensure nil
    :hook (prog-mode . electric-pair-mode)
    :config
    (defun electric-pair-delete-pair (arg &optional killp)
      "Custom pair-delete. Delete a closing braket in case of (|),
  delete a pair of inner braket in case of ((|))."
      (interactive "*p\nP")
      (if (memq (char-after (1+ (point))) '(?\) ?\" ?\] ?\} ?\$))
          (delete-char 1)
        (forward-char))
      (backward-delete-char-untabify arg killp)))

  (use-package octave
    :ensure nil
    :mode ("\\.m\\'" . octave-mode)
    :config
    (sk-switch-buffer-repl sk-octave-buffer-repl-toggle
                           octave-mode
                           inferior-octave-mode
                           run-octave)
    (evil-leader/set-key-for-mode 'inferior-octave-mode
      "z" 'sk-octave-buffer-repl-toggle)
    (evil-leader/set-key-for-mode 'octave-mode
      "z"  'sk-octave-buffer-repl-toggle
      "eb" 'octave-send-buffer
      "ee" 'octave-send-line
      "ef" 'octave-send-defun
      "er" 'octave-send-region))

  (use-package python
    :ensure nil
    :commands sk-toggle-python
    :config
    (setq imenu-create-index-function 'python-imenu-create-index)
    (elpy-enable)
    (defun sk-toggle-python ()
      "Toggle between Python2 and Python3"
      (interactive)
      (let* ((ret (shell-command-to-string
                   (concat elpy-rpc-python-command " --version")))
             (ver (substring (cadr (split-string ret)) 0 1))
             (python (if (equal ver "3") "python2" "python3")))
        (setq python-shell-interpreter python
              elpy-rpc-python-command python)
        (message (concat "Toggled to " python)))))

  (use-package xref
    :ensure nil
    :commands xref-find-reference-here
    :bind (:map xref--xref-buffer-mode-map
            ("<return>" . xref-quit-and-goto-xref)
            ("<RET>"    . xref-quit-and-goto-xref))
    :config
    (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
    (defun xref-find-reference-here ()
      (interactive)
      (xref-find-references (thing-at-point 'symbol))))

  (use-package gdb-mi
    :ensure nil
    :init
    (advice-add 'gdb-setup-windows :after
                (lambda (&rest _)
                  (set-window-dedicated-p (selected-window) t)))
    :config
    (gdb-many-windows t)
    (dolist (mm '(gdb-edit-locals-map-1
                  gdb-locals-mode-map
                  gdb-locals-watch-map
                  gdb-registers-mode-map
                  gdb-frames-mode-map
                  gdb-breakpoints-mode-map
                  gdb-threads-mode-map))
      (bind-keys :map (symbol-value mm)
                 ("j" . next-line)
                 ("k" . previous-line)))
    (evil-define-key 'normal gud-mode-map
      (kbd "RET") 'my-shell-return)
    (evil-leader/set-key-for-mode 'gud-mode
      "l"  'my-comint-history)
    (evil-leader/set-key-minor-mode 'gdb-many-windows
      "ab" 'gud-break
      "ad" 'gud-remove
      "af" 'gud-finish
      "ai" 'gud-stempi
      "aj" 'gud-jump
      "al" 'gud-refresh
      "an" 'gud-next
      "ap" 'gud-print
      "ar" 'gud-cont
      "as" 'gud-step
      "at" 'gud-tbreak
      "au" 'gud-until
      "aw" 'gud-watch))

  (use-package make-mode
    :ensure nil
    :mode ("Makefile.*" . makefile-gmake-mode))

  (use-package which-func
    :ensure nil
    :hook ((c-mode-common python-mode js-mode) . my-which-function-setup)
    :custom-face (which-func ((t (:inherit font-lock-function-name-face))))
    :config
    (setq which-func-unknown "N/A")
    (defun my-which-function-setup ()
      (which-function-mode)
      (setq-local header-line-format 'which-func-format)))

  (use-package sh-script
    :ensure nil
    :hook (sh-mode . (lambda () (sh-electric-here-document-mode -1))))

  (use-package scheme
    :ensure nil
    :config
    (require 'geiser)
    (sk-switch-buffer-repl sk-scheme-buffer-repl-toggle
                           scheme-mode
                           geiser-repl-mode
                           run-geiser)
    (evil-leader/set-key-for-mode 'geiser-repl-mode
      "z"  'sk-scheme-buffer-repl-toggle)
    (evil-leader/set-key-for-mode 'scheme-mode
      "z"  'sk-scheme-buffer-repl-toggle
      "eb" 'geiser-eval-buffer
      "ee" 'geiser-eval-last-sexp
      "ef" 'geiser-eval-definition
      "er" 'geiser-eval-region))

  (use-package elisp-mode
    :ensure nil
    :config
    (dolist (mm '(emacs-lisp-mode lisp-interaction-mode))
      (evil-leader/set-key-for-mode mm
        "eb" 'eval-buffer
        "ee" 'eval-last-sexp
        "ef" 'eval-defun
        "er" 'eval-region)))

  ;;; External packages
  (use-package cff
    :init
    (add-hook 'c-mode-common-hook
              (lambda () (local-set-key (kbd "M-o") 'cff-find-other-file))))

  (use-package ggtags
    :hook ((c-mode-common asm-mode) . ggtags-mode)
    :config
    (evil-define-key 'normal ggtags-mode-map
      "gd" 'ggtags-find-tag-dwim
      "gr" 'ggtags-find-reference)
    (evil-define-key 'motion ggtags-navigation-mode-map
      (kbd "RET") 'ggtags-navigation-mode-done))

  (use-package irony
    :hook ((c++-mode c-mode objc-mode) . irony-mode)
    :config
    (defun my-irony-mode-hook ()
      (define-key irony-mode-map [remap completion-at-point]
        'irony-completion-at-point-async)
      (define-key irony-mode-map [remap complete-symbol]
        'irony-completion-at-point-async)
      (irony-cdb-autosetup-compile-options))
    (add-hook 'irony-mode-hook 'my-irony-mode-hook))

  (use-package flycheck
    :disabled t
    :hook ((c-mode c++-mode) . flycheck-mode))

  (use-package rtags
    :disabled t
    :commands my-rtags-index
    :init
    (add-hook 'c-mode-common-hook 'rtags-start-process-unless-running)
    :config
    (require 'helm-utils)
    (require 'helm-rtags)
    (setq rtags-autostart-diagnostics t
          rtags-use-helm t)
    (rtags-enable-standard-keybindings)
    (rtags-start-process-unless-running)
    (add-hook 'kill-emacs-hook 'rtags-quit-rdm)
    (defun my-rtags-index ()
      (interactive)
      (let ((dir (find-file-in-tree (file-name-directory default-directory)
                                    "compile_commands.json"
                                    (my-project-root-or-dir))))
        (if (equal dir nil)
            (message "You can make 'compile_commands.json' by 'bear make'.")
          (shell-command (concat "rc -J " dir))))))

  (use-package xcscope
    :disabled t
    :hook ((c-mode-common asm-mode) . cscope-minor-mode))

  (use-package elpy
    :config
    (evil-leader/set-key-for-mode 'inferior-python-mode
      "l"  'my-comint-history
      "z"  'elpy-shell-switch-to-buffer)
    (evil-leader/set-key-for-mode 'python-mode
      "z"  'elpy-shell-switch-to-shell
      "eb" 'elpy-shell-send-buffer
      "ec" 'elpy-shell-send-defclass
      "ee" 'elpy-shell-send-statement
      "ef" 'elpy-shell-send-defun
      "er" 'elpy-shell-send-region-or-buffer)
    (evil-define-key 'normal inferior-python-mode-map
      "gk" 'comint-previous-prompt
      "gj" 'comint-next-prompt
      (kbd "RET") 'my-shell-return))

  (use-package paredit
    :hook ((clojure-mode emacs-lisp-mode lisp-mode scheme-mode geiser-repl-mode)
           . enable-paredit-mode)
    :bind (:map paredit-mode-map
            ("M-b" . paredit-backward)
            ("M-f" . paredit-forward)
            ("M-n" . paredit-forward-up)
            ("M-p" . paredit-backward-down)
            ("C-c <left>"  . paredit-forward-barf-sexp)
            ("C-c <right>" . paredit-forward-slurp-sexp))
    :config
    (defun evil-paredit-kill (&rest _)
      (interactive)
      (if (and (equal (point) (- (line-end-position) 1))
               (equal evil-state 'normal))
          (progn
            (evil-append 1)
            (call-interactively 'paredit-kill)
            (evil-normal-state nil)
            (evil-forward-char))
        (call-interactively 'paredit-kill)))
    (evil-define-key 'insert paredit-mode-map (kbd "C-k") 'paredit-kill)
    (evil-leader/set-key-minor-mode 'paredit-mode
      "k"  'evil-paredit-kill))

  (use-package clojure-mode
    :config
    (evil-define-key 'normal clojure-mode-map
      "gd" 'cider-find-dwim
      "gp" 'cider-pop-back)
    (evil-leader/set-key-for-mode 'clojure-mode
      "z"  'cider-switch-to-repl-buffer
      "eb" 'cider-eval-buffer
      "ee" 'cider-eval-last-sexp
      "er" 'cider-eval-region
      "ex" 'cider-eval-last-sexp-and-replace))

  (use-package cider
    :commands cider-jack-in
    :config
    (evil-set-initial-state 'cider-auto-test-mode           'emacs)
    (evil-set-initial-state 'cider-browse-ns-mode           'emacs)
    (evil-set-initial-state 'cider-browse-spec-example-mode 'emacs)
    (evil-set-initial-state 'cider-browse-spec-mode         'emacs)
    (evil-set-initial-state 'cider-browse-spec-view-mode    'emacs)
    (evil-set-initial-state 'cider-docview-mode             'emacs)
    (evil-set-initial-state 'cider-enlighten-mode           'emacs)
    (evil-set-initial-state 'cider-inspector-mode           'emacs)
    (evil-set-initial-state 'cider-popup-buffer-mode        'emacs)
    (evil-set-initial-state 'cider-repl-history-mode        'emacs)
    (evil-set-initial-state 'cider-stacktrace-mode          'emacs)
    (evil-set-initial-state 'cider-test-report-mode         'emacs)
    (evil-define-key 'normal cider-repl-mode-map
      "gd"        'cider-find-dwim
      "gp"        'cider-pop-back
      (kbd "RET") 'my-shell-return)
    (evil-leader/set-key-for-mode 'clojurescript-mode
      "z"  'cider-switch-to-repl-buffer)
    (evil-leader/set-key-for-mode 'cider-repl-mode
      "z"  'cider-switch-to-last-clojure-buffer))

  (use-package clj-refactor
    :disabled t
    :mode ("\\.clj\\'" . clojure-mode))

  (use-package slime
    :commands slime
    :init
    (setq inferior-lisp-program "clisp"
          slime-contribs '(slime-fancy))
    :config
    (slime-setup '(slime-fancy slime-company))
    (setq slime-completion-at-point-functions 'slime-fuzzy-complete-symbol)
    (sk-switch-buffer-repl sk-slime-buffer-repl-toggle
                           lisp-mode
                           slime-repl-mode
                           slime)
    (evil-leader/set-key-minor-mode 'slime-mode
      "z"  'sk-slime-buffer-repl-toggle
      "eb" 'slime-eval-buffer
      "ee" 'slime-eval-last-expression
      "ef" 'slime-eval-defun
      "er" 'slime-eval-region)
    (evil-leader/set-key-for-mode 'slime-repl-mode
      "z"  'sk-slime-buffer-repl-toggle)
    (evil-define-key 'motion slime-mode-map
      "gd" 'slime-edit-definition
      "gp" 'slime-pop-find-definition-stack)
    (evil-define-key 'motion slime-repl-mode-map
      "gj" 'slime-repl-next-prompt
      "gk" 'slime-repl-previous-prompt
      "gd" 'slime-edit-definition
      "gp" 'slime-pop-find-definition-stack
      (kbd "RET") 'my-shell-return))

  (use-package geiser
    :commands geiser run-geiser
    :init
    (remove-hook 'scheme-mode-hook 'geiser-mode--maybe-activate)
    :config
    (geiser-mode--maybe-activate))

  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.ejs\\'" . web-mode)
           ("\\.vue\\'" . web-mode))
    :config
    (setq web-mode-style-padding 0
          web-mode-script-padding 0
          web-mode-css-indent-offset 2
          web-mode-code-indent-offset 2
          web-mode-markup-indent-offset 2
          web-mode-enable-current-element-highlight t)
    (require 'cl)
    (defun tree-assoc (key tree)
      (when (consp tree)
        (destructuring-bind (x . y)  tree
          (if (eql x key) tree
            (or (tree-assoc key x) (tree-assoc key y))))))
    (defmacro code-to-key (code)
      `(key-description (vector ,code)))
    (defun cc-map-to-evil-leader-map (mode ori1 ori2 con1 con2)
      "Find bindings start with ori1 ori2 from mode-map and
  convert it to corresponding evil-leader map. For example, all
  bindings of C-c C-e X is converted to leader c e X by below:
  '(cc-map-to-evil-leader-map ?\C-c ?\C-e c e)'"
      (let* ((map (symbol-value (intern (concat (symbol-name mode) "-map"))))
             (cc-maps (thread-last map (tree-assoc ori1) (tree-assoc ori2) cddr)))
        (dolist (pair cc-maps)
          (let ((key (car pair))
                (func (cdr pair)))
            (evil-leader/set-key-for-mode mode
              (concat con1 con2 (code-to-key key)) func)))))
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-a "c" "a")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-b "c" "b")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-d "c" "d")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-e "c" "e")
    (cc-map-to-evil-leader-map 'web-mode ?\C-c ?\C-t "c" "t")
    (defun my-web-mode-hook ()
      (setq-local
       company-backends
       '(company-tern company-web-html company-yasnippet company-files)))
    (add-hook 'web-mode-hook 'my-web-mode-hook))

  (use-package js2-mode
    :mode (("\\.js\\'" . js2-mode)
           ("\\.jsx\\'" . js2-jsx-mode))
    :config
    (setq js2-basic-offset 2
          js2-strict-missing-semi-warning nil)
    (add-to-list 'company-backends 'company-tern)
    (add-hook 'js2-mode-hook (lambda () (js2-imenu-extras-mode))))

  (use-package js2-refactor
    :disabled t
    :config
    (js2r-add-keybindings-with-prefix "C-c C-n"))

  (use-package rjsx-mode
    :init
    (add-to-list 'auto-mode-alist '("components\\/.*\\.js\\'" . rjsx-mode))
    (add-hook 'find-file-hook
              (lambda ()
                (when
                    (and (string-match "\\.js\\'" buffer-file-name)
                         (find-file-in-tree default-directory "next.config.js"))
                  (rjsx-mode)))))

  (use-package emmet-mode
    :hook ((web-mode js2-mode css-mode) . emmet-mode))

  (use-package tern
    :hook ((web-mode js2-mode css-mode) . my-tern-hook)
    :config
    (evil-define-key 'normal tern-mode-keymap
      "gd" 'tern-find-definition
      "gp" 'tern-pop-find-definition
      "gr" 'xref-find-reference-here
      "g[" 'xref-pop-marker-stack)
    (defun my-tern-hook ()
      (evil-normalize-keymaps)
      (tern-mode)
      (yas-minor-mode)))

  (use-package go-mode
    :bind (:map go-mode-map
            ("M-." . godef-jump))
    :config
    (setq gofmt-command "goimports")
    (evil-define-key 'normal go-mode-map
      "gd" 'godef-jump
      "gp" 'xref-pop-marker-stack
      "gr" 'xref-find-reference-here
      "g[" 'xref-pop-marker-stack)
    (defun my-go-code-hook ()
      (evil-normalize-keymaps)
      (make-local-variable 'before-save-hook)
      (add-hook 'before-save-hook 'gofmt-before-save)
      (setq-local compile-command
                  "go build -v && go test -v && go vet"))
    (add-hook 'go-mode-hook 'my-go-code-hook))

  (use-package format-all)

  (use-package plantuml-mode
    :mode ("\\.puml\\'" . plantuml-mode)
    :bind (:map plantuml-mode-map
            ("C-c C-e" . plantuml-make-output))
    :config
    (setq plantuml-jar-path (getenv "PLANTUML_PATH"))
    (evil-leader/set-key-for-mode 'plantuml-mode
      "ce" 'plantuml-make-output)
    (defun plantuml-make-output ()
      (interactive)
      (set-process-sentinel
       (start-process "plantuml" nil "plantuml" (buffer-file-name))
       (lambda (&rest _) (message "PlantUML process is done")))))

  (use-package haskell-mode
    :hook (haskell-mode . my-haskell-mode-hook)
    :config
    (defun my-haskell-mode-hook ()
      (setq-local tab-width 4))
    (sk-switch-buffer-repl sk-haskell-buffer-repl-toggle
                           haskell-mode
                           inferior-haskell-mode
                           run-haskell)
    (evil-leader/set-key-for-mode 'inferior-haskell-mode
      "z" 'sk-haskell-buffer-repl-toggle)
    (evil-leader/set-key-for-mode 'haskell-mode
      "z" 'sk-haskell-buffer-repl-toggle))

  (use-package restclient
    :mode ("\\.rest\\'" . restclient-mode)
    :hook (restclient-mode . my-restclient-mode-hook)
    :config
    (defvar restclient-imenu-generic-expression
      '(("GET" "^\\(GET\\)\\(.*\\)" 2)
        ("PUT" "^\\(PUT\\)\\(.*\\)" 2)
        ("POST" "^\\(POST\\)\\(.*\\)" 2)
        ("DELETE" "^\\(DELETE\\)\\(.*\\)" 2)
        ("Variables" "^:\\(.*\\)" 1)))
    (defun my-restclient-mode-hook ()
      (setq imenu-generic-expression restclient-imenu-generic-expression
            imenu-case-fold-search nil))
    (evil-leader/set-key-for-mode 'restclient-mode
      "ec" 'restclient-http-send-current-raw
      "ee" 'restclient-http-send-current-stay-in-window)
    (evil-define-key 'motion restclient-mode-map
      "gj" 'restclient-jump-next
      "gk" 'restclient-jump-prev))

  (use-package eglot
    :config
    (require 'projectile)
    (defun my-projectile-project-find (dir)
      (let ((root (projectile-project-root dir)))
        (and root (cons 'transient root))))
    (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
    (add-to-list 'project-find-functions 'my-projectile-project-find)
    (evil-define-key 'normal eglot-mode-map
      "gh" 'eglot-help-at-point))

  (use-package rust-mode
    :hook (rust-mode . eglot-ensure))
#+END_SRC
* End
** After init
Set =package--initialized= to =nil= to prevent that all the packages from
=package-list-packages= become new packages. Still it is required to execute
=M-x package-initialize= manually in some cases.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq package--initialized nil)
#+END_SRC
** Provide a feature
Make =config.el= available to load by =require=.

#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'config)
#+END_SRC
